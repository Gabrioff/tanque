<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Solana Memecoin Simulator</title>
    <!-- Cargar Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Cargar Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Cargar anotaciones de Chart.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chartjs-plugin-annotation/3.0.1/chartjs-plugin-annotation.min.js"></script>
    <!-- Iconos Phosphor -->
    <script src="https://unpkg.com/@phosphor-icons/web"></script>
    <!-- Cargar Supabase Client -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <!-- Configuración de Tailwind -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                    colors: {
                        'solana-green': '#14F195',
                        'solana-purple': '#9945FF',
                        'x-blue': '#1DA1F2', // Color de Twitter/X
                        'page-bg': '#111827', // gray-900
                        'item-bg': '#1F2937', // gray-800
                        'item-hover': '#374151', // gray-700
                    },
                    keyframes: {
                        livePulse: {
                            '0%, 100%': { opacity: 1, boxShadow: '0 0 5px #F11414' },
                            '50%': { opacity: 0.6, boxShadow: '0 0 15px 5px #F11414' },
                        },
                        liveScreen: {
                            '0%, 100%': { backgroundColor: 'rgba(239, 68, 68, 0.2)' },
                            '50%': { backgroundColor: 'rgba(34, 197, 94, 0.2)' },
                        },
                        shimmer: {
                            '0%': { backgroundPosition: '-1000px 0' },
                            '100%': { backgroundPosition: '1000px 0' },
                        },
                    },
                    animation: {
                        livePulse: 'livePulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite',
                        liveScreen: 'liveScreen 1.5s ease-in-out infinite',
                        shimmer: 'shimmer 1.5s infinite linear',
                    }
                }
            }
        }
    </script>
    <style>
        /* Estilo para la barra de scroll */
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: #374151; }
        ::-webkit-scrollbar-thumb { background: #4a5568; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #718096; }

        .glassmorphism {
            background: rgba(31, 41, 55, 0.7); /* item-bg con transparencia */
            backdrop-filter: blur(10px);
            border: 1px solid rgba(55, 65, 81, 0.5); /* item-hover con transparencia */
        }

        .modal { transition: opacity 0.25s ease, visibility 0.25s ease; }
        .modal-content { transition: transform 0.25s ease; }

        /* Estilo para Popover de X */
        .x-popover-container { position: relative; display: inline-block; }
        .x-popover {
            position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%) translateY(-10px);
            z-index: 100; opacity: 0; visibility: hidden; transition: all 0.2s ease;
            width: 250px; pointer-events: none;
        }
        .x-popover-container:hover .x-popover { opacity: 1; visibility: visible; pointer-events: auto; transform: translateX(-50%) translateY(0); }

        /* Estilo para la barra de navegación inferior */
        .bottom-nav {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            z-index: 40;
            background: rgba(31, 41, 55, 0.9); /* item-bg con blur */
            backdrop-filter: blur(10px);
            border-top: 1px solid rgba(55, 65, 81, 0.5);
        }
        .nav-btn {
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            flex-grow: 1; padding: 8px 0; color: #9CA3AF; /* gray-400 */
            transition: color 0.2s ease;
            width: 0; /* Asegura que flex-grow distribuya el espacio */
        }
        .nav-btn.active { color: #14F195; /* solana-green */ }
        .nav-btn i { font-size: 24px; }
        .nav-btn span { font-size: 10px; margin-top: 2px; }

        /* Contenedor principal de la página con padding para la barra de navegación */
        .page-container {
            padding-bottom: 60px; /* Altura de la barra de navegación */
            flex-grow: 1;
        }
        .page {
            padding: 1rem; /* p-4 */
            display: none; /* Oculto por defecto */
        }
        .page.active {
            display: block; /* Visible */
        }

        /* Estilo para el Chat Global */
        #chat-messages {
            scroll-behavior: smooth;
        }
        /* Ocultar scrollbar de mensajes pero mantener scroll */
        #chat-messages::-webkit-scrollbar { display: none; }
        #chat-messages { -ms-overflow-style: none; scrollbar-width: none; }

        /* Estilos para la Oficina */
        #office-layout {
            position: relative;
            width: 100%;
            max-width: 600px; /* Ancho máximo de la oficina */
            height: 400px; /* Altura fija */
            background: url('https://placehold.co/600x400/1F2937/374151?text=Tu+Oficina') center center / cover no-repeat;
            border-radius: 0.5rem;
            border: 2px solid #374151;
            margin: auto;
        }
        .office-item {
            position: absolute;
            font-size: 3rem; /* Tamaño de los emojis */
            user-select: none;
        }

        /* Estilo para la Tarjeta PnL (Fondo oscuro) */
        #pnl-card-content {
            background-color: #1F2937; /* item-bg */
        }
        .pnl-value-positive { color: #22C55E; } /* green-500 */
        .pnl-value-negative { color: #EF4444; } /* red-500 */

    </style>
</head>
<body class="bg-page-bg text-white font-sans antialiased flex flex-col min-h-screen">

    <!-- Encabezado Fijo -->
    <header class="bg-item-bg shadow-lg sticky top-0 z-30">
        <nav class="container mx-auto px-4 py-3 flex justify-between items-center">
            <h1 class="text-xl lg:text-2xl font-bold text-solana-green">
                🚀 Solana Memecoin Sim
            </h1>
            <div class="flex items-center space-x-4">
                <button id="show-create-modal-btn" class="bg-solana-purple hover:bg-opacity-80 text-white font-bold p-2 rounded-full transition duration-200">
                    <i class="ph ph-plus text-xl"></i>
                </button>
                <div class="text-right">
                    <div class="text-sm text-gray-400">Balance</div>
                    <div id="ssol-balance" class="text-lg font-semibold text-solana-green">?.?? sSOL</div>
                </div>
            </div>
        </nav>
        <div id="player-id-banner" class="bg-solana-purple text-center py-1 px-4 text-xs font-mono">
            Conectando...
        </div>
    </header>

    <!-- Contenedor Principal de Páginas -->
    <main class="container mx-auto page-container">

        <!-- PÁGINA 1: MERCADO (Home) -->
        <section id="page-mercado" class="page active">
            <div class="mb-3">
                <input type="text" id="coin-filter-input" placeholder="Filtrar por nombre o símbolo..." class="w-full px-3 py-2 bg-item-bg border border-item-hover rounded-md focus:outline-none focus:ring-2 focus:ring-solana-purple">
            </div>
            <div id="memecoin-list" class="flex-grow overflow-y-auto space-y-2 pr-2">
                <p class="text-gray-400 text-center mt-10">Cargando monedas...</p>
            </div>
        </section>

        <!-- PÁGINA 2: PORTAFOLIO -->
        <section id="page-portafolio" class="page">
            <h2 class="text-xl font-semibold mb-3 border-b border-gray-700 pb-2">Mi Portafolio</h2>
            <div id="portfolio-list" class="space-y-2 pr-2 mb-6">
                <p class="text-gray-400">Cargando portafolio...</p>
            </div>
        </section>

        <!-- PÁGINA 3: FEED SOCIAL -->
        <section id="page-social" class="page">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-semibold">Feed Social</h2>
                <div>
                    <button id="show-my-profile-btn" class="bg-item-hover hover:bg-gray-600 text-white font-bold py-2 px-3 rounded-md transition duration-200 text-sm mr-2">
                        Mi Perfil
                    </button>
                    <button id="create-social-post-btn" class="bg-solana-purple hover:bg-opacity-80 text-white font-bold py-2 px-3 rounded-md transition duration-200 text-sm">
                        Crear Post
                    </button>
                </div>
            </div>
            <div id="social-feed-list" class="space-y-3">
                <p class="text-gray-400 text-center mt-10">Cargando feed...</p>
            </div>
        </section>

        <!-- PÁGINA 4: TIENDA -->
        <section id="page-tienda" class="page">
            <h2 class="text-xl font-semibold mb-3 border-b border-gray-700 pb-2">Tienda de Lujo</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
                <!-- Artículos de Lujo -->
                <div class="glassmorphism rounded-lg shadow-xl p-4 flex flex-col items-center text-center">
                    <span class="text-6xl mb-2">🏎️</span>
                    <h3 class="text-2xl font-bold mb-1">Lambo</h3>
                    <p class="text-lg font-semibold text-solana-green mb-3">5.00 sSOL</p>
                    <button data-item="lambo" data-cost="5" data-category="assets" class="buy-asset-btn w-full bg-yellow-500 hover:bg-yellow-600 text-gray-900 font-bold py-2 px-3 rounded-md transition duration-200 text-sm">
                        Comprar
                    </button>
                </div>
                <div class="glassmorphism rounded-lg shadow-xl p-4 flex flex-col items-center text-center">
                    <span class="text-6xl mb-2">🏰</span>
                    <h3 class="text-2xl font-bold mb-1">Mansión</h3>
                    <p class="text-lg font-semibold text-solana-green mb-3">20.00 sSOL</p>
                    <button data-item="mansion" data-cost="20" data-category="assets" class="buy-asset-btn w-full bg-teal-500 hover:bg-teal-600 text-white font-bold py-2 px-3 rounded-md transition duration-200 text-sm">
                        Comprar
                    </button>
                </div>
                 <div class="glassmorphism rounded-lg shadow-xl p-4 flex flex-col items-center text-center">
                    <span class="text-6xl mb-2">🛥️</span>
                    <h3 class="text-2xl font-bold mb-1">Yate</h3>
                    <p class="text-lg font-semibold text-solana-green mb-3">50.00 sSOL</p>
                    <button data-item="yate" data-cost="50" data-category="assets" class="buy-asset-btn w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-3 rounded-md transition duration-200 text-sm">
                        Comprar
                    </button>
                </div>
                <div class="glassmorphism rounded-lg shadow-xl p-4 flex flex-col items-center text-center">
                    <span class="text-6xl mb-2">✈️</span>
                    <h3 class="text-2xl font-bold mb-1">Jet Privado</h3>
                    <p class="text-lg font-semibold text-solana-green mb-3">100.00 sSOL</p>
                    <button data-item="jet" data-cost="100" data-category="assets" class="buy-asset-btn w-full bg-gray-300 hover:bg-gray-400 text-gray-900 font-bold py-2 px-3 rounded-md transition duration-200 text-sm">
                        Comprar
                    </button>
                </div>
            </div>

            <h2 class="text-xl font-semibold mb-3 border-b border-gray-700 pb-2">Tienda de Oficina</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <!-- Artículos de Oficina -->
                <div class="glassmorphism rounded-lg shadow-xl p-4 flex flex-col items-center text-center">
                    <span class="text-6xl mb-2">🖥️</span>
                    <h3 class="text-2xl font-bold mb-1">PC Gamer</h3>
                    <p class="text-lg font-semibold text-solana-green mb-3">3.00 sSOL</p>
                    <button data-item="pc" data-cost="3" data-category="office" data-emoji="🖥️" data-pos="bottom: 20%; left: 15%;" class="buy-asset-btn w-full bg-purple-500 hover:bg-purple-600 text-white font-bold py-2 px-3 rounded-md transition duration-200 text-sm">
                        Comprar
                    </button>
                </div>
                <div class="glassmorphism rounded-lg shadow-xl p-4 flex flex-col items-center text-center">
                    <span class="text-6xl mb-2">📺</span>
                    <h3 class="text-2xl font-bold mb-1">Monitor Curvo</h3>
                    <p class="text-lg font-semibold text-solana-green mb-3">1.50 sSOL</p>
                    <button data-item="monitor" data-cost="1.5" data-category="office" data-emoji="📺" data-pos="bottom: 22%; left: 40%;" class="buy-asset-btn w-full bg-cyan-500 hover:bg-cyan-600 text-white font-bold py-2 px-3 rounded-md transition duration-200 text-sm">
                        Comprar
                    </button>
                </div>
                <div class="glassmorphism rounded-lg shadow-xl p-4 flex flex-col items-center text-center">
                    <span class="text-6xl mb-2">🪑</span>
                    <h3 class="text-2xl font-bold mb-1">Silla Ergonómica</h3>
                    <p class="text-lg font-semibold text-solana-green mb-3">1.00 sSOL</p>
                    <button data-item="silla" data-cost="1" data-category="office" data-emoji="🪑" data-pos="bottom: 10%; left: 65%;" class="buy-asset-btn w-full bg-pink-500 hover:bg-pink-600 text-white font-bold py-2 px-3 rounded-md transition duration-200 text-sm">
                        Comprar
                    </button>
                </div>
            </div>
        </section>

        <!-- PÁGINA 5: JUGADORES -->
        <section id="page-jugadores" class="page">
            <h2 class="text-xl font-semibold mb-3 border-b border-gray-700 pb-2">Jugadores en la Sala</h2>
            <div id="players-list" class="overflow-y-auto space-y-2 pr-2">
                <p class="text-gray-400 text-center mt-10">Cargando jugadores...</p>
            </div>
        </section>

        <!-- PÁGINA 6: OFICINA -->
        <section id="page-oficina" class="page">
            <h2 class="text-xl font-semibold mb-3 border-b border-gray-700 pb-2">Mi Oficina</h2>
            <div id="office-layout" class="shadow-inner mb-4">
                <!-- Los artículos de la oficina se añadirán aquí con JS -->
                <p class="text-gray-400 text-center pt-20">Cargando oficina...</p>
            </div>
            <h3 class="text-lg font-semibold mb-2">Mis Artículos de Oficina</h3>
            <div id="my-office-assets-list" class="flex flex-wrap gap-2">
                <p class="text-gray-400 text-sm">Aún no tienes artículos de oficina.</p>
            </div>

            <h3 class="text-lg font-semibold mb-2 mt-6">Mis Activos de Lujo</h3>
            <div id="my-luxury-assets-list" class="flex flex-wrap gap-2">
                <p class="text-gray-400 text-sm">Aún no tienes activos de lujo.</p>
            </div>
        </section>

        <!-- PÁGINA 7: CHAT GLOBAL -->
        <section id="page-chat" class="page flex flex-col h-full" style="padding: 0.5rem; max-height: calc(100vh - 120px); /* Altura total menos header y nav */">
            <h2 class="text-xl font-semibold mb-3 border-b border-gray-700 pb-2 px-2">Chat Global</h2>
            <!-- Contenedor de mensajes -->
            <div id="chat-messages" class="flex-grow overflow-y-auto space-y-3 p-2 bg-item-bg/50 rounded-lg">
                <p class="text-gray-400 text-center text-sm">Cargando mensajes...</p>
            </div>
            <!-- Formulario de envío -->
            <form id="chat-form" class="flex gap-2 mt-3 p-2">
                <input type="text" id="chat-input" placeholder="Escribe un mensaje..." class="flex-grow px-3 py-2 bg-item-bg border border-item-hover rounded-md focus:outline-none focus:ring-2 focus:ring-solana-purple" required>
                <button type="submit" class="bg-solana-purple hover:bg-opacity-80 text-white font-bold p-2 rounded-md transition duration-200">
                    <i class="ph ph-paper-plane-tilt text-xl"></i>
                </button>
            </form>
        </section>


    </main>

    <!-- Barra de Navegación Inferior -->
    <nav class="bottom-nav flex shadow-lg">
        <button class="nav-btn active" data-page="page-mercado" title="Mercado">
            <i class="ph ph-chart-line-up"></i>
            <span class="hidden sm:inline">Mercado</span>
        </button>
        <button class="nav-btn" data-page="page-portafolio" title="Portafolio">
            <i class="ph ph-wallet"></i>
            <span class="hidden sm:inline">Portafolio</span>
        </button>
        <button class="nav-btn" data-page="page-social" title="Feed Social">
            <i class="ph ph-user-sound"></i>
            <span class="hidden sm:inline">Feed</span>
        </button>
        <button class="nav-btn" data-page="page-chat" title="Chat Global">
            <i class="ph ph-chats-circle"></i>
            <span class="hidden sm:inline">Chat</span>
        </button>
        <button class="nav-btn" data-page="page-tienda" title="Tienda">
            <i class="ph ph-storefront"></i>
            <span class="hidden sm:inline">Tienda</span>
        </button>
        <button class="nav-btn" data-page="page-oficina" title="Mi Oficina">
            <i class="ph ph-desktop-tower"></i>
            <span class="hidden sm:inline">Oficina</span>
        </button>
        <button class="nav-btn" data-page="page-jugadores" title="Jugadores">
            <i class="ph ph-users"></i>
            <span class="hidden sm:inline">Jugadores</span>
        </button>
    </nav>


    <!-- MODALES -->
        <!-- Modal para Mensajes Simples -->
        <div id="message-modal" class="modal fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 hidden opacity-0 visibility-hidden p-4">
            <div class="modal-content glassmorphism p-6 rounded-lg shadow-2xl max-w-sm w-full text-center transform scale-95">
                <p id="message-text" class="text-lg mb-4">Mensaje</p>
                <button id="close-message-btn" class="bg-solana-purple hover:bg-opacity-80 text-white font-bold py-2 px-4 rounded-md transition duration-200">
                    Cerrar
                </button>
            </div>
        </div>

        <!-- Modal para Crear Moneda -->
        <div id="create-coin-modal" class="modal fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 hidden opacity-0 visibility-hidden p-4">
            <div class="modal-content glassmorphism p-6 rounded-lg shadow-2xl max-w-md w-full text-center transform scale-95 overflow-y-auto max-h-full">
                <div class="flex justify-between items-center mb-3 border-b border-gray-700 pb-2">
                    <h2 class="text-xl font-semibold">Lanzar Nueva Memecoin</h2>
                    <button id="close-create-modal-btn" class="text-gray-400 hover:text-white text-2xl">&times;</button>
                </div>
                <form id="create-coin-form" class="space-y-3 text-left">
                    <div>
                        <label for="coin-name" class="block text-sm font-medium text-gray-300">Nombre (Ej: DogeWifHat)</label>
                        <input type="text" id="coin-name" required class="w-full mt-1 px-3 py-2 bg-gray-900 border border-gray-700 rounded-md focus:outline-none focus:ring-2 focus:ring-solana-purple" maxlength="20">
                    </div>
                    <div>
                        <label for="coin-symbol" class="block text-sm font-medium text-gray-300">Símbolo (Ej: WIF)</label>
                        <input type="text" id="coin-symbol" required class="w-full mt-1 px-3 py-2 bg-gray-900 border border-gray-700 rounded-md focus:outline-none focus:ring-2 focus:ring-solana-purple" maxlength="5" autocapitalize="characters">
                    </div>
                    <div>
                        <label for="coin-image-url" class="block text-sm font-medium text-gray-300">URL de Imagen</label>
                        <input type="url" id="coin-image-url" placeholder="https://..." class="w-full mt-1 px-3 py-2 bg-gray-900 border border-gray-700 rounded-md focus:outline-none focus:ring-2 focus:ring-solana-purple">
                    </div>
                    <div>
                        <label for="coin-x-url" class="block text-sm font-medium text-gray-300">URL de X (Twitter)</label>
                        <input type="url" id="coin-x-url" placeholder="https://x.com/yourcoin" class="w-full mt-1 px-3 py-2 bg-gray-900 border border-gray-700 rounded-md focus:outline-none focus:ring-2 focus:ring-x-blue">
                    </div>
                    <div class="grid grid-cols-2 gap-2">
                         <div>
                            <label for="coin-initial-ssol" class="block text-sm font-medium text-gray-300">sSOL Inicial (Liq.)</label>
                            <input type="number" id="coin-initial-ssol" step="0.01" min="0.01" required placeholder="0.1" class="w-full mt-1 px-3 py-2 bg-gray-900 border border-gray-700 rounded-md focus:outline-none focus:ring-2 focus:ring-solana-purple">
                        </div>
                         <div>
                            <label for="coin-initial-tokens" class="block text-sm font-medium text-gray-300">Tokens (Liq.)</label>
                            <input type="number" id="coin-initial-tokens" step="1000" min="1000" required placeholder="1000000" class="w-full mt-1 px-3 py-2 bg-gray-900 border border-gray-700 rounded-md focus:outline-none focus:ring-2 focus:ring-solana-purple">
                        </div>
                    </div>
                    <button type="submit" class="w-full bg-solana-purple hover:bg-opacity-80 text-white font-bold py-2 px-4 rounded-md transition duration-200">
                        Lanzar (Costo: 0.01 sSOL + Liq.)
                    </button>
                </form>
            </div>
        </div>

        <!-- Modal para Gráfica y Trading -->
        <div id="chart-modal" class="modal fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 hidden opacity-0 visibility-hidden p-4">
            <div class="modal-content glassmorphism p-6 rounded-lg shadow-2xl max-w-3xl w-full text-center transform scale-95 overflow-y-auto max-h-full">
                <div class="flex justify-between items-center mb-3 border-b border-gray-700 pb-2">
                     <div class="flex items-center gap-2">
                         <h2 id="modal-coin-name" class="text-2xl font-bold text-solana-green"></h2>
                         <span id="modal-live-badge" class="hidden animate-livePulse text-xs font-bold bg-red-600 text-white px-2 py-0.5 rounded-md">LIVE</span>
                     </div>
                    <button id="close-chart-modal-btn" class="text-gray-400 hover:text-white text-2xl">&times;</button>
                </div>

                <p id="modal-coin-price" class="text-xl font-mono text-center text-gray-300 mb-4">$0.00</p>
                <p id="modal-contract-id" class="text-sm font-mono text-center text-gray-500 mb-4">ID: ...</p>

                <div class="relative h-48 md:h-72 mb-4">
                    <canvas id="coin-chart-modal"></canvas>
                </div>

                <div class="flex gap-2 mb-4 w-full justify-center">
                    <button id="view-live-btn" class="hidden w-1/2 bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-md transition duration-200">
                        Ver Directo
                    </button>
                    <button id="show-pnl-modal-btn" class="w-1/2 bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md transition duration-200">
                        Ver PnL
                    </button>
                </div>


                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <form id="buy-form-modal" class="space-y-2 glassmorphism p-4 rounded-lg">
                        <label for="buy-amount-ssol-modal" class="block text-sm font-medium text-gray-300">Gastar (sSOL) - Fee 0.3%</label>
                        <input type="text" id="buy-amount-ssol-modal" inputmode="decimal" placeholder="0.1" class="w-full px-3 py-2 bg-gray-900 border border-gray-700 rounded-md focus:outline-none focus:ring-2 focus:ring-solana-green" required>
                        <button type="submit" class="w-full bg-solana-green hover:bg-opacity-80 text-gray-900 font-bold py-2 px-4 rounded-md transition duration-200">
                            Comprar
                        </button>
                    </form>

                    <form id="sell-form-modal" class="space-y-2 glassmorphism p-4 rounded-lg">
                        <label for="sell-amount-token-modal" class="block text-sm font-medium text-gray-300">Vender (Tokens) - Fee 0.3%</label>
                        <input type="text" id="sell-amount-token-modal" inputmode="decimal" placeholder="1000" class="w-full px-3 py-2 bg-gray-900 border border-gray-700 rounded-md focus:outline-none focus:ring-2 focus:ring-red-500" required>
                        <div class="grid grid-cols-3 gap-2 text-xs">
                            <button type="button" class="sell-percent-btn bg-gray-700 hover:bg-gray-600 py-1 rounded" data-percent="0.10">10%</button>
                            <button type="button" class="sell-percent-btn bg-gray-700 hover:bg-gray-600 py-1 rounded" data-percent="0.50">50%</button>
                            <button type="button" class="sell-percent-btn bg-gray-700 hover:bg-gray-600 py-1 rounded" data-percent="1.00">100%</button>
                        </div>
                        <button type="submit" class="w-full bg-red-600 hover:bg-opacity-80 text-white font-bold py-2 px-4 rounded-md transition duration-200">
                            Vender
                        </button>
                    </form>
                </div>
            </div>
        </div>

        <!-- Modal para Panel de Creador -->
        <div id="creator-dashboard-modal" class="modal fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 hidden opacity-0 visibility-hidden p-4">
            <div class="modal-content glassmorphism p-6 rounded-lg shadow-2xl max-w-4xl w-full text-center transform scale-95 overflow-y-auto max-h-full">
                <div class="flex justify-between items-center mb-3 border-b border-gray-700 pb-2">
                    <h2 class="text-xl font-semibold">Panel de Creador</h2>
                    <button id="close-creator-dashboard-btn" class="text-gray-400 hover:text-white text-2xl">&times;</button>
                </div>
                <div id="creator-coins-list" class="space-y-4 text-left">
                    <p class="text-gray-400 text-center">Cargando tus monedas...</p>
                </div>
            </div>
        </div>

        <!-- Modal para Enviar sSOL (P2P) -->
        <div id="send-ssol-modal" class="modal fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 hidden opacity-0 visibility-hidden p-4">
            <div class="modal-content glassmorphism p-6 rounded-lg shadow-2xl max-w-md w-full text-center transform scale-95">
                <div class="flex justify-between items-center mb-3 border-b border-gray-700 pb-2">
                    <h2 class="text-xl font-semibold">Enviar sSOL</h2>
                    <button id="close-send-ssol-btn" class="text-gray-400 hover:text-white text-2xl">&times;</button>
                </div>
                <form id="send-ssol-form" class="space-y-3 text-left">
                    <p class="text-sm">Enviar a: <strong id="send-ssol-target-name" class="font-mono text-solana-green">...</strong></p>
                    <div>
                        <label for="send-ssol-amount" class="block text-sm font-medium text-gray-300">Monto (sSOL)</label>
                        <input type="number" id="send-ssol-amount" step="0.01" min="0.01" required placeholder="0.1" class="w-full mt-1 px-3 py-2 bg-gray-900 border border-gray-700 rounded-md focus:outline-none focus:ring-2 focus:ring-solana-purple">
                    </div>
                    <button type="submit" class="w-full bg-solana-purple hover:bg-opacity-80 text-white font-bold py-2 px-4 rounded-md transition duration-200">
                        Confirmar Envío
                    </button>
                </form>
            </div>
        </div>

        <!-- Modal para "Live Stream" -->
        <div id="live-stream-modal" class="modal fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 hidden opacity-0 visibility-hidden p-4">
            <div class="modal-content glassmorphism p-6 rounded-lg shadow-2xl max-w-2xl w-full text-center transform scale-95">
                <div class="flex justify-between items-center mb-3 border-b border-gray-700 pb-2">
                    <h2 id="live-coin-name" class="text-xl font-semibold text-red-500 animate-pulse">LIVE: ...</h2>
                    <button id="close-live-stream-btn" class="text-gray-400 hover:text-white text-2xl">&times;</button>
                </div>
                <div class="w-full h-64 bg-black rounded-lg mb-4 animate-liveScreen border-2 border-gray-700 flex items-center justify-center">
                    <span class="text-3xl font-bold text-gray-500">SIMULACIÓN DE LIVE</span>
                </div>
                <div class="flex justify-between items-center mb-3">
                    <div class="text-lg">Espectadores: <span id="live-viewers" class="font-bold text-solana-green">...</span></div>
                    <div class="flex space-x-2">
                        <button id="boost-live-btn-small" data-boost-level="small" class="boost-live-btn bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-3 rounded-md text-sm transition">
                            Boost (0.1 sSOL)
                        </button>
                        <button id="boost-live-btn-medium" data-boost-level="medium" class="boost-live-btn bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-3 rounded-md text-sm transition">
                            Boost (1 sSOL)
                        </button>
                        <button id="boost-live-btn-large" data-boost-level="large" class="boost-live-btn bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-3 rounded-md text-sm transition">
                            Boost (10 sSOL)
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Modal para MI PERFIL -->
        <div id="my-profile-modal" class="modal fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 hidden opacity-0 visibility-hidden p-4">
            <div class="modal-content glassmorphism p-6 rounded-lg shadow-2xl max-w-md w-full text-center transform scale-95 overflow-y-auto max-h-full">
                <div class="flex justify-between items-center mb-3">
                    <h2 class="text-xl font-semibold">Mi Perfil</h2>
                    <button id="close-my-profile-btn" class="text-gray-400 hover:text-white text-2xl">&times;</button>
                </div>

                <form id="edit-social-profile-form" class="space-y-3 text-left mb-4">
                    <div class="flex items-center gap-4">
                        <img id="social-avatar-preview" src="https://placehold.co/60/374151/FFFFFF?text=P" alt="Avatar" class="w-16 h-16 rounded-full border-2 border-solana-green">
                        <div class="flex-grow">
                            <label for="social-username-input" class="block text-sm font-medium text-gray-300">Nombre de Usuario</label>
                            <input type="text" id="social-username-input" required class="w-full mt-1 px-3 py-2 bg-gray-900 border border-gray-700 rounded-md focus:outline-none focus:ring-2 focus:ring-solana-purple" maxlength="15">
                        </div>
                    </div>
                    <div>
                        <label for="social-avatar-input" class="block text-sm font-medium text-gray-300">URL de Avatar</label>
                        <input type="url" id="social-avatar-input" placeholder="https://..." class="w-full mt-1 px-3 py-2 bg-gray-900 border border-gray-700 rounded-md focus:outline-none focus:ring-2 focus:ring-solana-purple">
                    </div>
                    <button type="submit" class="w-full bg-solana-purple hover:bg-opacity-80 text-white font-bold py-2 px-4 rounded-md transition duration-200">
                        Guardar Perfil
                    </button>
                </form>

                <div class="text-left border-t border-gray-700 pt-4">
                    <h3 class="font-semibold text-md mb-2">Mis Posts</h3>
                    <div id="my-social-posts" class="space-y-3 h-48 overflow-y-auto pr-2">
                        <p class="text-gray-400 text-sm">Cargando posts...</p>
                    </div>
                </div>

                <button id="show-creator-dashboard-btn-from-profile" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md transition duration-200 mt-4">
                    💼 Panel de Creador
                </button>

                <button id="launch-socialfi-coin-btn" class="w-full bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-3 rounded-md transition duration-200 mt-2 hidden">
                    💎 Lanzar Moneda SocialFi (50+ Seguidores)
                </button>
            </div>
        </div>

        <!-- Modal para Crear Post Social -->
        <div id="create-social-post-modal" class="modal fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 hidden opacity-0 visibility-hidden p-4">
            <div class="modal-content glassmorphism p-6 rounded-lg shadow-2xl max-w-md w-full text-center transform scale-95">
                <div class="flex justify-between items-center mb-3 border-b border-gray-700 pb-2">
                    <h2 class="text-xl font-semibold">Crear Nuevo Post</h2>
                    <button id="close-create-social-post-btn" class="text-gray-400 hover:text-white text-2xl">&times;</button>
                </div>
                <form id="create-social-post-form" class="space-y-3 text-left">
                    <div>
                        <label for="social-post-text" class="block text-sm font-medium text-gray-300">Texto del Post</label>
                        <textarea id="social-post-text" rows="4" required class="w-full mt-1 px-3 py-2 bg-gray-900 border border-gray-700 rounded-md focus:outline-none focus:ring-2 focus:ring-solana-purple" maxlength="280" placeholder="¿Qué estás pensando? Shillea tu moneda aquí..."></textarea>
                    </div>
                    <button type="submit" class="w-full bg-solana-purple hover:bg-opacity-80 text-white font-bold py-2 px-4 rounded-md transition duration-200">
                        Publicar Post
                    </button>
                </form>
            </div>
        </div>

        <!-- Modal para Perfil de Otro Jugador -->
        <div id="player-profile-modal" class="modal fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 hidden opacity-0 visibility-hidden p-4">
            <div class="modal-content glassmorphism p-6 rounded-lg shadow-2xl max-w-md w-full text-center transform scale-95 overflow-y-auto max-h-full">
                <div class="flex justify-between items-center mb-3">
                    <h2 id="player-profile-username" class="text-xl font-semibold">Perfil del Jugador</h2>
                    <button id="close-player-profile-btn" class="text-gray-400 hover:text-white text-2xl">&times;</button>
                </div>

                <img id="player-profile-avatar" src="https://placehold.co/60/374151/FFFFFF?text=P" alt="Avatar" class="w-16 h-16 rounded-full mx-auto mb-2 border-2 border-solana-green">
                <p class="text-sm text-gray-400 mb-4">Seguidores: <span id="player-profile-followers">0</span></p>

                <button id="follow-player-btn" class="w-full bg-x-blue hover:bg-opacity-80 text-white font-bold py-2 px-4 rounded-md transition duration-200 mb-4">
                    Seguir
                </button>

                <div class="text-left border-t border-gray-700 pt-4 mb-4">
                    <h3 class="font-semibold text-md mb-2">Monedas Creadas</h3>
                    <div id="player-profile-coins" class="space-y-2 h-24 overflow-y-auto pr-2">
                        <p class="text-gray-400 text-sm">Cargando monedas...</p>
                    </div>
                </div>

                <div class="text-left border-t border-gray-700 pt-4">
                    <h3 class="font-semibold text-md mb-2">Posts Recientes</h3>
                    <div id="player-profile-posts" class="space-y-3 h-48 overflow-y-auto pr-2">
                        <p class="text-gray-400 text-sm">Cargando posts...</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Modal para PnL (Fondo Oscuro) -->
        <div id="pnl-card-modal" class="modal fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 hidden opacity-0 visibility-hidden p-4">
            <div class="modal-content p-0 rounded-lg shadow-2xl max-w-sm w-full text-center transform scale-95 overflow-hidden">
                <!-- Contenido de la tarjeta PnL -->
                <div id="pnl-card-content" class="p-6 rounded-lg text-white relative">
                    <button id="close-pnl-card-btn" class="absolute top-2 right-3 text-gray-300 hover:text-white text-2xl">&times;</button>

                    <div class="flex justify-between items-center mb-4">
                        <span class="text-xl font-bold">Mi PnL</span>
                        <span id="pnl-coin-symbol" class="text-lg font-bold bg-gray-700 px-3 py-1 rounded-full">...</span>
                    </div>

                    <div id="pnl-total-percent" class="text-4xl font-bold mb-1">+0.00%</div>
                    <div id="pnl-total-ssol" class="text-2xl font-semibold mb-6">+0.00 sSOL</div>

                    <div class="space-y-3 text-sm text-left">
                        <div class="flex justify-between border-b border-gray-700 pb-2">
                            <span class="text-gray-400">Total Invertido (sSOL)</span>
                            <span id="pnl-total-invested" class="font-mono">0.00</span>
                        </div>
                        <div class="flex justify-between border-b border-gray-700 pb-2">
                            <span class="text-gray-400">Total Realizado (sSOL)</span>
                            <span id="pnl-total-realized" class="font-mono">0.00</span>
                        </div>
                        <div class="flex justify-between border-b border-gray-700 pb-2">
                            <span class="text-gray-400">Valor Actual (sSOL)</span>
                            <span id="pnl-current-value" class="font-mono">0.00</span>
                        </div>
                        <div class="flex justify-between border-b border-gray-700 pb-2">
                            <span class="text-gray-400">Tokens Actuales</span>
                            <span id="pnl-current-tokens" class="font-mono">0.00</span>
                        </div>
                        <div class="flex justify-between">
                            <span class="text-gray-400">Precio Prom. Compra</span>
                            <span id="pnl-avg-buy-price" class="font-mono">$0.00</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>


    <!-- Script Principal (AHORA CON SUPABASE) -->
    <script type="module">
        // --- CONFIGURACIÓN DE SUPABASE ---
        const supabaseUrl = 'https://etwhxnbisztbohrhxexb.supabase.co'; // TU URL
        const supabaseAnonKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImV0d2h4bmJpc3p0Ym9oaHJ4ZXhiIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjE1MDU0NzMsImV4cCI6MjA3NzA4MTQ3M30.y1x3Ra3s7lTvPC6UrAc9DhXb8adFOA2NUQkTz-VZs3s'; // TU CLAVE ANÓNIMA
        // CORRECCIÓN: Usar supabaseClient como nombre de variable
        const supabaseClient = supabase.createClient(supabaseUrl, supabaseAnonKey);
        const appId = 'meme-59775'; // Mantener para lógica interna si es necesario, aunque no se usa en Supabase directamente

        // --- INICIO: ENVOLTORIO MAIN ASYNC ---
        async function main() {

            // --- REFERENCIAS AL DOM (MODALES) ---
            // ... (sin cambios)

            // --- FUNCIONES DE MODAL ---
             function showModal(modalEl) {
                modalEl.classList.remove('hidden');
                setTimeout(() => {
                    modalEl.classList.remove('opacity-0', 'visibility-hidden');
                    // Asegurarse de que el modal content exista
                    const content = modalEl.querySelector('.modal-content');
                    if (content) content.classList.remove('scale-95');
                }, 10);
            }

            function hideModal(modalEl) {
                modalEl.classList.add('opacity-0');
                // Asegurarse de que el modal content exista
                const content = modalEl.querySelector('.modal-content');
                 if (content) content.classList.add('scale-95');
                setTimeout(() => {
                    modalEl.classList.add('hidden', 'visibility-hidden');
                }, 250);
            }

            function showMessage(text) {
                messageTextEl.textContent = text;
                showModal(messageModalEl);
            }
            // --- VARIABLES GLOBALES DEL JUEGO ---
            let currentUserId = null; // Ahora será el UUID de Supabase Auth
            let currentUserData = null; // Para guardar datos del usuario logueado
            let realtimeChannels = []; // Para manejar suscripciones realtime
            // ... (resto de variables globales sin cambios)
            let selectedCoinId = null;
            let targetPlayerId = null;
            let memecoinChart = null;
            let chartGradient = null;
            let allCoinsCache = new Map();
            let myPortfolioCache = new Map();
            let myAssetsCache = { assets: new Map(), office: new Map() };
            let allPlayersCache = new Map();
            let mySocialPostsCache = new Map();
            let globalSocialFeedCache = new Map();
            let selectedProfilePlayerId = null;
            let myFollowsCache = new Set();
            let chatListener = null; // No se usará igual, será un canal

            // --- COMISIONES ---
            const LP_FEE = 0.0025;
            const CREATOR_FEE = 0.0005;
            const TOTAL_FEE = LP_FEE + CREATOR_FEE;
            const PROMO_POST_COST = 0.2;

            // --- REFERENCIAS AL DOM (PÁGINAS Y ELEMENTOS) ---
            // ... (sin cambios)
            const ssolBalanceEl = document.getElementById('ssol-balance');
            const playerIdBannerEl = document.getElementById('player-id-banner');
            const coinFilterInputEl = document.getElementById('coin-filter-input');
            const pages = document.querySelectorAll('.page');
            const navButtons = document.querySelectorAll('.nav-btn');
            const memecoinListEl = document.getElementById('memecoin-list');
            const portfolioListEl = document.getElementById('portfolio-list');
            const myLuxuryAssetsListEl = document.getElementById('my-luxury-assets-list');
            const myOfficeAssetsListEl = document.getElementById('my-office-assets-list');
            const officeLayoutEl = document.getElementById('office-layout');
            const socialFeedListEl = document.getElementById('social-feed-list');
            const playersListEl = document.getElementById('players-list');
            const chatMessagesEl = document.getElementById('chat-messages');
            const createCoinFormEl = document.getElementById('create-coin-form');
            const coinNameEl = document.getElementById('coin-name');
            const coinSymbolEl = document.getElementById('coin-symbol');
            const coinImageUrlEl = document.getElementById('coin-image-url');
            const coinXUrlEl = document.getElementById('coin-x-url');
            const coinInitialSsolEl = document.getElementById('coin-initial-ssol');
            const coinInitialTokensEl = document.getElementById('coin-initial-tokens');
            const buyFormEl = document.getElementById('buy-form-modal');
            const sellFormEl = document.getElementById('sell-form-modal');
            const buyAmountEl = document.getElementById('buy-amount-ssol-modal');
            const sellAmountEl = document.getElementById('sell-amount-token-modal');
            const chatFormEl = document.getElementById('chat-form');
            const chatInputEl = document.getElementById('chat-input');
             // Modales (ya definidos antes, asegurarse que estén todos)
            const messageModalEl = document.getElementById('message-modal');
            const messageTextEl = document.getElementById('message-text');
            const closeMessageBtn = document.getElementById('close-message-btn');
            const createCoinModalEl = document.getElementById('create-coin-modal');
            const showCreateModalBtn = document.getElementById('show-create-modal-btn');
            const closeCreateModalBtn = document.getElementById('close-create-modal-btn');
            const chartModalEl = document.getElementById('chart-modal');
            const closeChartModalBtn = document.getElementById('close-chart-modal-btn');
            const modalCoinNameEl = document.getElementById('modal-coin-name');
            const modalCoinPriceEl = document.getElementById('modal-coin-price');
            const modalLiveBadgeEl = document.getElementById('modal-live-badge');
            const viewLiveBtnEl = document.getElementById('view-live-btn');
            const modalContractIdEl = document.getElementById('modal-contract-id');
            const showPnlModalBtn = document.getElementById('show-pnl-modal-btn');
            const pnlCardModalEl = document.getElementById('pnl-card-modal');
            const closePnlCardBtn = document.getElementById('close-pnl-card-btn');
            const pnlCardContentEl = document.getElementById('pnl-card-content');
            const pnlCoinSymbolEl = document.getElementById('pnl-coin-symbol');
            const pnlTotalPercentEl = document.getElementById('pnl-total-percent');
            const pnlTotalSsolEl = document.getElementById('pnl-total-ssol');
            const pnlTotalInvestedEl = document.getElementById('pnl-total-invested');
            const pnlTotalRealizedEl = document.getElementById('pnl-total-realized');
            const pnlCurrentValueEl = document.getElementById('pnl-current-value');
            const pnlCurrentTokensEl = document.getElementById('pnl-current-tokens');
            const pnlAvgBuyPriceEl = document.getElementById('pnl-avg-buy-price');
            const creatorDashboardModalEl = document.getElementById('creator-dashboard-modal');
            const closeCreatorDashboardBtn = document.getElementById('close-creator-dashboard-btn');
            const creatorCoinsListEl = document.getElementById('creator-coins-list');
            const sendSsolModalEl = document.getElementById('send-ssol-modal');
            const closeSendSsolBtn = document.getElementById('close-send-ssol-btn');
            const sendSsolTargetNameEl = document.getElementById('send-ssol-target-name');
            const sendSsolFormEl = document.getElementById('send-ssol-form');
            const sendSsolAmountEl = document.getElementById('send-ssol-amount');
            const liveStreamModalEl = document.getElementById('live-stream-modal');
            const closeLiveStreamBtn = document.getElementById('close-live-stream-btn');
            const liveCoinNameEl = document.getElementById('live-coin-name');
            const liveViewersEl = document.getElementById('live-viewers');
            const myProfileModalEl = document.getElementById('my-profile-modal');
            const showMyProfileBtn = document.getElementById('show-my-profile-btn');
            const closeMyProfileBtn = document.getElementById('close-my-profile-btn');
            const editSocialProfileFormEl = document.getElementById('edit-social-profile-form');
            const socialUsernameInputEl = document.getElementById('social-username-input');
            const socialAvatarInputEl = document.getElementById('social-avatar-input');
            const socialAvatarPreviewEl = document.getElementById('social-avatar-preview');
            const mySocialPostsEl = document.getElementById('my-social-posts');
            const showCreatorDashboardBtnFromProfile = document.getElementById('show-creator-dashboard-btn-from-profile');
            const launchSocialFiCoinBtn = document.getElementById('launch-socialfi-coin-btn');
            const createSocialPostModalEl = document.getElementById('create-social-post-modal');
            const closeCreateSocialPostBtn = document.getElementById('close-create-social-post-btn');
            const createSocialPostBtn = document.getElementById('create-social-post-btn');
            const createSocialPostFormEl = document.getElementById('create-social-post-form');
            const socialPostTextEl = document.getElementById('social-post-text');
            const playerProfileModalEl = document.getElementById('player-profile-modal');
            const closePlayerProfileBtn = document.getElementById('close-player-profile-btn');
            const playerProfileUsernameEl = document.getElementById('player-profile-username');
            const playerProfileAvatarEl = document.getElementById('player-profile-avatar');
            const playerProfileFollowersEl = document.getElementById('player-profile-followers');
            const playerProfilePostsEl = document.getElementById('player-profile-posts');
            const playerProfileCoinsEl = document.getElementById('player-profile-coins');
            const followPlayerBtn = document.getElementById('follow-player-btn');

            // --- LÓGICA DE NAVEGACIÓN (SPA) ---
            function showPage(pageId) {
                pages.forEach(page => {
                    page.classList.toggle('active', page.id === pageId);
                });
                navButtons.forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.page === pageId);
                });

                // Si cambiamos al chat, asegurar que el canal esté suscrito
                if (pageId === 'page-chat') {
                    subscribeToChatMessages(); // Asegura suscripción
                }
            }
            // ... (listeners de botones de navegación sin cambios)
             navButtons.forEach(btn => {
                btn.addEventListener('click', () => showPage(btn.dataset.page));
            });

             // --- Add event listeners for modal close buttons ---
            closeMessageBtn.addEventListener('click', () => hideModal(messageModalEl));
            closeCreateModalBtn.addEventListener('click', () => hideModal(createCoinModalEl));
            closeChartModalBtn.addEventListener('click', () => {
                hideModal(chartModalEl);
                selectedCoinId = null;
                const coinElements = memecoinListEl.querySelectorAll('button');
                coinElements.forEach(child => {
                    child.classList.remove('bg-solana-purple/50');
                    child.classList.add('bg-item-bg');
                });
            });
            closeCreatorDashboardBtn.addEventListener('click', () => hideModal(creatorDashboardModalEl));
            closeSendSsolBtn.addEventListener('click', () => hideModal(sendSsolModalEl));
            closeLiveStreamBtn.addEventListener('click', () => hideModal(liveStreamModalEl));
            closeMyProfileBtn.addEventListener('click', () => hideModal(myProfileModalEl));
            closeCreateSocialPostBtn.addEventListener('click', () => hideModal(createSocialPostModalEl));
            closePlayerProfileBtn.addEventListener('click', () => hideModal(playerProfileModalEl));
            closePnlCardBtn.addEventListener('click', () => hideModal(pnlCardModalEl));

             // --- Add event listeners for modal open buttons ---
            showCreateModalBtn.addEventListener('click', () => showModal(createCoinModalEl));
            showPnlModalBtn.addEventListener('click', () => showPnlModal());
            viewLiveBtnEl.addEventListener('click', () => showLiveStream());
            showMyProfileBtn.addEventListener('click', () => {
                const player = allPlayersCache.get(currentUserId);
                if (player) {
                    socialUsernameInputEl.value = player.username || '';
                    socialAvatarInputEl.value = player.avatar_url || '';
                    socialAvatarPreviewEl.src = player.avatar_url || 'https://placehold.co/60/374151/FFFFFF?text=P';
                }
                loadMySocialPosts(currentUserId); // Cargar posts aquí
                showModal(myProfileModalEl);
            });
            createSocialPostBtn.addEventListener('click', () => showModal(createSocialPostModalEl));
             showCreatorDashboardBtnFromProfile.addEventListener('click', () => {
                hideModal(myProfileModalEl);
                showCreatorDashboard();
            });
             document.querySelectorAll('.boost-live-btn').forEach(btn => btn.addEventListener('click', (e) => boostLiveStream(e.target.dataset.boostLevel)));


            // --- FUNCIONES DE UTILIDAD ---
            // ... (parseFloatStrict, formatPrice, formatCurrency, formatNumber, timeAgo sin cambios)
             function parseFloatStrict(value) {
                if (typeof value !== 'string' || value.trim() === '') return NaN;
                const normalizedValue = value.replace(',', '.');
                if (!/^\d*(\.\d+)?$/.test(normalizedValue)) return NaN;
                const number = parseFloat(normalizedValue);
                return isNaN(number) || number < 0 ? NaN : number;
            }
            function formatPrice(value) {
                if (isNaN(value)) value = 0;
                return new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD', minimumFractionDigits: 2, maximumFractionDigits: 10 }).format(value);
            }
            function formatCurrency(value) {
                if (isNaN(value)) value = 0;
                 return new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD', minimumFractionDigits: 2, maximumFractionDigits: 2 }).format(value);
            }
            function formatNumber(value, decimals = 2) {
                if (isNaN(value)) value = 0;
                return new Intl.NumberFormat('en-US', { minimumFractionDigits: decimals, maximumFractionDigits: decimals }).format(value);
            }
            function timeAgo(dateString) { // Ahora recibe string ISO
                if (!dateString) return 'justo ahora';
                const date = new Date(dateString);
                const seconds = Math.floor((new Date() - date) / 1000);
                let interval = seconds / 31536000;
                if (interval > 1) return Math.floor(interval) + "a";
                interval = seconds / 2592000;
                if (interval > 1) return Math.floor(interval) + "m";
                interval = seconds / 86400;
                if (interval > 1) return Math.floor(interval) + "d";
                interval = seconds / 3600;
                if (interval > 1) return Math.floor(interval) + "h";
                interval = seconds / 60;
                if (interval > 1) return Math.floor(interval) + "min";
                return "ahora";
            }


            // --- LÓGICA DE AUTENTICACIÓN (SUPABASE AUTH) ---
            async function initAuth() {
                // Intentar obtener sesión existente
                const { data: { session }, error: sessionError } = await supabaseClient.auth.getSession();

                if (session && session.user) {
                    currentUserId = session.user.id;
                    console.log("Sesión existente. User ID:", currentUserId);
                    await joinGame(currentUserId);
                } else {
                    console.log("No hay sesión, intentando login anónimo...");
                    // Intentar login anónimo simulado
                    let fakeEmail = localStorage.getItem('supabase-anon-email');
                    let fakePassword = localStorage.getItem('supabase-anon-password');

                    if (!fakeEmail) {
                        fakeEmail = `user_${Date.now()}@anon.sim`;
                        fakePassword = Math.random().toString(36).substring(2);
                        // Intentar registrar
                        const { data: signUpData, error: signUpError } = await supabaseClient.auth.signUp({
                            email: fakeEmail,
                            password: fakePassword,
                        });

                        if (signUpError) {
                            console.error("Error al registrar usuario anónimo simulado:", signUpError);
                            showMessage("Error al conectar (registro). Recarga.");
                            return;
                        }
                        console.log("Usuario anónimo simulado registrado:", signUpData.user?.id);
                        if (!signUpData.user) {
                             showMessage("Error crítico: No se pudo obtener el ID de usuario registrado.");
                             return;
                        }
                        localStorage.setItem('supabase-anon-email', fakeEmail);
                        localStorage.setItem('supabase-anon-password', fakePassword);
                        currentUserId = signUpData.user.id;
                        await joinGame(currentUserId);

                    } else {
                        // Intentar iniciar sesión con credenciales guardadas
                        const { data: signInData, error: signInError } = await supabaseClient.auth.signInWithPassword({
                            email: fakeEmail,
                            password: fakePassword,
                        });

                        if (signInError) {
                            console.error("Error al iniciar sesión anónima simulada:", signInError);
                            localStorage.removeItem('supabase-anon-email');
                            localStorage.removeItem('supabase-anon-password');
                            // Reintentar registro después de limpiar credenciales inválidas
                            await initAuth(); // Llamada recursiva simple para reintentar
                            // showMessage("Error al reconectar. Recarga la página.");
                            return;
                        }
                        console.log("Usuario anónimo simulado re-autenticado:", signInData.user?.id);
                         if (!signInData.user) {
                             showMessage("Error crítico: No se pudo obtener el ID de usuario al iniciar sesión.");
                             return;
                        }
                        currentUserId = signInData.user.id;
                        await joinGame(currentUserId);
                    }
                }
                playerIdBannerEl.textContent = `Tu ID: ...${currentUserId.slice(-6)}`;
            }

            async function joinGame(userId) {
                 if (!userId) {
                    console.error("joinGame llamado sin userId");
                    showMessage("Error interno: Falta ID de usuario.");
                    return;
                }
                // Verificar si el jugador existe
                const { data: player, error: getError } = await supabaseClient
                    .from('players')
                    .select('*')
                    .eq('user_id', userId)
                    .single();

                if (getError && getError.code !== 'PGRST116') { // PGRST116: No rows found (esperado si es nuevo)
                    console.error("Error al buscar jugador:", getError);
                    showMessage(`Error al buscar tu perfil: ${getError.message}`);
                    return;
                }

                if (!player) {
                    // Crear jugador si no existe
                    const defaultUsername = `Jugador${userId.slice(-4)}`;
                    const defaultAvatar = `https://placehold.co/60/374151/FFFFFF?text=${userId.slice(-1)}`;
                    const { error: insertError } = await supabaseClient
                        .from('players')
                        .insert({
                            user_id: userId,
                            username: defaultUsername,
                            avatar_url: defaultAvatar,
                            s_sol_balance: 2.0, // Saldo inicial
                        });

                    if (insertError) {
                        console.error("Error al crear jugador:", insertError);
                        showMessage(`Error al crear tu perfil: ${insertError.message}`);
                        return;
                    }
                    console.log("Jugador creado en Supabase con ID:", userId);
                     // Obtener los datos recién creados para la caché local
                    const { data: newPlayer, error: getNewError } = await supabaseClient
                        .from('players')
                        .select('*')
                        .eq('user_id', userId)
                        .single();
                    if(getNewError || !newPlayer) {
                        console.error("Error al obtener el jugador recién creado:", getNewError);
                        showMessage("Error crítico al obtener datos iniciales.");
                        return;
                    }
                    currentUserData = newPlayer;
                } else {
                    currentUserData = player; // Guardar datos del usuario actual
                }

                 // Actualizar UI inicial con datos del usuario
                ssolBalanceEl.textContent = `${formatNumber(currentUserData.s_sol_balance)} sSOL`;
                myAssetsCache = {
                    assets: new Map(Object.entries(currentUserData.assets || {})),
                    office: new Map(Object.entries(currentUserData.office_items || {}))
                };
                updateMyAssetsUI();


                // Iniciar listeners/suscripciones Realtime
                unsubscribeAllRealtime(); // Limpiar suscripciones anteriores si las hubiera
                subscribeToPlayerBalance(userId);
                subscribeToPlayers();
                subscribeToMemecoins();
                subscribeToMyPortfolio(userId);
                loadMyPortfolio(userId);
                subscribeToMySocialProfile(userId);
                subscribeToGlobalSocialFeed();
                subscribeToMyFollows(userId);
                subscribeToChatMessages(); // Iniciar suscripción al chat siempre
            }

            // --- LISTENERS/SUSCRIPCIONES REALTIME (SUPABASE) ---

            // Función genérica para manejar suscripciones y limpieza
            function setupRealtimeSubscription(channelName, table, filter, callback) {
                // Quitar canal existente con el mismo nombre si existe
                const existingChannel = supabaseClient.channel(channelName);
                if (existingChannel) {
                    supabaseClient.removeChannel(existingChannel).then(() => console.log(`Removed existing channel ${channelName}`));
                }

                const channel = supabaseClient.channel(channelName);
                channel
                    .on('postgres_changes', { event: '*', schema: 'public', table: table, filter: filter }, payload => {
                        // console.log(`Realtime update on ${table}:`, payload.eventType);
                        callback(payload);
                    })
                    .subscribe((status, err) => {
                        if (status === 'SUBSCRIBED') {
                            console.log(`Subscribed to ${channelName} (${table})`);
                        }
                         else if (status === 'CHANNEL_ERROR' || status === 'TIMED_OUT' || status === 'CLOSED') {
                            console.error(`Subscription error/closed on ${channelName} (${table}):`, status, err);
                            // Intentar re-suscribir después de un delay podría ser una opción
                        }
                    });
                realtimeChannels.push(channel); // Guardar para limpiar después
                return channel; // Devolver el canal por si se necesita referencia directa
            }

            function unsubscribeAllRealtime() {
                realtimeChannels.forEach(channel => supabaseClient.removeChannel(channel));
                realtimeChannels = [];
                console.log("Unsubscribed from all realtime channels.");
            }
            // Asegurarse de limpiar al salir (ej. al cerrar la ventana)
            window.addEventListener('beforeunload', unsubscribeAllRealtime);

            function subscribeToPlayerBalance(userId) {
                setupRealtimeSubscription(`player-balance-${userId}`, 'players', `user_id=eq.${userId}`, (payload) => {
                    if (payload.new && payload.eventType !== 'DELETE') {
                        const data = payload.new;
                        console.log("Realtime update for my balance:", data.s_sol_balance);
                        currentUserData = data; // Actualizar caché local del usuario
                        ssolBalanceEl.textContent = `${formatNumber(data.s_sol_balance)} sSOL`;
                        myAssetsCache = {
                            assets: new Map(Object.entries(data.assets || {})),
                            office: new Map(Object.entries(data.office_items || {}))
                        };
                        updateMyAssetsUI();
                    }
                });
            }

            function subscribeToPlayers() {
                // Carga inicial
                async function loadInitialPlayers() {
                    const { data, error } = await supabaseClient.from('players').select('*');
                    if (error) {
                        console.error("Error loading initial players:", error);
                        playersListEl.innerHTML = '<p class="text-red-500">Error al cargar jugadores.</p>';
                        return;
                    }
                    allPlayersCache.clear();
                    data.forEach(p => allPlayersCache.set(p.user_id, p));
                    updatePlayersListUI();
                }
                loadInitialPlayers();

                // Suscripción a cambios
                setupRealtimeSubscription('all-players', 'players', null, (payload) => {
                     const eventType = payload.eventType;
                     const record = eventType === 'DELETE' ? payload.old : payload.new;
                     const userId = record?.user_id;

                     if (!userId) return;

                     if (eventType === 'INSERT' || eventType === 'UPDATE') {
                         allPlayersCache.set(userId, record);
                     } else if (eventType === 'DELETE') {
                         allPlayersCache.delete(userId);
                     }
                     updatePlayersListUI(); // Actualizar UI completa en cualquier cambio
                });
            }
             // Función separada para renderizar la lista de jugadores desde la caché
            function updatePlayersListUI() {
                playersListEl.innerHTML = '';
                if (allPlayersCache.size === 0) {
                    playersListEl.innerHTML = '<p class="text-gray-400">Estás solo aquí...</p>';
                    return;
                }

                // Convertir Map a Array y ordenar si es necesario (ej. por balance)
                const sortedPlayers = Array.from(allPlayersCache.values()).sort((a, b) => b.s_sol_balance - a.s_sol_balance);

                sortedPlayers.forEach(player => {
                    const isMe = player.user_id === currentUserId;
                    const playerEl = document.createElement('div');
                    playerEl.className = `flex w-full justify-between items-center p-3 rounded-lg ${isMe ? 'bg-solana-purple/30' : 'bg-item-bg'}`;
                    playerEl.innerHTML = `
                        <div class="flex items-center gap-3">
                            <img src="${player.avatar_url || 'https://placehold.co/40/374151/FFFFFF?text=P'}" alt="avatar" class="w-10 h-10 rounded-full">
                            <div>
                                <span class="font-semibold truncate ${isMe ? 'text-solana-green' : ''}">
                                    ${player.username || '...'} ${isMe ? '(Tú)' : ''}
                                </span>
                                <span class="text-sm text-gray-400 block">${formatNumber(player.social_followers || 0, 0)} seguidores</span>
                            </div>
                        </div>
                        <span class="text-sm font-semibold">${formatNumber(player.s_sol_balance)} sSOL</span>
                    `;

                    if (!isMe) {
                        const controlsEl = document.createElement('div');
                        controlsEl.className = "flex gap-2";

                        const sendBtn = document.createElement('button');
                        sendBtn.innerHTML = `<i class="ph ph-paper-plane-tilt text-xl"></i>`;
                        sendBtn.className = "p-2 bg-item-hover rounded-md hover:bg-gray-600 transition";
                        sendBtn.title = "Enviar sSOL";
                        sendBtn.addEventListener('click', () => {
                            targetPlayerId = player.user_id;
                            sendSsolTargetNameEl.textContent = `${player.username || '...' + player.user_id.slice(-6)}`;
                            showModal(sendSsolModalEl);
                        });

                        const profileBtn = document.createElement('button');
                        profileBtn.innerHTML = `<i class="ph ph-user text-xl"></i>`;
                        profileBtn.className = "p-2 bg-item-hover rounded-md hover:bg-gray-600 transition";
                        profileBtn.title = "Ver Perfil";
                        profileBtn.addEventListener('click', () => {
                            showPlayerProfile(player.user_id);
                        });

                        controlsEl.appendChild(profileBtn);
                        controlsEl.appendChild(sendBtn);
                        playerEl.appendChild(controlsEl);
                    }
                    playersListEl.appendChild(playerEl);
                });
            }


            function subscribeToMyFollows(userId) {
                // Carga inicial
                async function loadInitialFollows() {
                    const { data, error } = await supabaseClient
                        .from('players')
                        .select('following')
                        .eq('user_id', userId)
                        .single();
                    if (!error && data) {
                        myFollowsCache = new Set(data.following || []);
                    } else {
                        console.error("Error loading initial follows:", error);
                    }
                }
                loadInitialFollows();

                // Suscripción (solo necesitamos saber si *nuestro* array 'following' cambia)
                setupRealtimeSubscription(`my-follows-${userId}`, 'players', `user_id=eq.${userId}`, (payload) => {
                    if (payload.new && payload.eventType !== 'DELETE') {
                         myFollowsCache = new Set(payload.new.following || []);
                         // Actualizar botón de seguir si el perfil de otro está abierto
                         if (!playerProfileModalEl.classList.contains('hidden') && selectedProfilePlayerId) { // Check if modal is visible
                            updateFollowButton();
                         }
                    }
                });
            }


            function subscribeToMySocialProfile(userId) {
                 setupRealtimeSubscription(`my-profile-${userId}`, 'players', `user_id=eq.${userId}`, (payload) => {
                    if (payload.new && payload.eventType !== 'DELETE') {
                        const player = payload.new;
                        currentUserData = player; // Actualizar caché local
                        socialUsernameInputEl.value = player.username || '';
                        socialAvatarInputEl.value = player.avatar_url || '';
                        socialAvatarPreviewEl.src = player.avatar_url || 'https://placehold.co/60/374151/FFFFFF?text=P';
                        launchSocialFiCoinBtn.classList.toggle('hidden', (player.social_followers || 0) < 50);
                    }
                 });
            }

            // No es necesario suscribirse a mis posts, se cargan al abrir el modal
            async function loadMySocialPosts(userId) {
                mySocialPostsEl.innerHTML = '<p class="text-gray-400 text-sm">Cargando mis posts...</p>';
                const { data: posts, error } = await supabaseClient
                    .from('social_posts')
                    .select('*')
                    .eq('user_id', userId)
                    .order('created_at', { ascending: false });

                mySocialPostsCache.clear();
                if (error) {
                    console.error("Error loading my posts:", error);
                    mySocialPostsEl.innerHTML = '<p class="text-red-500 text-sm">Error al cargar posts.</p>';
                    return;
                }

                if (!posts || posts.length === 0) {
                    mySocialPostsEl.innerHTML = '<p class="text-gray-400 text-sm">Aún no has hecho posts.</p>';
                    return;
                }

                mySocialPostsEl.innerHTML = '';
                posts.forEach(post => {
                    mySocialPostsCache.set(post.id, post);
                    const postEl = document.createElement('div');
                    postEl.className = 'bg-item-hover p-3 rounded-lg text-sm';
                    postEl.innerHTML = `
                        <p>${post.text}</p>
                        <p class="text-xs text-gray-500 mt-2">${new Date(post.created_at).toLocaleString()}</p>
                    `;
                    mySocialPostsEl.appendChild(postEl);
                });
            }

            function subscribeToGlobalSocialFeed() {
                 // Carga inicial
                async function loadInitialFeed() {
                    const { data, error } = await supabaseClient
                        .from('social_posts')
                        .select('*')
                        .order('created_at', { ascending: false })
                        .limit(50); // Cargar 50 iniciales

                    if (error) {
                        console.error("Error loading initial feed:", error);
                        socialFeedListEl.innerHTML = '<p class="text-red-500 text-center">Error al cargar el feed.</p>';
                        return;
                    }
                    handleFeedUpdate(data); // Renderizar carga inicial
                }
                loadInitialFeed();

                // Suscripción a nuevos posts
                // Escuchar INSERT y UPDATE (para boosted)
                 setupRealtimeSubscription('social-feed-changes', 'social_posts', null, (payload) => {
                     // Recargar todo el feed en cualquier cambio para mantener el orden boost/fecha
                     // Podría optimizarse para solo insertar/actualizar, pero es más complejo
                     loadInitialFeed();
                });
            }
             // Función separada para renderizar el feed desde datos (usada por carga inicial y realtime)
            function handleFeedUpdate(postsData) {
                socialFeedListEl.innerHTML = '';
                globalSocialFeedCache.clear();

                if (!postsData || postsData.length === 0) {
                    socialFeedListEl.innerHTML = '<p class="text-gray-400 text-center">¡El feed está vacío! Sé el primero en postear.</p>';
                    return;
                }

                 // Ordenar en JS: boosted=true primero, luego por fecha (ya viene ordenado por fecha, solo falta boost)
                postsData.sort((a, b) => {
                    if (a.boosted && !b.boosted) return -1;
                    if (!a.boosted && b.boosted) return 1;
                    // Mantenemos el orden por fecha si el estado boosted es el mismo
                    return 0; // O usar new Date(b.created_at) - new Date(a.created_at) si no viniera ordenado
                });

                postsData.forEach(post => {
                    globalSocialFeedCache.set(post.id, post);

                    // Usar datos denormalizados si existen, o buscar en caché de jugadores
                    const username = post.username || allPlayersCache.get(post.user_id)?.username || 'Desconocido';
                    const avatarUrl = post.avatar_url || allPlayersCache.get(post.user_id)?.avatar_url || 'https://placehold.co/40/374151/FFFFFF?text=P';

                    const postEl = document.createElement('div');
                    postEl.className = `glassmorphism p-4 rounded-lg ${post.boosted ? 'border-2 border-solana-purple' : 'border border-transparent'}`;

                    let promoBtn = '';
                    if (post.user_id === currentUserId && !post.boosted) {
                        promoBtn = `<button data-post-id="${post.id}" class="promote-post-btn text-sm text-solana-purple hover:text-solana-green transition">Promocionar (0.2 sSOL)</button>`;
                    } else if (post.boosted) {
                        promoBtn = `<span class="text-sm text-solana-purple font-semibold">¡Promocionado!</span>`;
                    }

                    postEl.innerHTML = `
                        <div class="flex justify-between items-start">
                            <button data-player-id="${post.user_id}" class="player-profile-link flex items-center gap-3 group">
                                <img src="${avatarUrl}" alt="avatar" class="w-10 h-10 rounded-full group-hover:opacity-80 transition">
                                <div>
                                    <p class="font-semibold text-white group-hover:text-solana-green transition">${username}</p>
                                    <p class="text-xs text-gray-400">${timeAgo(post.created_at)}</p>
                                </div>
                            </button>
                            ${promoBtn}
                        </div>
                        <p class="mt-3 text-gray-200">${post.text}</p>
                    `;
                    socialFeedListEl.appendChild(postEl);
                });

                 // Añadir listeners a los nuevos botones del feed
                socialFeedListEl.querySelectorAll('.promote-post-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => promotePost(e.target.dataset.postId, e.target));
                });
                socialFeedListEl.querySelectorAll('.player-profile-link').forEach(btn => {
                    btn.addEventListener('click', (e) => showPlayerProfile(e.currentTarget.dataset.playerId));
                });
            }


            // Carga inicial y suscripción para el portfolio
             async function loadMyPortfolio(userId) {
                const { data, error } = await supabaseClient
                    .from('wallets')
                    .select('*, coins(*)') // Obtener datos de la moneda relacionada
                    .eq('user_id', userId)
                    .gt('amount', 0.00000001); // Filtrar wallets con balance > 0

                if (error) {
                    console.error("Error loading initial portfolio:", error);
                    portfolioListEl.innerHTML = '<p class="text-red-500">Error al cargar portafolio.</p>';
                    return;
                }
                handlePortfolioUpdate(data);
            }

            function subscribeToMyPortfolio(userId) {
                // Suscribirse a cambios en la tabla 'wallets' para mi user_id
                setupRealtimeSubscription(`my-portfolio-${userId}`, 'wallets', `user_id=eq.${userId}`, (payload) => {
                    // Recargar todo el portfolio en cualquier cambio para recalcular valores
                     loadMyPortfolio(userId);
                });
                 // También necesitamos suscribirnos a cambios en 'coins' para actualizar precios en el portfolio
                 setupRealtimeSubscription('portfolio-coin-prices', 'coins', null, (payload) => {
                     // Si una moneda cambia, actualizamos su caché y recargamos/renderizamos el portfolio
                     const coinId = payload.new?.id || payload.old?.id;
                     if (!coinId) return;

                     if (payload.new && payload.eventType !== 'DELETE') {
                         allCoinsCache.set(coinId, payload.new);
                     } else if (payload.eventType === 'DELETE' && payload.old) {
                         allCoinsCache.delete(coinId);
                     }
                     // Re-renderizar portfolio si está visible
                      if (document.getElementById('page-portafolio').classList.contains('active')) {
                        handlePortfolioUpdate(Array.from(myPortfolioCache.values()));
                      }
                 });
            }
             // Función separada para renderizar el portfolio desde los datos (wallets + coin data)
            function handlePortfolioUpdate(walletData) {
                portfolioListEl.innerHTML = '';
                myPortfolioCache.clear(); // Limpiar caché antes de rellenar

                if (!walletData || walletData.length === 0) {
                    portfolioListEl.innerHTML = '<p class="text-gray-400">Aún no tienes monedas.</p>';
                    return;
                }

                let portfolioItems = walletData.map(wallet => {
                    // La moneda puede venir anidada ('coins') o necesitar búsqueda en caché ('coin_id')
                    const coinData = wallet.coins || allCoinsCache.get(wallet.coin_id);
                    const currentValue = coinData ? wallet.amount * coinData.current_price : 0;
                     // Guardar en caché del portfolio
                     const portfolioItem = {
                        ...wallet, // Incluye user_id, coin_id, amount, trade_history
                        coinData: coinData,
                        currentValue: currentValue
                    };
                    myPortfolioCache.set(wallet.coin_id, portfolioItem);
                    return portfolioItem;
                }).filter(item => item.coinData); // Filtrar si falta coinData

                 // Ordenar por valor actual
                portfolioItems.sort((a, b) => b.currentValue - a.currentValue);

                portfolioItems.forEach(item => {
                    const coinName = `${item.coinData.name} (${item.coinData.symbol})`;

                    const itemEl = document.createElement('div');
                    itemEl.className = 'flex justify-between items-center bg-item-bg p-3 rounded-lg';
                    itemEl.innerHTML = `
                        <div>
                            <div class="font-semibold">${coinName}</div>
                            <div class="text-sm text-gray-400">${formatNumber(item.amount, 4)} tokens</div>
                        </div>
                        <div class="text-right">
                            <div class="font-semibold">${formatCurrency(item.currentValue)}</div>
                            <div class="text-sm text-gray-400">Valor</div>
                        </div>
                    `;
                    portfolioListEl.appendChild(itemEl);
                });
            }


            function subscribeToMemecoins() {
                // Carga inicial
                async function loadInitialCoins() {
                    const { data, error } = await supabaseClient
                        .from('coins')
                        .select('*')
                        .order('created_at', { ascending: false });
                    if (error) {
                         console.error("Error loading initial coins:", error);
                         memecoinListEl.innerHTML = '<p class="text-red-500">Error al cargar monedas.</p>';
                         return;
                    }
                    allCoinsCache.clear();
                    data.forEach(c => allCoinsCache.set(c.id, c));
                    updateMemecoinListUI();
                }
                loadInitialCoins();

                // Suscripción a cambios
                setupRealtimeSubscription('all-coins', 'coins', null, (payload) => {
                     const eventType = payload.eventType;
                     const record = eventType === 'DELETE' ? payload.old : payload.new;
                     const coinId = record?.id;

                     if (!coinId) return;

                     if (eventType === 'INSERT' || eventType === 'UPDATE') {
                         allCoinsCache.set(coinId, record);
                     } else if (eventType === 'DELETE') {
                         allCoinsCache.delete(coinId);
                     }
                     // Re-renderizar toda la lista para mantener el orden y actualizar todo
                     updateMemecoinListUI();
                });
            }

            // --- LÓGICA DE GRÁFICA (CHART.JS) ---
            function initChart() {
                // Registrar plugin ANTES de crear el chart
                if (typeof ChartjsPluginAnnotation !== 'undefined') {
                    Chart.register(ChartjsPluginAnnotation);
                } else {
                    console.warn("ChartjsPluginAnnotation not loaded.");
                }

                const ctx = document.getElementById('coin-chart-modal').getContext('2d');
                chartGradient = createChartGradient(ctx, 'green'); // Gradiente por defecto

                // Destruir chart existente si lo hay
                 if (memecoinChart) {
                     memecoinChart.destroy();
                 }

                memecoinChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [
                            {
                                label: 'Precio', data: [], borderColor: '#14F195', borderWidth: 2, pointRadius: 0, tension: 0.3, fill: true, backgroundColor: chartGradient, yAxisID: 'yPrice',
                            },
                            {
                                label: 'Volumen', data: [], backgroundColor: 'rgba(153, 69, 255, 0.4)', type: 'bar', yAxisID: 'yVolume',
                            }
                        ]
                    },
                    options: {
                        responsive: true, maintainAspectRatio: false,
                        scales: {
                            yPrice: { type: 'linear', position: 'left', ticks: { color: '#9CA3AF', callback: (value) => formatPrice(value) }, grid: { color: 'rgba(255, 255, 255, 0.1)' } },
                            yVolume: { type: 'linear', position: 'right', ticks: { display: false }, grid: { display: false }, beginAtZero: true },
                            x: { ticks: { display: false }, grid: { color: 'rgba(255, 255, 255, 0.1)' } }
                        },
                        plugins: {
                            legend: { display: false },
                            tooltip: {
                                enabled: true, mode: 'index', intersect: false,
                                callbacks: {
                                    label: (context) => {
                                        if (context.datasetIndex === 0) return `Precio: ${formatPrice(context.parsed.y)}`;
                                        if (context.datasetIndex === 1) return `Volumen: ${formatCurrency(context.parsed.y)}`;
                                        return '';
                                    }
                                }
                            },
                            // Configuración inicial de anotaciones (vacía)
                            annotation: { annotations: {} }
                        }
                    }
                });
            }

             function createChartGradient(ctx, color) { /* ... (sin cambios) ... */
                const gradient = ctx.createLinearGradient(0, 0, 0, 400);
                if (color === 'green') {
                    gradient.addColorStop(0, 'rgba(20, 241, 149, 0.5)'); // solana-green
                } else {
                    gradient.addColorStop(0, 'rgba(239, 68, 68, 0.5)'); // red-500
                }
                gradient.addColorStop(1, 'rgba(31, 41, 55, 0)'); // item-bg (transparente)
                return gradient;
             }
            // Asegurarse que updateChart usa nombres de columna SQL (ej. price_history)
             function updateChart(coinData) {
                if (!memecoinChart) return;

                // Usar nombres de columna SQL
                const history = coinData.price_history?.slice(-50) || [];
                const volumeHistory = (coinData.volume_history || []).slice(-50);

                let newColor = '#14F195';
                let newGradientColor = 'green';
                 // Usar current_price
                if (history.length > 1 && coinData.current_price < history[history.length - 2]) {
                    newColor = '#EF4444'; // red-500
                    newGradientColor = 'red';
                }

                memecoinChart.data.datasets[0].borderColor = newColor;
                memecoinChart.data.datasets[0].backgroundColor = createChartGradient(memecoinChart.ctx, newGradientColor);

                memecoinChart.data.labels = history.map((_, i) => i + 1);
                memecoinChart.data.datasets[0].data = history;
                memecoinChart.data.datasets[1].data = volumeHistory;

                // Actualizar anotaciones (asegurarse que la función es async si llama a supabaseClient)
                updateChartAnnotations(coinData.id); // 'id' es el nombre en SQL

                memecoinChart.update('none');
            }
             // updateChartAnnotations necesita leer trade_history de wallets (usar async/await)
            async function updateChartAnnotations(coinId) {
                // Verificar si el plugin está registrado y el chart existe
                if (!memecoinChart || !memecoinChart.options.plugins.annotation) {
                    // console.warn("Annotations plugin not ready or chart destroyed.");
                    return;
                 }


                let annotations = {};
                const { data: walletData, error } = await supabaseClient
                    .from('wallets')
                    .select('trade_history')
                    .eq('user_id', currentUserId)
                    .eq('coin_id', coinId)
                    .single();

                if (!error && walletData && walletData.trade_history) {
                    const tradeHistory = walletData.trade_history || [];
                    tradeHistory.forEach((trade, index) => {
                         const isBuy = trade.type === 'buy';
                         annotations[`line${index}`] = {
                             type: 'line',
                             yMin: trade.price,
                             yMax: trade.price,
                             borderColor: isBuy ? 'rgba(34, 197, 94, 0.7)' : 'rgba(239, 68, 68, 0.7)',
                             borderWidth: 2,
                             borderDash: [6, 6],
                             label: {
                                 // content: isBuy ? `Compra (${formatNumber(trade.amountSsol)} sSOL)` : `Venta (${formatNumber(trade.amountSsol)} sSOL)`,
                                 content: isBuy ? `C` : `V`, // Contenido más corto
                                 enabled: true,
                                 position: index % 2 === 0 ? 'start' : 'end', // Alternar posición
                                 backgroundColor: isBuy ? 'rgba(34, 197, 94, 0.7)' : 'rgba(239, 68, 68, 0.7)',
                                 font: { size: 9 },
                                 color: 'white',
                                 padding: 2,
                                 // xPadding: 4, yPadding: 4,
                                 borderRadius: 4
                             }
                         };
                    });
                } else if (error && error.code !== 'PGRST116') { // Ignorar 'not found'
                     console.error("Error fetching trade history for annotations:", error);
                }

                // Asignar y actualizar
                memecoinChart.options.plugins.annotation.annotations = annotations;
                // No llamamos a update aquí, se llama desde updateChart
            }


            // updateSelectedCoinPrice sin cambios
             function updateSelectedCoinPrice(price) {
                modalCoinPriceEl.textContent = `${formatPrice(price)}`;
            }
            // selectCoin usa nombres SQL (current_price, contract_id, is_live)
             function selectCoin(coinId) {
                selectedCoinId = coinId;
                const coinData = allCoinsCache.get(coinId);

                if (!coinData) return;

                modalCoinNameEl.textContent = `${coinData.name} (${coinData.symbol})`;
                 // Usar 'id' como contract_id ya que es UNIQUE
                modalContractIdEl.textContent = `ID: ...${coinData.id.slice(-6)}`; // Acortado
                updateSelectedCoinPrice(coinData.current_price); // SQL: current_price
                updateChart(coinData);
                showModal(chartModalEl);

                modalLiveBadgeEl.classList.toggle('hidden', !coinData.is_live); // SQL: is_live
                viewLiveBtnEl.classList.toggle('hidden', !coinData.is_live); // SQL: is_live

                Array.from(memecoinListEl.children).forEach(child => {
                    child.classList.toggle('bg-solana-purple/50', child.dataset.coinId === coinId);
                    child.classList.toggle('bg-item-bg', child.dataset.coinId !== coinId);
                });
            }


            // --- ACCIONES DEL JUGADOR ---

            // updateMemecoinListUI adaptada para Supabase (nombres SQL)
            function updateMemecoinListUI() {
                memecoinListEl.innerHTML = '';
                const filterText = coinFilterInputEl.value.toLowerCase();
                let coinsToShow = Array.from(allCoinsCache.values()); // Cache ya ordenado por created_at

                if (filterText) {
                    coinsToShow = coinsToShow.filter(coin =>
                        coin.name.toLowerCase().includes(filterText) ||
                        coin.symbol.toLowerCase().includes(filterText)
                    );
                }

                if (coinsToShow.length === 0) {
                    memecoinListEl.innerHTML = `<p class="text-gray-400 text-center mt-10">${filterText ? 'No se encontraron monedas.' : 'No hay monedas. ¡Lanza la primera!'}</p>`;
                    return;
                }

                coinsToShow.forEach(coin => {
                     // Calcular cambio de precio
                     const priceHistory = coin.price_history || [];
                     const priceChange = priceHistory.length > 1 ? (coin.current_price - priceHistory[priceHistory.length - 2]) / priceHistory[priceHistory.length - 2] : 0;
                    const changeColor = priceChange >= 0 ? 'text-green-500' : 'text-red-500';
                    const changeIcon = priceChange >= 0 ? '▲' : '▼';
                    const placeholderImg = `https://placehold.co/40x40/${coin.id.slice(0,6)}/FFFFFF?text=${coin.symbol}`;
                     const creatorUsername = allPlayersCache.get(coin.creator_id)?.username || '...' + coin.creator_id?.slice(-6) || 'Desconocido';


                    const coinEl = document.createElement('button');
                    coinEl.className = `w-full text-left p-3 rounded-lg transition duration-200 ${selectedCoinId === coin.id ? 'bg-solana-purple/50' : 'bg-item-bg hover:bg-item-hover'}`;
                    coinEl.dataset.coinId = coin.id;
                    coinEl.innerHTML = `
                        <div class="flex justify-between items-center">
                            <div class="flex items-center gap-3 overflow-hidden mr-2"> <!-- Añadido overflow-hidden -->
                                <img src="${coin.image_url || placeholderImg}" onerror="this.src='${placeholderImg}'" alt="${coin.name}" class="w-10 h-10 rounded-full bg-gray-700 flex-shrink-0"> <!-- Añadido flex-shrink-0 -->
                                <div class="truncate"> <!-- Añadido truncate -->
                                    <span class="text-lg font-bold block truncate">${coin.name} (${coin.symbol})</span> <!-- Añadido block truncate -->
                                    <span class="text-xs text-gray-400 block" title="${coin.creator_id}">Creador: ${creatorUsername}</span>
                                </div>
                                ${coin.is_live ? `<span class="animate-livePulse text-xs font-bold bg-red-600 text-white px-2 py-0.5 rounded-md ml-2 flex-shrink-0">LIVE</span>` : ''}
                                ${coin.x_url ? `
                                    <div class="x-popover-container ml-1 flex-shrink-0">
                                        <i class="ph ph-x text-gray-400 hover:text-x-blue cursor-pointer text-base"></i>
                                        <div class="x-popover glassmorphism p-3 rounded-lg shadow-xl text-xs">
                                            <div class="flex items-center gap-2 mb-2">
                                                <img src="${coin.image_url || placeholderImg}" alt="${coin.name}" class="w-8 h-8 rounded-full">
                                                <div>
                                                    <p class="font-bold text-white">${coin.name} <i class="ph ph-check-circle-fill text-x-blue text-xs align-middle"></i></p>
                                                    <p class="text-gray-400">@${(coin.name || 'memecoin').replace(/\s/g, '_').slice(0,10)}_Official</p>
                                                </div>
                                            </div>
                                            <p class="text-gray-300 mb-2">¡Sigue el hype en X!</p>
                                            <div class="flex justify-between text-gray-400 mb-2">
                                                <span><strong class="text-white">${formatNumber(coin.followers || 0, 0)}</strong> Seguidores</span>
                                            </div>
                                            <a href="${coin.x_url}" target="_blank" class="w-full inline-block bg-x-blue hover:bg-opacity-80 text-white font-bold py-1.5 px-2 rounded-md transition duration-200 text-center">Ver perfil en X</a>
                                        </div>
                                    </div>
                                ` : ''}
                            </div>
                            <div class="text-right flex-shrink-0"> <!-- Añadido flex-shrink-0 -->
                                <span class="text-lg font-mono block">${formatPrice(coin.current_price)}</span>
                                <span class="text-sm font-semibold ${changeColor}">${changeIcon} ${formatNumber(isNaN(priceChange) ? 0 : priceChange * 100)}%</span>
                            </div>
                        </div>

                        <div class="grid grid-cols-3 sm:grid-cols-5 gap-2 mt-3 text-xs text-center">
                            <div>
                                <span class="text-gray-400 block">MC</span>
                                <span class="font-semibold">${formatCurrency(coin.market_cap || 0)}</span>
                            </div>
                            <div>
                                <span class="text-gray-400 block">Liquidez</span>
                                <span class="font-semibold">${formatCurrency(coin.s_sol_pool || 0)}</span>
                            </div>
                             <div>
                                <span class="text-gray-400 block">Volumen</span>
                                <span class="font-semibold">${formatCurrency(coin.volume || 0)}</span>
                            </div>
                             <div>
                                <span class="text-gray-400 block">Holders</span>
                                <span class="font-semibold">${formatNumber(coin.holder_count || 0, 0)}</span>
                            </div>
                            <div>
                                <span class="text-gray-400 block">Seguidores</span>
                                <span class="font-semibold">${formatNumber(coin.followers || 0, 0)}</span>
                            </div>
                        </div>
                    `;
                    coinEl.addEventListener('click', () => selectCoin(coin.id));
                    memecoinListEl.appendChild(coinEl);

                    // Actualizar modal si esta moneda está seleccionada
                    if (coin.id === selectedCoinId) {
                        updateChart(coin);
                        updateSelectedCoinPrice(coin.current_price);
                        modalCoinNameEl.textContent = `${coin.name} (${coin.symbol})`;
                        modalContractIdEl.textContent = `ID: ...${coin.id.slice(-6)}`;
                        modalLiveBadgeEl.classList.toggle('hidden', !coin.is_live);
                        viewLiveBtnEl.classList.toggle('hidden', !coin.is_live);
                    }
                });

                // updatePortfolioValues(); // Ya no es necesario llamar aquí, se actualiza por realtime
            }


             coinFilterInputEl.addEventListener('input', updateMemecoinListUI);

             // updateMyAssetsUI adaptada para Supabase (nombres SQL)
            function updateMyAssetsUI() {
                myLuxuryAssetsListEl.innerHTML = '';
                myOfficeAssetsListEl.innerHTML = '';
                officeLayoutEl.innerHTML = ''; // Limpiar oficina

                // Lujo (assets)
                if (myAssetsCache.assets.size === 0) {
                    myLuxuryAssetsListEl.innerHTML = '<p class="text-gray-400 text-sm">Aún no tienes activos de lujo.</p>';
                } else {
                    myAssetsCache.assets.forEach((count, item) => {
                        let emoji = '❓';
                        if (item === 'lambo') emoji = '🏎️';
                        if (item === 'mansion') emoji = '🏰';
                        if (item === 'yate') emoji = '🛥️';
                        if (item === 'jet') emoji = '✈️';
                        const name = item.charAt(0).toUpperCase() + item.slice(1);
                        const itemEl = document.createElement('div');
                        itemEl.className = 'bg-item-bg p-3 rounded-lg text-center';
                        itemEl.innerHTML = `
                            <span class="text-2xl">${emoji}</span>
                            <div class="text-sm font-semibold">${name} (x${count})</div>
                        `;
                        myLuxuryAssetsListEl.appendChild(itemEl);
                    });
                }

                // Oficina (office_items)
                if (myAssetsCache.office.size === 0) {
                    myOfficeAssetsListEl.innerHTML = '<p class="text-gray-400 text-sm">Aún no tienes artículos de oficina.</p>';
                     officeLayoutEl.innerHTML = '<p class="text-gray-400 text-center pt-20">Tu oficina está vacía.</p>';
                } else {
                     myAssetsCache.office.forEach((data, item) => {
                         const name = item.charAt(0).toUpperCase() + item.slice(1);
                        const itemElList = document.createElement('div'); // Elemento para la lista
                        itemElList.className = 'bg-item-bg p-3 rounded-lg text-center';
                        itemElList.innerHTML = `
                            <span class="text-2xl">${data.emoji}</span>
                            <div class="text-sm font-semibold">${name} (x${data.count})</div>
                        `;
                        myOfficeAssetsListEl.appendChild(itemElList);

                        // Añadir al layout de la oficina (solo 1 por tipo por ahora)
                         if(data.count > 0) { // Mostrar si tiene al menos 1
                            const officeItemEl = document.createElement('span');
                            officeItemEl.className = 'office-item';
                            officeItemEl.style.cssText = data.pos;
                            officeItemEl.textContent = data.emoji;
                            officeLayoutEl.appendChild(officeItemEl);
                         }
                    });
                     // Si después de iterar, la oficina sigue vacía (porque count era 0?)
                     if(officeLayoutEl.innerHTML === '') {
                        officeLayoutEl.innerHTML = '<p class="text-gray-400 text-center pt-20">Tu oficina está vacía.</p>';
                     }
                }
            }


            // Formulario de Crear Moneda (adaptado)
            createCoinFormEl.addEventListener('submit', async (e) => {
                e.preventDefault();
                const name = coinNameEl.value.trim();
                const symbol = coinSymbolEl.value.trim().toUpperCase();
                const imageUrl = coinImageUrlEl.value.trim();
                const xUrl = coinXUrlEl.value.trim();
                 // Usar parseFloatStrict para inputs numéricos
                const initialSsol = parseFloatStrict(coinInitialSsolEl.value);
                const initialTokens = parseFloatStrict(coinInitialTokensEl.value);


                if (!name || !symbol || isNaN(initialSsol) || isNaN(initialTokens) || initialSsol <= 0 || initialTokens <= 0) {
                    showMessage("Completa los campos de liquidez correctamente.");
                    return;
                }

                const launchCost = 0.01;
                const totalCost = launchCost + initialSsol;

                // Verificar balance ANTES de intentar la transacción (aunque no es atómico)
                if (!currentUserData || currentUserData.s_sol_balance < totalCost) {
                    return showMessage(`Fondos insuficientes. Necesitas ${formatNumber(totalCost)} sSOL.`);
                }
                 const createButton = createCoinFormEl.querySelector('button[type="submit"]');
                 createButton.disabled = true; createButton.textContent = 'Lanzando...';

                try {
                    // 1. Descontar balance del jugador
                    const { error: balanceError } = await supabaseClient
                        .from('players')
                        .update({ s_sol_balance: currentUserData.s_sol_balance - totalCost })
                        .eq('user_id', currentUserId);

                    if (balanceError) throw new Error(`Error al actualizar balance: ${balanceError.message}`);
                    currentUserData.s_sol_balance -= totalCost; // Update local cache

                    // 2. Crear la moneda
                    const price = initialSsol / initialTokens;
                    const placeholderImgUrl = `https://placehold.co/40x40/random/FFFFFF?text=${symbol}`; // Placeholder simple
                    const { data: newCoinData, error: coinError } = await supabaseClient
                        .from('coins')
                        .insert({
                            name: name,
                            symbol: symbol,
                            creator_id: currentUserId,
                            image_url: imageUrl || placeholderImgUrl,
                            x_url: xUrl || '',
                            s_sol_pool: initialSsol,
                            token_pool: initialTokens,
                            current_price: price,
                            price_history: [price], // Inicializar array
                            volume_history: [0], // Inicializar array
                            all_time_high: price,
                            all_time_low: price,
                            market_cap: initialSsol * 2,
                             // followers se inicializa basado en los del creador
                            followers: (currentUserData.social_followers || 0) + 1,
                            holder_count: 1, // El creador es el primer holder
                            last_holder_count_change: 1, // El creador cuenta como +1 inicial
                            // contract_id se actualizará después con el 'id' generado
                        })
                        .select() // Pedir que devuelva el registro insertado
                        .single(); // Esperamos solo uno

                    if (coinError) {
                         // Intentar revertir el balance si falla la creación de la moneda (mejor esfuerzo)
                        await supabaseClient.from('players').update({ s_sol_balance: currentUserData.s_sol_balance + totalCost }).eq('user_id', currentUserId);
                        currentUserData.s_sol_balance += totalCost;
                        throw new Error(`Error al crear moneda: ${coinError.message}`);
                    }

                    // Actualizar contract_id con el ID generado
                     const newCoinId = newCoinData.id;
                     const { error: updateContractIdError } = await supabaseClient
                         .from('coins')
                         .update({ contract_id: newCoinId })
                         .eq('id', newCoinId);
                     if (updateContractIdError) console.warn("Could not backfill contract_id:", updateContractIdError.message);


                    // 3. Crear la entrada en la billetera del creador
                    const { error: walletError } = await supabaseClient
                        .from('wallets')
                        .insert({
                            user_id: currentUserId,
                            coin_id: newCoinId,
                            amount: initialTokens,
                            trade_history: [], // Inicializar historial
                        });

                     if (walletError) {
                         // Aquí la situación es más compleja para revertir...
                         console.error("Error crítico al crear wallet inicial:", walletError);
                         showMessage("Moneda creada pero hubo un error al añadirla a tu wallet.");
                         // No lanzar error para que al menos la moneda exista
                     }


                    hideModal(createCoinModalEl);
                    showMessage(`¡Moneda ${name} (${symbol}) lanzada con éxito!`);
                    createCoinFormEl.reset();
                    showPage('page-portafolio');

                } catch (error) {
                    console.error("Error detallado al lanzar moneda:", error);
                    showMessage(error.message); // Mostrar el error específico
                } finally {
                     createButton.disabled = false; createButton.textContent = 'Lanzar (Costo: 0.01 sSOL + Liq.)';
                }
            });


            // --- LÓGICA DE BOTS (Ajustada para Supabase) ---
            // simulateBotTrade necesita nombres SQL y devuelve nombres SQL
            function simulateBotTrade(coinData, playerAction, forceBuyProbability = null) {
                // Usar nombres SQL en la desestructuración
                let {
                    bot_ssol_pool, bot_token_pool, s_sol_pool, token_pool,
                    volume, price_history, volume_history, creator_id,
                    creator_fees_ssol, creator_fees_token, market_cap, all_time_high, all_time_low,
                    followers
                } = coinData;

                // ... (lógica interna sin cambios, excepto nombres de variables) ...
                 if (creator_id === 'bot') return {}; // Asumiendo 'bot' no es un UUID válido

                let buyProbability = 0.6;
                if (playerAction === 'proactive' && forceBuyProbability !== null) {
                    buyProbability = forceBuyProbability;
                }

                const isBuy = (Math.random() < buyProbability);

                let ssolTraded = 0;
                let ssolForTrade = 0;
                let tokensForTrade = 0;
                let tokensReceived = 0;
                let ssolReceived = 0;
                let finalSsolPool = s_sol_pool;
                let finalTokenPool = token_pool;
                let newCreatorFeesSsol = creator_fees_ssol || 0;
                let newCreatorFeesToken = creator_fees_token || 0;
                let newFollowers = followers || 0;
                let creatorFollowsIncrement = 0;

                if (isBuy) {
                    const ssolToSpend = (Math.pow(Math.random(), 2) * (bot_ssol_pool * 0.1));
                    if (ssolToSpend < 0.00000001 || bot_ssol_pool < ssolToSpend) return { updates: {}, creatorFollowsIncrement: 0 }; // Devolver objeto vacío si no hay trade

                    bot_ssol_pool -= ssolToSpend;
                    ssolTraded = ssolToSpend;

                    const totalFee = ssolToSpend * TOTAL_FEE;
                    ssolForTrade = ssolToSpend - totalFee;

                    const k = s_sol_pool * token_pool;
                    const newSsolPool_k = s_sol_pool + ssolForTrade;
                     // Evitar división por cero
                    finalTokenPool = newSsolPool_k > 0 ? k / newSsolPool_k : 0;
                    tokensReceived = token_pool - finalTokenPool;

                    finalSsolPool = newSsolPool_k;
                    newCreatorFeesSsol += totalFee; // Sumar TODA la comisión a sSOL (LP+Creator)

                    bot_token_pool += tokensReceived;

                    newFollowers++;
                    if (Math.random() < 0.1) { // Reducida probabilidad de seguir
                        creatorFollowsIncrement = 1;
                    }

                } else {
                    const sellPercentage = (Math.pow(Math.random(), 2) * 0.1); // Vender máx 10%
                    const tokensToSell = bot_token_pool * sellPercentage;
                    if (tokensToSell < 0.00000001 || bot_token_pool < tokensToSell) return { updates: {}, creatorFollowsIncrement: 0 }; // Devolver objeto vacío si no hay trade

                    bot_token_pool -= tokensToSell;

                    const totalFee = tokensToSell * TOTAL_FEE;
                    tokensForTrade = tokensToSell - totalFee;

                    const k = s_sol_pool * token_pool;
                    const newTokenPool_k = token_pool + tokensForTrade;
                     // Evitar división por cero
                    finalSsolPool = newTokenPool_k > 0 ? k / newTokenPool_k : 0;
                    ssolReceived = s_sol_pool - finalSsolPool;
                    ssolTraded = ssolReceived;

                    finalTokenPool = newTokenPool_k;
                    newCreatorFeesToken += totalFee; // Sumar TODA la comisión a Tokens

                    bot_ssol_pool += ssolReceived;
                }

                 // Recalcular precio solo si los pools son válidos
                const newPrice = finalTokenPool > 0 && finalSsolPool > 0 ? finalSsolPool / finalTokenPool : coinData.current_price; // Mantener precio si pool es 0
                const newAllTimeHigh = Math.max(all_time_high || 0, newPrice);
                const newAllTimeLow = Math.min(all_time_low || 999999, newPrice);
                const newMarketCap = newPrice * (finalTokenPool + bot_token_pool);
                 // Asegurarse de que price_history es un array
                const currentPriceHistory = Array.isArray(price_history) ? price_history : [];
                const newHistory = [...currentPriceHistory, newPrice].slice(-50);
                 // Asegurarse de que volume_history es un array
                const currentVolumeHistory = Array.isArray(volume_history) ? volume_history : [];
                const newVolumeHistory = [...currentVolumeHistory, ssolTraded].slice(-50);

                const newVolume = volume + ssolTraded;

                // Retornar objeto con nombres SQL
                const updates = {
                    s_sol_pool: finalSsolPool,
                    token_pool: finalTokenPool,
                    bot_ssol_pool: bot_ssol_pool,
                    bot_token_pool: bot_token_pool,
                    current_price: newPrice,
                    price_history: newHistory,
                    volume_history: newVolumeHistory,
                    volume: newVolume,
                    market_cap: newMarketCap,
                    creator_fees_ssol: newCreatorFeesSsol,
                    creator_fees_token: newCreatorFeesToken,
                    all_time_high: newAllTimeHigh,
                    all_time_low: newAllTimeLow,
                    // No incluir creatorFollowsIncrement aquí, manejar fuera
                };

                if (isBuy) updates.followers = newFollowers;

                // Devolver también el incremento para manejarlo fuera
                return { updates, creatorFollowsIncrement };
            }

            // proactiveBotLoop adaptado para Supabase (update, nombres SQL)
             async function proactiveBotLoop() {
                if (allCoinsCache.size > 0 && allPlayersCache.size > 0) {
                    for (const [coinId, coin] of allCoinsCache.entries()) {
                         // Usar nombres SQL
                        const allTimeHigh = coin.all_time_high || coin.price_history?.[0] || 0;
                        const currentPrice = coin.current_price;
                        let buyProbability = 0.5;
                        let tradeProbability = 0.0;

                         if (allTimeHigh > 0 && (currentPrice / allTimeHigh) < 0.2) {
                             tradeProbability = 0.1;
                             buyProbability = 0.05;
                         } else {
                             const priceHistory = coin.price_history || [];
                             let priceChange = 0;
                             if (priceHistory.length > 1) {
                                 const prevPrice = priceHistory[priceHistory.length - 2];
                                 if (prevPrice > 0) priceChange = (coin.current_price - prevPrice) / prevPrice;
                             }

                             const creator = allPlayersCache.get(coin.creator_id);
                             const creatorFollowers = creator ? (creator.social_followers || 0) : 0;
                             const creatorFollowerScore = Math.min(1.0, creatorFollowers / 1000);

                             const priceChangeScore = Math.min(1, priceChange / 0.1);
                             const volumeRatio = (coin.s_sol_pool > 0) ? (coin.volume || 0) / coin.s_sol_pool : 0;
                             const volumeScore = Math.min(1, volumeRatio / 10);
                             const holderScore = Math.min(1, (coin.last_holder_count_change || 0) / 5);
                             const liveScore = coin.is_live ? Math.min(1.0, (coin.live_viewers || 0) / 1000) : 0.0;
                             const followersScore = Math.min(1, (coin.followers || 0) / 1000);

                             const totalHypeScore = (priceChangeScore + volumeScore + holderScore + (followersScore*1.5) + (liveScore * 5) + (creatorFollowerScore * 2)) / 11.5;
                             tradeProbability = totalHypeScore * 0.7;

                             if (priceChange > 0) buyProbability = 0.5 + (totalHypeScore * 0.45);
                             else buyProbability = 0.5 - ((1 - totalHypeScore) * 0.45);
                         }

                         // Probabilidad de seguir a un jugador aleatorio
                        if (Math.random() < 0.01) {
                            try {
                                const playerIds = Array.from(allPlayersCache.keys()).filter(id => id !== currentUserId && id !== coin.creator_id); // No seguirse a sí mismo ni al creador
                                if (playerIds.length > 0) {
                                    const randomPlayerId = playerIds[Math.floor(Math.random() * playerIds.length)];
                                    if (randomPlayerId) {
                                        // Usar RPC sería más robusto para incrementos concurrentes
                                        const { error } = await supabaseClient.rpc('increment_followers', { user_uuid: randomPlayerId, amount: 1 });
                                        if(error) console.warn("Bot failed to follow (RPC):", error.message);
                                        // else console.log("Bot followed player:", randomPlayerId);
                                    }
                                }
                            } catch(e) { console.warn("Bot failed to follow random player (client):", e.message); }
                        }

                        if (Math.random() < tradeProbability) {
                            // --- INICIO: Lógica de transacción simulada (NO ATÓMICA) ---
                            // 1. Obtener datos actuales de la moneda (podrían estar obsoletos)
                            const currentCoinData = allCoinsCache.get(coinId);
                            if (!currentCoinData) continue;

                            // 2. Simular el trade del bot
                            const { updates: botUpdates, creatorFollowsIncrement } = simulateBotTrade(currentCoinData, 'proactive', buyProbability);

                            if (Object.keys(botUpdates).length > 0) {
                                // 3. Actualizar la moneda
                                botUpdates.last_holder_count_change = 0; // Resetear contador
                                const { error: coinUpdateError } = await supabaseClient
                                    .from('coins')
                                    .update(botUpdates)
                                    .eq('id', coinId);

                                if (coinUpdateError) {
                                    console.warn(`Bot failed coin update for ${coinId}:`, coinUpdateError.message);
                                } else {
                                     // 4. Incrementar seguidores del creador si aplica (después de actualizar moneda)
                                    if (creatorFollowsIncrement > 0) {
                                        const { error: followError } = await supabaseClient.rpc('increment_followers', { user_uuid: currentCoinData.creator_id, amount: creatorFollowsIncrement });
                                        if (followError) console.warn(`Bot failed creator follow for ${coinId}:`, followError.message);
                                    }
                                }
                            }
                            // --- FIN: Lógica de transacción simulada ---
                        }
                    }
                }
                setTimeout(proactiveBotLoop, 5000);
            }
             // Crear función RPC 'increment_followers' en Supabase SQL Editor:
             /*
                CREATE OR REPLACE FUNCTION increment_followers(user_uuid uuid, amount int)
                RETURNS void AS $$
                  UPDATE public.players
                  SET social_followers = social_followers + amount
                  WHERE user_id = user_uuid;
                $$ LANGUAGE sql VOLATILE;
             */


            // Formulario de Compra (usa RPC handle_buy si existe, o lógica secuencial como fallback)
            // IMPORTANTE: La lógica secuencial NO ES ATÓMICA.
            buyFormEl.addEventListener('submit', async (e) => {
                e.preventDefault();
                const ssolToSpend = parseFloatStrict(buyAmountEl.value);
                if (!selectedCoinId || isNaN(ssolToSpend) || ssolToSpend <= 0) return showMessage("Ingresa un monto válido.");

                 buyAmountEl.disabled = true; // Deshabilitar mientras procesa
                 const buyButton = buyFormEl.querySelector('button[type="submit"]');
                 buyButton.disabled = true;
                 buyButton.textContent = 'Procesando...';

                try {
                     // Intentar usar RPC si existe (Asegúrate de haberla creado en Supabase SQL)
                     /* // Descomentar si creaste y probaste la RPC handle_buy
                    const { data: rpcData, error: rpcError } = await supabaseClient.rpc('handle_buy', {
                        p_user_id: currentUserId,
                        p_coin_id: selectedCoinId,
                        p_ssol_to_spend: ssolToSpend
                    });

                    if (rpcData && rpcData.success) {
                        showMessage(`¡Compraste ${formatNumber(rpcData.tokensReceived, 4)} ${allCoinsCache.get(selectedCoinId)?.symbol} a ~${formatPrice(rpcData.newPrice)}! (RPC)`);
                        // Actualizar caché local de balance si es necesario (o confiar en realtime)
                        if (currentUserData) currentUserData.s_sol_balance -= ssolToSpend;
                        // ssolBalanceEl.textContent = `${formatNumber(currentUserData.s_sol_balance)} sSOL`; // Realtime lo hará
                    } else if (rpcError || (rpcData && rpcData.error)) {
                         console.warn("RPC handle_buy falló o no existe, usando fallback secuencial:", rpcError || rpcData.error);
                         await buySequentially(ssolToSpend); // Llamar a la función secuencial
                    } else {
                        // Caso inesperado de RPC
                         await buySequentially(ssolToSpend); // Usar fallback si RPC no devuelve success/error claros
                        // throw new Error("Respuesta inesperada de la función de compra.");
                    }
                    */
                    // Por ahora, usar siempre el fallback secuencial hasta que RPC esté robusta
                    await buySequentially(ssolToSpend);

                    buyAmountEl.value = '';

                } catch (error) {
                    console.error("Error al comprar:", error);
                    showMessage(`Error al comprar: ${error.message}`);
                } finally {
                     buyAmountEl.disabled = false;
                     buyButton.disabled = false;
                     buyButton.textContent = 'Comprar';
                }
            });
             // Lógica de compra secuencial (Fallback, NO ATÓMICA)
            async function buySequentially(ssolToSpend) {
                 // 1. Leer datos necesarios (podrían cambiar entre lecturas!)
                 if (!currentUserData) throw new Error("Datos del usuario no cargados."); // Chequeo inicial
                 const currentBalance = currentUserData.s_sol_balance; // Usar caché como chequeo inicial rápido
                 if (currentBalance < ssolToSpend) throw new Error("sSOL insuficiente (verificación inicial).");

                const { data: coinData, error: coinError } = await supabaseClient.from('coins').select('*').eq('id', selectedCoinId).single();
                const { data: walletData, error: walletError } = await supabaseClient.from('wallets').select('amount, trade_history').eq('user_id', currentUserId).eq('coin_id', selectedCoinId).single();
                 // Ignorar walletError si es 'not found' (PGRST116)

                if (coinError || (walletError && walletError.code !== 'PGRST116')) {
                    throw new Error(`Error al leer datos: ${coinError?.message || walletError?.message}`);
                }
                if (!coinData) throw new Error("Datos de moneda no encontrados.");

                // Re-verificar balance desde la DB (más seguro que la caché)
                 const { data: playerDataDB, error: playerErrorDB } = await supabaseClient.from('players').select('s_sol_balance, social_followers').eq('user_id', currentUserId).single();
                 if(playerErrorDB || !playerDataDB) throw new Error("Error al verificar balance final.");
                 if(playerDataDB.s_sol_balance < ssolToSpend) throw new Error("sSOL insuficiente (verificación final).");


                // --- Calcular trade (igual que antes) ---
                const { updates: botUpdates, creatorFollowsIncrement: botCreatorFollows } = simulateBotTrade(coinData, 'reactive_buy');
                let coinDataAfterBot = { ...coinData, ...botUpdates }; // Datos tras simulación de bot

                const ssolTraded = ssolToSpend;
                const totalFee = ssolToSpend * TOTAL_FEE;
                const ssolForTrade = ssolToSpend - totalFee;
                const k = coinDataAfterBot.s_sol_pool * coinDataAfterBot.token_pool;
                const newSsolPool_k = coinDataAfterBot.s_sol_pool + ssolForTrade;
                 // Evitar división por cero
                const newTokenPool = newSsolPool_k > 0 ? k / newSsolPool_k : 0;
                const tokensReceived = coinDataAfterBot.token_pool - newTokenPool;
                const finalSsolPool = newSsolPool_k;

                 if (tokensReceived <= 0.00000001) throw new Error("No se recibirían suficientes tokens (posiblemente liquidez baja o monto pequeño).");

                 // Calcular precio DESPUÉS de aplicar el trade
                const newPrice = finalSsolPool > 0 && newTokenPool > 0 ? finalSsolPool / newTokenPool : coinData.current_price;

                const newAllTimeHigh = Math.max(coinDataAfterBot.all_time_high || 0, newPrice);
                const newAllTimeLow = Math.min(coinDataAfterBot.all_time_low || 999999, newPrice);
                const newMarketCap = newPrice * (newTokenPool + coinDataAfterBot.bot_token_pool);
                const currentPriceHistory = Array.isArray(coinDataAfterBot.price_history) ? coinDataAfterBot.price_history : [];
                const newHistory = [...currentPriceHistory, newPrice].slice(-50);
                const currentVolumeHistory = Array.isArray(coinDataAfterBot.volume_history) ? coinDataAfterBot.volume_history : [];
                const newVolumeHistory = [...currentVolumeHistory, ssolTraded].slice(-50);

                const newVolume = coinDataAfterBot.volume + ssolTraded;
                const newCreatorFeesSsol = (coinDataAfterBot.creator_fees_ssol || 0) + totalFee; // Sumar toda la fee

                let newHolderCount = coinDataAfterBot.holder_count;
                let holderChange = 0;
                let newFollowers = coinDataAfterBot.followers || 0;
                let playerCreatorFollows = 0;
                const currentTokens = walletData ? walletData.amount : 0;

                if (currentTokens < 0.00000001) {
                    newHolderCount++;
                    holderChange = 1;
                    newFollowers++;
                    playerCreatorFollows = 1;
                }
                const newLastHolderCountChange = (coinDataAfterBot.last_holder_count_change || 0) + holderChange;

                const currentTradeHistory = walletData?.trade_history || [];
                 // Guardar precio AL QUE SE EJECUTÓ (newPrice)
                const updatedTradeHistory = [...currentTradeHistory, {
                    type: 'buy', price: newPrice, amountSsol: ssolToSpend, amountToken: tokensReceived, coinId: selectedCoinId, timestamp: new Date().toISOString()
                }].slice(-50);

                 // --- Actualizar tablas (secuencialmente, NO ATÓMICO) ---
                 // 1. Actualizar balance jugador (Usar RPC si existe)
                 const { error: playerUpdateError } = await supabaseClient.rpc('increment_balance', { user_uuid: currentUserId, amount: -ssolToSpend });
                // const { error: playerUpdateError } = await supabaseClient.from('players').update({ s_sol_balance: playerDataDB.s_sol_balance - ssolToSpend }).eq('user_id', currentUserId); // Fallback
                if (playerUpdateError) throw new Error(`Error player update: ${playerUpdateError.message}`);
                // currentUserData.s_sol_balance -= ssolToSpend; // Realtime lo hará

                 // 2. Actualizar/Insertar wallet (Usar RPC si existe)
                 const { error: walletUpdateError } = await supabaseClient.rpc('increment_wallet_amount', { p_user_id: currentUserId, p_coin_id: selectedCoinId, p_amount: tokensReceived });
                 // const { error: walletUpdateError } = await supabaseClient.from('wallets').upsert({ user_id: currentUserId, coin_id: selectedCoinId, amount: currentTokens + tokensReceived, trade_history: updatedTradeHistory }); // Fallback
                 if (walletUpdateError) {
                    // Revertir balance (mejor esfuerzo)
                    await supabaseClient.rpc('increment_balance', { user_uuid: currentUserId, amount: ssolToSpend });
                    throw new Error(`Error wallet update: ${walletUpdateError.message}`);
                 }
                  // Actualizar historial por separado si se usó RPC de incremento
                 const { error: historyUpdateError } = await supabaseClient.from('wallets').update({trade_history: updatedTradeHistory}).eq('user_id', currentUserId).eq('coin_id', selectedCoinId);
                 if(historyUpdateError) console.warn("Fallback Buy: Failed to update trade history:", historyUpdateError.message);


                 // 3. Actualizar seguidores creador (si aplica)
                if (playerCreatorFollows > 0 || botCreatorFollows > 0) {
                    const totalFollowIncrement = playerCreatorFollows + botCreatorFollows;
                    const { error: followError } = await supabaseClient.rpc('increment_followers', { user_uuid: coinData.creator_id, amount: totalFollowIncrement });
                    if(followError) console.warn("Fallback Buy: Failed to increment creator followers:", followError.message);
                }
                 delete botUpdates.creatorFollowsIncrement; // Ya no se necesita en el update de coin

                 // 4. Actualizar moneda
                const { error: coinUpdateError } = await supabaseClient.from('coins').update({
                    ...botUpdates, // Incluir actualizaciones del bot simulado
                    s_sol_pool: finalSsolPool, token_pool: newTokenPool,
                    current_price: newPrice, price_history: newHistory,
                    volume: newVolume, volume_history: newVolumeHistory,
                    market_cap: newMarketCap, holder_count: newHolderCount,
                    last_holder_count_change: newLastHolderCountChange,
                    creator_fees_ssol: newCreatorFeesSsol, // Sumar aquí
                    // creator_fees_token se suma en venta
                    all_time_high: newAllTimeHigh, all_time_low: newAllTimeLow,
                    followers: newFollowers
                }).eq('id', selectedCoinId);
                 if (coinUpdateError) {
                     // Revertir es complejo aquí... loggear el error
                     console.error("Error crítico al actualizar moneda post-compra:", coinUpdateError);
                     showMessage("Compra registrada, pero error al actualizar estado de la moneda.");
                 } else {
                    showMessage(`¡Compra exitosa! ${formatNumber(tokensReceived, 4)} ${coinData.symbol} a ~${formatPrice(newPrice)}`);
                 }
            }


            // Formulario de Venta (usa lógica secuencial por ahora, NO ATÓMICA)
            // Idealmente, también usaría una función RPC 'handle_sell'
            sellFormEl.addEventListener('submit', async (e) => {
                e.preventDefault();
                const tokensToSell = parseFloatStrict(sellAmountEl.value);
                if (!selectedCoinId || isNaN(tokensToSell) || tokensToSell <= 0) return showMessage("Ingresa un monto válido.");

                 sellAmountEl.disabled = true;
                 const sellButton = sellFormEl.querySelector('button[type="submit"]');
                 sellButton.disabled = true;
                 sellButton.textContent = 'Procesando...';

                try {
                    // --- Lógica secuencial (NO ATÓMICA) ---
                    // 1. Leer datos
                    const { data: coinData, error: coinError } = await supabaseClient.from('coins').select('*').eq('id', selectedCoinId).single();
                    const { data: walletData, error: walletError } = await supabaseClient.from('wallets').select('amount, trade_history').eq('user_id', currentUserId).eq('coin_id', selectedCoinId).single();

                    if (coinError || walletError) {
                        throw new Error(`Error al leer datos: ${coinError?.message || walletError?.message}`);
                    }
                    if (!coinData || !walletData) throw new Error("Datos de moneda o wallet no encontrados.");
                    if (walletData.amount < tokensToSell) throw new Error("No tienes suficientes tokens.");

                     // Verificar balance del jugador (no estrictamente necesario para vender, pero útil)
                     const { data: playerDataDB, error: playerErrorDB } = await supabaseClient.from('players').select('s_sol_balance').eq('user_id', currentUserId).single();
                     if(playerErrorDB || !playerDataDB) throw new Error("Error al verificar datos del jugador.");


                    // --- Calcular trade ---
                    const { updates: botUpdates, creatorFollowsIncrement: botCreatorFollows } = simulateBotTrade(coinData, 'reactive_sell');
                    let coinDataAfterBot = { ...coinData, ...botUpdates };

                    const totalFee = tokensToSell * TOTAL_FEE; // Fee en tokens
                    const tokensForTrade = tokensToSell - totalFee;
                    const k = coinDataAfterBot.s_sol_pool * coinDataAfterBot.token_pool;
                    const newTokenPool_k = coinDataAfterBot.token_pool + tokensForTrade;
                    // Evitar división por cero
                    const newSsolPool = newTokenPool_k > 0 ? k / newTokenPool_k : 0;
                    const ssolReceived = coinDataAfterBot.s_sol_pool - newSsolPool;
                    const finalTokenPool = newTokenPool_k;
                    const ssolTraded = ssolReceived;

                    if (ssolReceived < 0.00000001) throw new Error("Liquidez demasiado baja para recibir sSOL.");

                     // Calcular precio DESPUÉS de aplicar el trade
                    const newPrice = newSsolPool > 0 && finalTokenPool > 0 ? newSsolPool / finalTokenPool : coinData.current_price;

                    const newAllTimeHigh = Math.max(coinDataAfterBot.all_time_high || 0, newPrice);
                    const newAllTimeLow = Math.min(coinDataAfterBot.all_time_low || 999999, newPrice);
                    const newMarketCap = newPrice * (finalTokenPool + coinDataAfterBot.bot_token_pool);
                    const currentPriceHistory = Array.isArray(coinDataAfterBot.price_history) ? coinDataAfterBot.price_history : [];
                    const newHistory = [...currentPriceHistory, newPrice].slice(-50);
                    const currentVolumeHistory = Array.isArray(coinDataAfterBot.volume_history) ? coinDataAfterBot.volume_history : [];
                    const newVolumeHistory = [...currentVolumeHistory, ssolTraded].slice(-50);

                    const newVolume = coinDataAfterBot.volume + ssolTraded;
                    const newCreatorFeesToken = (coinDataAfterBot.creator_fees_token || 0) + totalFee; // Sumar fee en tokens

                    let newHolderCount = coinDataAfterBot.holder_count;
                    let holderChange = 0;
                    const currentTokens = walletData.amount;
                    const newAmountInWallet = currentTokens - tokensToSell;
                    if (newAmountInWallet < 0.00000001 && currentTokens >= 0.00000001) {
                        newHolderCount--;
                        holderChange = -1;
                    }
                    const newLastHolderCountChange = (coinDataAfterBot.last_holder_count_change || 0) + holderChange;

                    const currentTradeHistory = walletData.trade_history || [];
                     // Guardar precio AL QUE SE EJECUTÓ (newPrice)
                    const updatedTradeHistory = [...currentTradeHistory, {
                        type: 'sell', price: newPrice, amountSsol: ssolReceived, amountToken: tokensToSell, coinId: selectedCoinId, timestamp: new Date().toISOString()
                    }].slice(-50);

                    // --- Actualizar tablas (secuencialmente) ---
                    // 1. Actualizar balance jugador (Usar RPC)
                    const { error: playerUpdateError } = await supabaseClient.rpc('increment_balance', { user_uuid: currentUserId, amount: ssolReceived });
                    // const { error: playerUpdateError } = await supabaseClient.from('players').update({ s_sol_balance: playerDataDB.s_sol_balance + ssolReceived }).eq('user_id', currentUserId); // Fallback
                    if (playerUpdateError) throw new Error(`Error player update: ${playerUpdateError.message}`);
                     // currentUserData.s_sol_balance += ssolReceived; // Realtime lo hará

                    // 2. Actualizar wallet (Usar RPC)
                    const { error: walletUpdateError } = await supabaseClient.rpc('increment_wallet_amount', { p_user_id: currentUserId, p_coin_id: selectedCoinId, p_amount: -tokensToSell });
                     // const { error: walletUpdateError } = await supabaseClient.from('wallets').update({ amount: newAmountInWallet, trade_history: updatedTradeHistory }).eq('user_id', currentUserId).eq('coin_id', selectedCoinId); // Fallback
                    if (walletUpdateError) {
                        // Revertir balance (mejor esfuerzo)
                        await supabaseClient.rpc('increment_balance', { user_uuid: currentUserId, amount: -ssolReceived });
                        throw new Error(`Error wallet update: ${walletUpdateError.message}`);
                    }
                     // Actualizar historial por separado si se usó RPC de incremento
                     const { error: historyUpdateError } = await supabaseClient.from('wallets').update({trade_history: updatedTradeHistory}).eq('user_id', currentUserId).eq('coin_id', selectedCoinId);
                     if(historyUpdateError) console.warn("Fallback Sell: Failed to update trade history:", historyUpdateError.message);


                    // 3. Actualizar seguidores creador (si aplica)
                    if (botCreatorFollows > 0) {
                        const { error: followError } = await supabaseClient.rpc('increment_followers', { user_uuid: coinData.creator_id, amount: botCreatorFollows });
                         if(followError) console.warn("Fallback Sell: Failed to increment creator followers:", followError.message);
                    }
                    delete botUpdates.creatorFollowsIncrement;

                    // 4. Actualizar moneda
                    const { error: coinUpdateError } = await supabaseClient.from('coins').update({
                        ...botUpdates,
                        s_sol_pool: newSsolPool, token_pool: finalTokenPool,
                        current_price: newPrice, price_history: newHistory,
                        volume: newVolume, volume_history: newVolumeHistory,
                        market_cap: newMarketCap, holder_count: newHolderCount,
                        last_holder_count_change: newLastHolderCountChange,
                         // creator_fees_ssol se suma en compra
                        creator_fees_token: newCreatorFeesToken, // Sumar aquí
                        all_time_high: newAllTimeHigh, all_time_low: newAllTimeLow
                    }).eq('id', selectedCoinId);
                     if (coinUpdateError) {
                         // Revertir es complejo aquí... loggear el error
                         console.error("Error crítico al actualizar moneda post-venta:", coinUpdateError);
                         showMessage("Venta registrada, pero error al actualizar estado de la moneda.");
                     } else {
                        showMessage(`¡Vendiste ${formatNumber(tokensToSell, 4)} ${coinData.symbol} por ${formatNumber(ssolReceived, 4)} sSOL!`);
                    }

                    sellAmountEl.value = '';

                } catch (error) {
                    console.error("Error al vender:", error);
                    showMessage(`Error al vender: ${error.message}`);
                } finally {
                     sellAmountEl.disabled = false;
                     sellButton.disabled = false;
                     sellButton.textContent = 'Vender';
                }
            });

            // Botones % venta (sin cambios)
            document.querySelectorAll('.sell-percent-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const percent = parseFloat(btn.dataset.percent);
                    const walletItem = myPortfolioCache.get(selectedCoinId); // Usa caché del portfolio
                    if (walletItem) {
                         // CORRECCIÓN: Calcular con 2 decimales para evitar errores de precisión
                        const amountToSell = parseFloat((walletItem.amount * percent).toFixed(2));
                        sellAmountEl.value = amountToSell;
                    } else {
                        showMessage("No tienes esta moneda.");
                        sellAmountEl.value = '0';
                    }
                });
            });


            // --- OTRAS FUNCIONES (P2P, Panel Creador, Tienda, Social, Chat, PnL) ---
            // Adaptar a Supabase (update, insert, rpc, select, nombres SQL)

            // Enviar sSOL (Requiere RPC para atomicidad ideal, fallback secuencial)
             sendSsolFormEl.addEventListener('submit', async (e) => {
                 e.preventDefault();
                 const amountToSend = parseFloat(sendSsolAmountEl.value);
                 if (!targetPlayerId || isNaN(amountToSend) || amountToSend <= 0) return showMessage("Monto inválido.");
                  if (!currentUserData || currentUserData.s_sol_balance < amountToSend) return showMessage("sSOL insuficiente.");

                 const sendButton = sendSsolFormEl.querySelector('button[type="submit"]');
                 sendButton.disabled = true; sendButton.textContent = 'Enviando...';

                 try {
                     // Lógica secuencial (NO ATÓMICA) usando RPC para incrementos
                     // 1. Restar al emisor
                     const { error: sendError } = await supabaseClient.rpc('increment_balance', { user_uuid: currentUserId, amount: -amountToSend });
                     if (sendError) throw new Error(`Error al enviar: ${sendError.message}`);
                     // currentUserData.s_sol_balance -= amountToSend; // Realtime lo hará

                     // 2. Sumar al receptor
                     const { error: receiveError } = await supabaseClient.rpc('increment_balance', { user_uuid: targetPlayerId, amount: amountToSend });

                     if (receiveError) {
                         // Intentar revertir el envío (mejor esfuerzo)
                         await supabaseClient.rpc('increment_balance', { user_uuid: currentUserId, amount: amountToSend });
                         throw new Error(`Error al recibir: ${receiveError.message}`);
                     }

                     showMessage(`¡Enviaste ${formatNumber(amountToSend)} sSOL a ${allPlayersCache.get(targetPlayerId)?.username || '...'}!`);
                     hideModal(sendSsolModalEl);
                     sendSsolFormEl.reset();

                 } catch (error) {
                     console.error("Error al enviar sSOL:", error);
                     showMessage(error.message);
                 } finally {
                     sendButton.disabled = false; sendButton.textContent = 'Confirmar Envío';
                 }
             });
             // Crear función RPC 'increment_balance' en Supabase SQL Editor:
             /*
                CREATE OR REPLACE FUNCTION increment_balance(user_uuid uuid, amount float8)
                RETURNS void AS $$
                  UPDATE public.players
                  SET s_sol_balance = s_sol_balance + amount
                  WHERE user_id = user_uuid;
                $$ LANGUAGE sql VOLATILE;
             */


            // showCreatorDashboard (leer caché allCoinsCache) - OK
             function showCreatorDashboard() {
                 creatorCoinsListEl.innerHTML = '';
                 let hasCoins = false;

                 const myCoins = Array.from(allCoinsCache.values())
                     .filter(coin => coin.creator_id === currentUserId) // SQL: creator_id
                     .sort((a, b) => (new Date(b.created_at) || 0) - (new Date(a.created_at) || 0)); // SQL: created_at

                 myCoins.forEach(coin => {
                     hasCoins = true;
                     const itemEl = document.createElement('div');
                     itemEl.className = 'bg-item-hover p-3 rounded-lg';
                     itemEl.innerHTML = `
                         <div class="flex justify-between items-center mb-3">
                             <span class="font-semibold text-lg">${coin.name} (${coin.symbol})</span>
                             <button data-coin-id="${coin.id}" class="go-live-btn ${coin.is_live ? 'bg-gray-600' : 'bg-red-600 hover:bg-red-700'} text-white font-bold py-2 px-3 rounded-md text-sm transition">
                                 ${coin.is_live ? 'EN VIVO' : 'Ir en Vivo'}
                             </button>
                         </div>
                         <div class="bg-gray-700/50 p-3 rounded-lg">
                             <h4 class="font-semibold mb-2">Comisiones Ganadas (Totales: 0.3%)</h4>
                             <div class="text-sm text-gray-300">sSOL: <span id="fee-ssol-${coin.id}">${formatNumber(coin.creator_fees_ssol, 6)}</span></div>
                             <div class="text-sm text-gray-300">${coin.symbol}: <span id="fee-token-${coin.id}">${formatNumber(coin.creator_fees_token, 2)}</span></div>
                             <button data-coin-id="${coin.id}" class="claim-fee-btn w-full mt-2 bg-solana-green text-gray-900 font-bold py-2 px-3 rounded-md text-sm hover:bg-opacity-80 transition">Reclamar</button>
                         </div>
                     `;
                     creatorCoinsListEl.appendChild(itemEl);
                 });

                 if (!hasCoins) creatorCoinsListEl.innerHTML = '<p class="text-gray-400 text-center">No has creado ninguna moneda.</p>';

                 creatorCoinsListEl.querySelectorAll('.claim-fee-btn').forEach(btn => btn.addEventListener('click', (e) => claimFees(e.target.dataset.coinId, e.target)));
                 creatorCoinsListEl.querySelectorAll('.go-live-btn').forEach(btn => btn.addEventListener('click', (e) => toggleLive(e.target.dataset.coinId, e.target)));

                 showModal(creatorDashboardModalEl);
             }


            // claimFees (Requiere RPC idealmente, fallback secuencial NO ATÓMICO)
            async function claimFees(coinId, btn) {
                 const coin = allCoinsCache.get(coinId);
                 if (!coin || (coin.creator_fees_ssol < 0.00000001 && coin.creator_fees_token < 0.00000001)) return showMessage("No hay comisiones que reclamar.");

                 btn.disabled = true; btn.textContent = '...';
                 const ssolToClaim = coin.creator_fees_ssol;
                 const tokensToClaim = coin.creator_fees_token;

                 try {
                     // Lógica secuencial NO ATÓMICA usando RPCs para incrementos
                     // 1. Resetear fees en la moneda
                     const { error: resetError } = await supabaseClient.from('coins').update({ creator_fees_ssol: 0, creator_fees_token: 0 }).eq('id', coinId);
                     if (resetError) throw new Error(`Error reset fees: ${resetError.message}`);

                     // 2. Incrementar balance sSOL del jugador
                     const { error: ssolError } = await supabaseClient.rpc('increment_balance', { user_uuid: currentUserId, amount: ssolToClaim });
                     if (ssolError) {
                         // Intentar revertir reset (mejor esfuerzo)
                         await supabaseClient.from('coins').update({ creator_fees_ssol: ssolToClaim, creator_fees_token: tokensToClaim }).eq('id', coinId);
                         throw new Error(`Error claim sSOL: ${ssolError.message}`);
                     }
                      // currentUserData.s_sol_balance += ssolToClaim; // Realtime lo hará


                     // 3. Incrementar/Crear balance de tokens en wallet
                     if (tokensToClaim > 0) {
                          // Usar RPC para upsert/increment seguro
                         const { error: tokenError } = await supabaseClient.rpc('increment_wallet_amount', { p_user_id: currentUserId, p_coin_id: coinId, p_amount: tokensToClaim });
                         if (tokenError) {
                             // Intentar revertir sSOL y reset (complejo)
                             console.error("Error crítico al reclamar tokens:", tokenError);
                             showMessage("Error al añadir tokens a tu wallet. sSOL reclamado.");
                             // No lanzar error aquí para que al menos sSOL se reclame
                         }
                         // Actualizar caché local del portfolio si existe
                         const walletItem = myPortfolioCache.get(coinId);
                         if (walletItem) walletItem.amount += tokensToClaim;

                     }

                     showMessage("¡Comisiones reclamadas!");
                     btn.textContent = "Reclamado";
                     // Actualizar UI en panel creador (o confiar en realtime)
                     document.getElementById(`fee-ssol-${coinId}`).textContent = formatNumber(0, 6);
                     document.getElementById(`fee-token-${coinId}`).textContent = formatNumber(0, 2);

                 } catch (e) {
                     showMessage(e.message);
                     btn.disabled = false; btn.textContent = "Reclamar";
                 }
             }
             // Crear función RPC 'increment_wallet_amount' en Supabase SQL Editor:
             /*
                CREATE OR REPLACE FUNCTION increment_wallet_amount(p_user_id uuid, p_coin_id uuid, p_amount float8)
                RETURNS void AS $$
                BEGIN
                  INSERT INTO public.wallets (user_id, coin_id, amount)
                  VALUES (p_user_id, p_coin_id, p_amount)
                  ON CONFLICT (user_id, coin_id)
                  DO UPDATE SET amount = wallets.amount + p_amount;
                END;
                $$ LANGUAGE plpgsql VOLATILE;
             */

            // toggleLive (update simple) - OK
             async function toggleLive(coinId, btn) {
                 const coin = allCoinsCache.get(coinId);
                  if (!coin) return; // Chequeo por si acaso
                 const newState = !coin.is_live; // SQL: is_live
                 btn.disabled = true; btn.textContent = '...';

                 try {
                     const initialViewers = newState ? 50 + Math.floor(Math.random() * 50) : 0;
                     const initialFollowers = newState ? (coin.followers || 0) + 5 + Math.floor(Math.random() * 10) : coin.followers;

                     const { error } = await supabaseClient
                         .from('coins')
                         .update({ is_live: newState, live_viewers: initialViewers, followers: initialFollowers })
                         .eq('id', coinId)
                         .eq('creator_id', currentUserId); // Asegurar que solo el creador lo cambie

                     if (error) throw error;

                     showMessage(newState ? "¡Estás en vivo!" : "Directo finalizado.");
                     // Estado se actualizará por realtime, pero actualizamos botón manualmente
                     btn.textContent = newState ? "EN VIVO" : "Ir en Vivo";
                     btn.classList.toggle('bg-gray-600', newState); btn.classList.toggle('bg-red-600', !newState);

                 } catch (e) {
                     showMessage(`Error al cambiar estado live: ${e.message}`);
                 } finally {
                    btn.disabled = false;
                 }
             }

            // showLiveStream (usa caché, no necesita cambios directos) - OK
            function showLiveStream() {
                if (!selectedCoinId) return;
                const coin = allCoinsCache.get(selectedCoinId);
                if (!coin) return;
                liveCoinNameEl.textContent = `LIVE: ${coin.name}`;
                liveViewersEl.textContent = formatNumber(coin.live_viewers || 0, 0); // SQL: live_viewers
                showModal(liveStreamModalEl);

                // No necesitamos un onSnapshot aquí, el listener de 'all-coins' actualizará el caché
            }
            // boostLiveStream (Requiere RPC idealmente, fallback secuencial NO ATÓMICO)
            async function boostLiveStream(level) {
                 if (!selectedCoinId) return;
                 let boostCost = 0, viewerBonus = 0, followerBonus = 0;
                 switch (level) {
                     case 'small':  boostCost = 0.1; viewerBonus = 100 + Math.floor(Math.random() * 100); followerBonus = 10 + Math.floor(Math.random() * 20); break;
                     case 'medium': boostCost = 1;   viewerBonus = 500 + Math.floor(Math.random() * 500); followerBonus = 50 + Math.floor(Math.random() * 50); break;
                     case 'large':  boostCost = 10;  viewerBonus = 2000 + Math.floor(Math.random() * 3000); followerBonus = 200 + Math.floor(Math.random() * 300); break;
                     default: return showMessage("Nivel de boost inválido.");
                 }

                 if (!currentUserData || currentUserData.s_sol_balance < boostCost) return showMessage("sSOL insuficiente.");

                 const btn = document.querySelector(`.boost-live-btn[data-boost-level="${level}"]`);
                 if (btn) { btn.disabled = true; btn.textContent = '...'; }

                 try {
                     // Lógica secuencial (NO ATÓMICA) usando RPCs para incrementos
                     // 1. Descontar balance
                     const { error: balanceError } = await supabaseClient.rpc('increment_balance', { user_uuid: currentUserId, amount: -boostCost });
                     if (balanceError) throw new Error(`Error balance update: ${balanceError.message}`);
                     // currentUserData.s_sol_balance -= boostCost; // Realtime lo hará

                     // 2. Incrementar viewers y followers en la moneda (usar RPC)
                      const { error: boostError } = await supabaseClient.rpc('boost_coin_stats', {
                          coin_uuid: selectedCoinId,
                          viewer_inc: viewerBonus,
                          follower_inc: followerBonus
                      });

                     if (boostError) {
                         // Revertir balance (mejor esfuerzo)
                          await supabaseClient.rpc('increment_balance', { user_uuid: currentUserId, amount: boostCost });
                         throw new Error(`Error boost update: ${boostError.message}`);
                     }

                     showMessage(`¡Boost (${level}) aplicado!`);
                 } catch (e) { showMessage(e.message); }
                 if (btn) { btn.disabled = false; btn.textContent = `Boost (${boostCost} sSOL)`; }
            }
             // Crear función RPC 'boost_coin_stats' en Supabase SQL Editor:
             /*
                 CREATE OR REPLACE FUNCTION boost_coin_stats(coin_uuid uuid, viewer_inc int, follower_inc int)
                 RETURNS void AS $$
                   UPDATE public.coins
                   SET live_viewers = live_viewers + viewer_inc,
                       followers = followers + follower_inc
                   WHERE id = coin_uuid AND is_live = true; -- Solo si está live
                 $$ LANGUAGE sql VOLATILE;
             */


            // Comprar Activos (Requiere RPC, fallback secuencial NO ATÓMICO)
            document.querySelectorAll('.buy-asset-btn').forEach(btn => {
                btn.addEventListener('click', async (e) => {
                    const target = e.currentTarget;
                    const item = target.dataset.item;
                    const cost = parseFloat(target.dataset.cost);
                    const category = target.dataset.category; // 'assets' o 'office'

                     if (!currentUserData || currentUserData.s_sol_balance < cost) return showMessage("sSOL insuficiente.");

                    target.disabled = true; target.textContent = '...';

                    try {
                         // Lógica secuencial (NO ATÓMICA)
                         // 1. Descontar balance (Usar RPC)
                        const { error: balanceError } = await supabaseClient.rpc('increment_balance', { user_uuid: currentUserId, amount: -cost });
                        if (balanceError) throw new Error(`Error balance update: ${balanceError.message}`);
                         // currentUserData.s_sol_balance -= cost; // Realtime lo hará

                         // 2. Actualizar assets/officeItems (requiere leer y luego escribir JSONB)
                         // Leer el valor actual desde DB para evitar race conditions con caché local
                         const { data: currentPlayerData, error: getPlayerError } = await supabaseClient.from('players').select('assets, office_items').eq('user_id', currentUserId).single();
                         if(getPlayerError) throw new Error(`Error fetching current assets: ${getPlayerError.message}`);

                        let currentAssets = currentPlayerData.assets || {};
                        let currentOfficeItems = currentPlayerData.office_items || {};
                        let updatePayload = {};

                        if (category === 'office') {
                            const emoji = target.dataset.emoji;
                            const pos = target.dataset.pos;
                            const currentItemData = currentOfficeItems[item] || { count: 0 };
                            currentOfficeItems[item] = {
                                count: currentItemData.count + 1,
                                emoji: emoji,
                                pos: pos
                            };
                            updatePayload = { office_items: currentOfficeItems };
                        } else {
                            currentAssets[item] = (currentAssets[item] || 0) + 1;
                            updatePayload = { assets: currentAssets };
                        }

                        const { error: assetError } = await supabaseClient.from('players').update(updatePayload).eq('user_id', currentUserId);

                        if (assetError) {
                            // Revertir balance (mejor esfuerzo)
                             await supabaseClient.rpc('increment_balance', { user_uuid: currentUserId, amount: cost });
                            throw new Error(`Error asset update: ${assetError.message}`);
                        }
                         // Actualizar caché local de assets (Realtime lo hará, pero podemos forzar)
                         // currentUserData.assets = currentAssets;
                         // currentUserData.office_items = currentOfficeItems;


                        showMessage(`¡Felicidades! ¡Compraste un ${item}!`);
                    } catch (e) { showMessage(e.message); }
                    target.disabled = false; target.textContent = 'Comprar';
                });
            });


            // editSocialProfileFormEl (update simple) - OK
            editSocialProfileFormEl.addEventListener('submit', async (e) => {
                 e.preventDefault();
                 const username = socialUsernameInputEl.value.trim();
                 const avatarUrl = socialAvatarInputEl.value.trim();
                 if (!username) return showMessage("El nombre de usuario no puede estar vacío.");
                 const editButton = editSocialProfileFormEl.querySelector('button[type="submit"]');
                 editButton.disabled = true;

                 try {
                     const { error } = await supabaseClient
                         .from('players')
                         .update({
                             username: username,
                             avatar_url: avatarUrl || `https://placehold.co/60/374151/FFFFFF?text=${username.slice(0,1)}`
                         })
                         .eq('user_id', currentUserId);

                     if (error) throw error;

                     showMessage("Perfil actualizado.");
                     hideModal(myProfileModalEl);
                      // Actualizar caché local (Realtime también lo hará)
                     if(currentUserData) {
                        currentUserData.username = username;
                        currentUserData.avatar_url = avatarUrl;
                     }

                 } catch (error) { showMessage(`Error al actualizar perfil: ${error.message}`); }
                 finally { editButton.disabled = false; }
            });

            // createSocialPostFormEl (insert simple) - OK
             createSocialPostFormEl.addEventListener('submit', async (e) => {
                 e.preventDefault();
                 const postText = socialPostTextEl.value.trim();
                 if (!postText) return showMessage("El post no puede estar vacío.");

                 const postButton = createSocialPostFormEl.querySelector('button[type="submit"]');
                 postButton.disabled = true;

                 try {
                     const player = currentUserData; // Usar caché local
                      if(!player) throw new Error("Datos del jugador no disponibles."); // Chequeo extra
                     const { error } = await supabaseClient
                         .from('social_posts')
                         .insert({
                             user_id: currentUserId,
                             username: player.username, // Guardar denormalizado
                             avatar_url: player.avatar_url, // Guardar denormalizado
                             text: postText,
                             // created_at es default now()
                         });

                     if (error) throw error;

                     showMessage("Post publicado.");
                     hideModal(createSocialPostModalEl);
                     createSocialPostFormEl.reset();
                     showPage('page-social'); // Ir al feed
                 } catch (error) { showMessage(`Error al publicar post: ${error.message}`); }
                 finally { postButton.disabled = false; }
             });


            // promotePost (Requiere RPC, fallback secuencial NO ATÓMICO)
             async function promotePost(postId, btn) {
                  if (!currentUserData || currentUserData.s_sol_balance < PROMO_POST_COST) return showMessage(`sSOL insuficiente. Necesitas ${PROMO_POST_COST}.`);

                 btn.disabled = true; btn.textContent = '...';
                 try {
                      // Lógica secuencial NO ATÓMICA usando RPCs
                     // 1. Descontar balance
                    const { error: balanceError } = await supabaseClient.rpc('increment_balance', { user_uuid: currentUserId, amount: -PROMO_POST_COST });
                    if (balanceError) throw new Error(`Error balance update: ${balanceError.message}`);
                     // currentUserData.s_sol_balance -= PROMO_POST_COST; // Realtime lo hará

                     // 2. Actualizar post
                     const { error: postError } = await supabaseClient.from('social_posts').update({ boosted: true }).eq('id', postId).eq('user_id', currentUserId); // Asegurar que solo el dueño lo boostee

                     if (postError) {
                         // Revertir balance (mejor esfuerzo)
                         await supabaseClient.rpc('increment_balance', { user_uuid: currentUserId, amount: PROMO_POST_COST });
                         throw new Error(`Error post update: ${postError.message}`);
                     }

                     showMessage("¡Post promocionado!");
                     // La UI se actualizará con el listener de feed
                 } catch (e) {
                     showMessage(e.message);
                     // No re-habilitar aquí, si falla se queda deshabilitado hasta recarga de feed
                     // btn.disabled = false; btn.textContent = `Promocionar (0.2 sSOL)`;
                 }
                 // No poner 'finally' aquí, el botón se deshabilita/cambia en la UI por realtime
             }


            // showPlayerProfile (usa caché, carga posts/coins con select) - OK
             async function showPlayerProfile(playerId) {
                 if (playerId === currentUserId) {
                     showMyProfileBtn.click(); // Asegura que carga mis posts
                     return;
                 }

                 selectedProfilePlayerId = playerId;
                 const player = allPlayersCache.get(playerId);
                 if (!player) return showMessage("No se encontró al jugador.");

                 playerProfileUsernameEl.textContent = player.username;
                 playerProfileAvatarEl.src = player.avatar_url || 'https://placehold.co/60/374151/FFFFFF?text=P';
                 playerProfileFollowersEl.textContent = formatNumber(player.social_followers || 0, 0);

                 updateFollowButton(); // Usa myFollowsCache

                 playerProfilePostsEl.innerHTML = '<p class="text-gray-400 text-sm">Cargando posts...</p>';
                 playerProfileCoinsEl.innerHTML = '<p class="text-gray-400 text-sm">Cargando monedas...</p>';
                 showModal(playerProfileModalEl);

                 // Cargar posts del jugador
                 const { data: posts, error: postsError } = await supabaseClient
                     .from('social_posts')
                     .select('*')
                     .eq('user_id', playerId)
                     .order('created_at', { ascending: false })
                     .limit(10);

                 if (postsError) {
                      playerProfilePostsEl.innerHTML = '<p class="text-red-500 text-sm">Error al cargar posts.</p>';
                 } else if (!posts || posts.length === 0) {
                      playerProfilePostsEl.innerHTML = '<p class="text-gray-400 text-sm">Este jugador no tiene posts.</p>';
                 } else {
                     playerProfilePostsEl.innerHTML = '';
                     posts.forEach(post => {
                         const postEl = document.createElement('div');
                         postEl.className = 'bg-item-hover p-3 rounded-lg text-sm';
                         postEl.innerHTML = `
                             <p>${post.text}</p>
                             <p class="text-xs text-gray-500 mt-2">${new Date(post.created_at).toLocaleString()}</p>
                         `;
                         playerProfilePostsEl.appendChild(postEl);
                     });
                 }


                 // Cargar monedas creadas
                 const { data: coins, error: coinsError } = await supabaseClient
                     .from('coins')
                     .select('id, name, symbol, image_url') // Solo lo necesario
                     .eq('creator_id', playerId)
                     .order('created_at', { ascending: false });

                 if (coinsError) {
                      playerProfileCoinsEl.innerHTML = '<p class="text-red-500 text-sm">Error al cargar monedas.</p>';
                 } else if (!coins || coins.length === 0) {
                      playerProfileCoinsEl.innerHTML = '<p class="text-gray-400 text-sm">Este jugador no ha creado monedas.</p>';
                 } else {
                     playerProfileCoinsEl.innerHTML = '';
                     coins.forEach(coin => {
                         const coinEl = document.createElement('div');
                         coinEl.className = 'bg-item-hover p-2 rounded-lg text-sm flex items-center gap-2';
                         coinEl.innerHTML = `
                             <img src="${coin.image_url || 'https://placehold.co/24/718096/FFFFFF?text=' + coin.symbol}" alt="${coin.symbol}" class="w-6 h-6 rounded-full">
                             <span>${coin.name} (${coin.symbol})</span>
                         `;
                         playerProfileCoinsEl.appendChild(coinEl);
                     });
                 }
             }

            // updateFollowButton (usa caché myFollowsCache) - OK
             function updateFollowButton() {
                 if (!selectedProfilePlayerId) return; // Añadir chequeo
                 if (myFollowsCache.has(selectedProfilePlayerId)) {
                     followPlayerBtn.textContent = "Dejar de Seguir";
                     followPlayerBtn.classList.remove('bg-x-blue', 'hover:bg-opacity-80');
                     followPlayerBtn.classList.add('bg-gray-600', 'hover:bg-gray-700');
                 } else {
                     followPlayerBtn.textContent = "Seguir";
                     followPlayerBtn.classList.add('bg-x-blue', 'hover:bg-opacity-80');
                     followPlayerBtn.classList.remove('bg-gray-600', 'hover:bg-gray-700');
                 }
                 followPlayerBtn.disabled = false; // Asegurar que esté habilitado
             }

            // followPlayerBtn (Requiere RPC para atomicidad, fallback secuencial NO ATÓMICO)
             followPlayerBtn.addEventListener('click', async () => {
                 if (!selectedProfilePlayerId) return;

                 followPlayerBtn.disabled = true;
                 const isFollowing = myFollowsCache.has(selectedProfilePlayerId);
                 const action = isFollowing ? 'unfollow' : 'follow';
                 const followerIncrement = isFollowing ? -1 : 1;

                 try {
                     // Lógica secuencial (NO ATÓMICA) usando RPCs
                     // 1. Actualizar MI lista 'following'
                     let currentFollows = Array.from(myFollowsCache);
                     if (isFollowing) {
                         currentFollows = currentFollows.filter(id => id !== selectedProfilePlayerId);
                     } else {
                         // Evitar duplicados si hay race condition
                         if (!currentFollows.includes(selectedProfilePlayerId)) {
                            currentFollows.push(selectedProfilePlayerId);
                         }
                     }
                     const { error: myUpdateError } = await supabaseClient.from('players').update({ following: currentFollows }).eq('user_id', currentUserId);
                     if (myUpdateError) throw new Error(`Error my update: ${myUpdateError.message}`);

                     // 2. Actualizar los followers del OTRO jugador (usar RPC)
                     const { error: targetUpdateError } = await supabaseClient.rpc('increment_followers', { user_uuid: selectedProfilePlayerId, amount: followerIncrement });

                     if (targetUpdateError) {
                         // Revertir mi lista 'following' (mejor esfuerzo)
                         if (isFollowing) currentFollows.push(selectedProfilePlayerId);
                         else currentFollows = currentFollows.filter(id => id !== selectedProfilePlayerId);
                         await supabaseClient.from('players').update({ following: currentFollows }).eq('user_id', currentUserId);
                         throw new Error(`Error target update: ${targetUpdateError.message}`);
                     }

                     // Actualizar caché local y UI si todo ok (Realtime lo hará también)
                     if (isFollowing) myFollowsCache.delete(selectedProfilePlayerId);
                     else myFollowsCache.add(selectedProfilePlayerId);

                     updateFollowButton(); // Actualiza el texto/estilo del botón

                     // Actualizar contador en el perfil abierto (si es el correcto)
                      const targetPlayer = allPlayersCache.get(selectedProfilePlayerId);
                      if (targetPlayer) {
                         // Actualizar caché local del jugador objetivo
                         targetPlayer.social_followers = (targetPlayer.social_followers || 0) + followerIncrement;
                          if (playerProfileFollowersEl) { // Verificar si el elemento existe
                            playerProfileFollowersEl.textContent = formatNumber(targetPlayer.social_followers, 0);
                          }
                      }


                 } catch (e) {
                     showMessage("Error al seguir/dejar de seguir: " + e.message);
                     updateFollowButton(); // Reintentar actualizar estado del botón en caso de error
                 }
                 // followPlayerBtn.disabled = false; // updateFollowButton lo maneja
             });


            // launchSocialFiCoinBtn (usa caché) - OK
             launchSocialFiCoinBtn.addEventListener('click', () => {
                 const player = currentUserData; // Usar caché local
                 if (player && (player.social_followers || 0) >= 50) {
                     coinNameEl.value = `${player.username || 'Mi'} Coin`;
                     coinSymbolEl.value = (player.username || 'ME').slice(0,5).toUpperCase();
                     coinImageUrlEl.value = player.avatar_url || '';
                     hideModal(myProfileModalEl);
                     showModal(createCoinModalEl);
                 } else {
                     showMessage("Necesitas al menos 50 seguidores.");
                 }
             });

            // --- LÓGICA DE CHAT (SUPABASE REALTIME) ---
            function subscribeToChatMessages() {
                 if (chatListener && chatListener.state === 'joined') return; // Ya suscrito y unido

                 console.log("Subscribing to chat messages...");
                 chatMessagesEl.innerHTML = '<p class="text-gray-400 text-center text-sm">Cargando mensajes...</p>';

                 // Carga inicial
                 async function loadInitialChat() {
                    const { data, error } = await supabaseClient
                        .from('chat_messages')
                        .select('*')
                        .order('timestamp', { ascending: true }) // Cargar en orden correcto
                        .limit(50); // Últimos 50

                    if (error) {
                        console.error("Error loading initial chat:", error);
                        chatMessagesEl.innerHTML = '<p class="text-red-500 text-center text-sm">Error al cargar chat.</p>';
                        return;
                    }
                    renderChatMessages(data);
                 }
                 loadInitialChat();

                 // Suscripción a nuevos mensajes
                 const channelName = 'chat-room';
                  // Quitar canal anterior si existe
                 const existing = supabaseClient.channel(channelName);
                 if (existing) {
                     supabaseClient.removeChannel(existing);
                     realtimeChannels = realtimeChannels.filter(ch => ch.topic !== existing.topic);
                 }

                 const channel = supabaseClient.channel(channelName);
                 chatListener = channel; // Guardar referencia para desuscribir
                 channel
                     .on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'chat_messages' }, payload => {
                         console.log('New chat message:', payload.new);
                         appendChatMessage(payload.new); // Añadir solo el nuevo mensaje
                     })
                     .subscribe((status, err) => {
                         if (status === 'SUBSCRIBED') console.log('Subscribed to chat');
                         else if (status === 'CHANNEL_ERROR' || status === 'TIMED_OUT' || status === 'CLOSED') {
                            console.error('Chat subscription error/closed:', status, err);
                            chatListener = null; // Resetear para permitir re-suscripción
                         }
                     });
                 realtimeChannels.push(channel); // Añadir a la lista para limpiar
            }

            // Renderiza la lista completa de mensajes
             function renderChatMessages(messages) {
                 chatMessagesEl.innerHTML = '';
                 if (!messages || messages.length === 0) {
                     chatMessagesEl.innerHTML = '<p class="text-gray-400 text-center text-sm">Aún no hay mensajes.</p>';
                     return;
                 }
                 messages.forEach(msg => appendChatMessage(msg, false)); // Añadir sin scroll individual
                 // Scroll al final DESPUÉS de que se rendericen los elementos
                 setTimeout(() => {
                    chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight;
                 }, 0);
             }

            // Añade un solo mensaje al DOM
            function appendChatMessage(msg, shouldScroll = true) {
                // Usar datos denormalizados si existen, o buscar en caché
                const username = msg.username || allPlayersCache.get(msg.user_id)?.username || 'Jugador';
                const avatarUrl = msg.avatar_url || allPlayersCache.get(msg.user_id)?.avatar_url || 'https://placehold.co/32/374151/FFFFFF?text=P';
                const isMe = msg.user_id === currentUserId;

                // Evitar añadir duplicados si realtime dispara muy rápido
                if (document.getElementById(`msg-${msg.id}`)) return;

                const msgEl = document.createElement('div');
                msgEl.id = `msg-${msg.id}`; // Añadir ID para evitar duplicados
                msgEl.className = `flex gap-2 ${isMe ? 'flex-row-reverse' : ''}`;
                msgEl.innerHTML = `
                    <img src="${avatarUrl}" alt="avatar" class="w-8 h-8 rounded-full ${isMe ? 'hidden sm:block' : ''}"> <!-- Mostrar mi avatar en pantallas grandes -->
                    <div class="flex-grow ${isMe ? 'text-right' : ''}">
                        <span class="text-xs font-semibold ${isMe ? 'text-solana-green' : 'text-solana-purple'}">${username}</span>
                        <div class="bg-item-hover p-3 rounded-lg ${isMe ? 'bg-solana-purple/50' : ''} inline-block max-w-[80%] sm:max-w-xs text-left break-words"> <!-- Estilos para burbuja y word wrap -->
                            <p class="text-sm text-white">${msg.text}</p>
                             <p class="text-xs text-gray-500 mt-1">${timeAgo(msg.timestamp)}</p> <!-- Añadir timestamp -->
                        </div>
                    </div>
                `;
                 // Insertar al final
                chatMessagesEl.appendChild(msgEl);


                // Auto-scroll al fondo si es un mensaje nuevo y estamos cerca del final
                 if (shouldScroll) {
                    const isScrolledToBottom = chatMessagesEl.scrollHeight - chatMessagesEl.clientHeight <= chatMessagesEl.scrollTop + 50; // Tolerancia de 50px
                    if(isScrolledToBottom) {
                        chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight;
                    }
                }
            }

            // Enviar mensaje de chat (insert simple) - OK
            chatFormEl.addEventListener('submit', async (e) => {
                 e.preventDefault();
                 const text = chatInputEl.value.trim();
                 if (!text || !currentUserData) return; // Asegurar que currentUserData esté cargado

                 chatInputEl.disabled = true; // Deshabilitar mientras envía
                 const sendButton = chatFormEl.querySelector('button[type="submit"]');
                 sendButton.disabled = true;

                 try {
                     const { error } = await supabaseClient
                         .from('chat_messages')
                         .insert({
                             user_id: currentUserId,
                             text: text,
                             username: currentUserData.username, // Denormalizar
                             avatar_url: currentUserData.avatar_url // Denormalizar
                             // timestamp es default now()
                         });

                     if (error) throw error;
                     chatInputEl.value = ''; // Limpiar input solo si tuvo éxito

                 } catch (error) {
                     console.error("Error al enviar mensaje:", error);
                     showMessage("No se pudo enviar tu mensaje.");
                 } finally {
                    chatInputEl.disabled = false;
                    sendButton.disabled = false;
                    chatInputEl.focus(); // Devolver foco al input
                 }
             });

            // --- LÓGICA DE PNL (adaptada a Supabase wallet) ---
             async function showPnlModal() {
                 if (!selectedCoinId) return showMessage("Selecciona una moneda primero.");

                 const coin = allCoinsCache.get(selectedCoinId);
                 if (!coin) return showMessage("Datos de la moneda no encontrados."); // Chequeo adicional

                 const { data: walletData, error } = await supabaseClient
                     .from('wallets')
                     .select('amount, trade_history')
                     .eq('user_id', currentUserId)
                     .eq('coin_id', selectedCoinId)
                     .single();

                 if (error && error.code !== 'PGRST116') { // Ignorar 'not found'
                     return showMessage("Error al leer tu billetera: " + error.message);
                 }
                  // Si no hay walletData O no hay historial, calcular PNL como 0 o basado solo en tenencia actual si la hay
                 const tradeHistory = walletData?.trade_history || [];
                 const currentTokens = walletData?.amount || 0;

                 let totalSsolInvested = 0;
                 let totalSsolRealized = 0;
                 let totalTokensBought = 0;
                 // let totalTokensSold = 0; // No se usa directamente en el cálculo final

                 tradeHistory.forEach(trade => {
                     // Asegurarse de que los montos sean números válidos
                     const amountSsol = parseFloat(trade.amountSsol) || 0;
                     const amountToken = parseFloat(trade.amountToken) || 0;

                     if (trade.type === 'buy') {
                         totalSsolInvested += amountSsol;
                         totalTokensBought += amountToken;
                     } else if (trade.type === 'sell') {
                         totalSsolRealized += amountSsol;
                         // totalTokensSold += amountToken;
                     }
                 });

                 const avgBuyPrice = totalTokensBought > 0 ? totalSsolInvested / totalTokensBought : 0;
                 const currentValue = currentTokens * coin.current_price; // SQL: current_price

                 const totalPnL_sSOL = (totalSsolRealized + currentValue) - totalSsolInvested;
                 const totalPnL_Percent = totalSsolInvested > 0 ? (totalPnL_sSOL / totalSsolInvested) * 100 : 0;

                 pnlCoinSymbolEl.textContent = coin.symbol;
                 pnlTotalSsolEl.textContent = `${totalPnL_sSOL >= 0 ? '+' : ''}${formatNumber(totalPnL_sSOL, 4)} sSOL`;
                 pnlTotalPercentEl.textContent = `${totalPnL_Percent >= 0 ? '+' : ''}${formatNumber(totalPnL_Percent, 2)}%`;

                 pnlTotalSsolEl.className = `text-2xl font-semibold mb-6 ${totalPnL_sSOL >= 0 ? 'pnl-value-positive' : 'pnl-value-negative'}`;
                 pnlTotalPercentEl.className = `text-4xl font-bold mb-1 ${totalPnL_sSOL >= 0 ? 'pnl-value-positive' : 'pnl-value-negative'}`;

                 pnlTotalInvestedEl.textContent = formatNumber(totalSsolInvested, 4);
                 pnlTotalRealizedEl.textContent = formatNumber(totalSsolRealized, 4);
                 pnlCurrentValueEl.textContent = formatNumber(currentValue, 4);
                 pnlCurrentTokensEl.textContent = formatNumber(currentTokens, 4);
                 pnlAvgBuyPriceEl.textContent = formatPrice(avgBuyPrice);

                 showModal(pnlCardModalEl);
             }


            // --- INICIAR EL JUEGO ---
            initAuth(); // Inicia autenticación y luego joinGame
            initChart();
            // proactiveBotLoop se inicia al final de sí mismo con setTimeout
             setTimeout(proactiveBotLoop, 7000); // Dar un poco más de tiempo inicial
            showMessage("¡Bienvenido a la versión Supabase!"); // Mensaje inicial

        } // --- FIN: ENVOLTORIO MAIN ASYNC ---

        // Llamar a la función principal para iniciar todo
        main().catch(err => {
            console.error("Error fatal al iniciar la aplicación:", err);
             const messageModalEl = document.getElementById('message-modal');
            const messageTextEl = document.getElementById('message-text');
            if (messageTextEl && messageModalEl && typeof showModal === 'function') { // Check if showModal is defined
                messageTextEl.textContent = `Error fatal al iniciar: ${err.message}. Revisa la consola.`;
                showModal(messageModalEl); // Use showModal to display the error
            } else {
                 // Fallback if showModal isn't ready
                 alert(`Error fatal al iniciar: ${err.message}. Revisa la consola.`);
            }
        });

    </script>
</body>
</html>

