<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Solana Memecoin Simulator</title>
    <!-- Cargar Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Cargar Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Cargar anotaciones de Chart.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chartjs-plugin-annotation/3.0.1/chartjs-plugin-annotation.min.js"></script>
    <!-- Iconos Phosphor -->
    <script src="https://unpkg.com/@phosphor-icons/web"></script>
    <!-- Cargar Supabase Client -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <!-- Configuración de Tailwind -->
    <script>
        tailwind.config = {
             /* ... (sin cambios) ... */
             theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                    colors: {
                        'solana-green': '#14F195',
                        'solana-purple': '#9945FF',
                        'x-blue': '#1DA1F2', // Color de Twitter/X
                        'page-bg': '#111827', // gray-900
                        'item-bg': '#1F2937', // gray-800
                        'item-hover': '#374151', // gray-700
                    },
                    keyframes: { /* ... (sin cambios) ... */ },
                    animation: { /* ... (sin cambios) ... */ }
                }
            }
        }
    </script>
    <style>
         /* ... (estilos sin cambios) ... */
        /* Estilo para la barra de scroll */
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: #374151; }
        ::-webkit-scrollbar-thumb { background: #4a5568; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #718096; }

        .glassmorphism { background: rgba(31, 41, 55, 0.7); backdrop-filter: blur(10px); border: 1px solid rgba(55, 65, 81, 0.5); }
        .modal { transition: opacity 0.25s ease, visibility 0.25s ease; }
        .modal-content { transition: transform 0.25s ease; }
        .x-popover-container { position: relative; display: inline-block; }
        .x-popover { position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%) translateY(-10px); z-index: 100; opacity: 0; visibility: hidden; transition: all 0.2s ease; width: 250px; pointer-events: none; }
        .x-popover-container:hover .x-popover { opacity: 1; visibility: visible; pointer-events: auto; transform: translateX(-50%) translateY(0); }
        .bottom-nav { position: fixed; bottom: 0; left: 0; right: 0; z-index: 40; background: rgba(31, 41, 55, 0.9); backdrop-filter: blur(10px); border-top: 1px solid rgba(55, 65, 81, 0.5); }
        .nav-btn { display: flex; flex-direction: column; align-items: center; justify-content: center; flex-grow: 1; padding: 8px 0; color: #9CA3AF; transition: color 0.2s ease; width: 0; }
        .nav-btn.active { color: #14F195; }
        .nav-btn i { font-size: 24px; }
        .nav-btn span { font-size: 10px; margin-top: 2px; }
        .page-container { padding-bottom: 60px; flex-grow: 1; }
        .page { padding: 1rem; display: none; }
        .page.active { display: block; }
        #pnl-card-content { background-color: #1F2937; }
        .pnl-value-positive { color: #22C55E; }
        .pnl-value-negative { color: #EF4444; }
        #main-content.hidden { display: none; }
        #auth-screen.hidden { display: none; }
    </style>
</head>
<body class="bg-page-bg text-white font-sans antialiased flex flex-col min-h-screen">

    <!-- Pantalla de Autenticación -->
    <div id="auth-screen" class="flex flex-col items-center justify-center min-h-screen p-4">
         <!-- ... (contenido auth sin cambios) ... -->
         <h1 class="text-3xl font-bold text-solana-green mb-8">🚀 Solana Memecoin Sim</h1>
        <div class="glassmorphism p-8 rounded-lg shadow-2xl w-full max-w-sm">
            <div class="flex border-b border-gray-700 mb-6"> <button id="tab-login" class="flex-1 py-2 text-center text-solana-green border-b-2 border-solana-green font-semibold">Iniciar Sesión</button> <button id="tab-register" class="flex-1 py-2 text-center text-gray-400 font-semibold">Registrarse</button> </div>
            <form id="login-form" class="space-y-4"> <div> <label for="login-username" class="block text-sm font-medium text-gray-300">Nombre de Usuario</label> <input type="text" id="login-username" required class="w-full mt-1 px-3 py-2 bg-gray-900 border border-gray-700 rounded-md focus:outline-none focus:ring-2 focus:ring-solana-purple" autocomplete="username"> </div> <div> <label for="login-password" class="block text-sm font-medium text-gray-300">Contraseña</label> <input type="password" id="login-password" required class="w-full mt-1 px-3 py-2 bg-gray-900 border border-gray-700 rounded-md focus:outline-none focus:ring-2 focus:ring-solana-purple" autocomplete="current-password"> </div> <button type="submit" class="w-full bg-solana-purple hover:bg-opacity-80 text-white font-bold py-2 px-4 rounded-md transition duration-200"> Entrar </button> <p id="login-error" class="text-red-500 text-sm mt-2 text-center hidden"></p> </form>
            <form id="register-form" class="space-y-4 hidden"> <div> <label for="register-username" class="block text-sm font-medium text-gray-300">Nombre de Usuario</label> <input type="text" id="register-username" required class="w-full mt-1 px-3 py-2 bg-gray-900 border border-gray-700 rounded-md focus:outline-none focus:ring-2 focus:ring-solana-purple" autocomplete="username" maxlength="15"> <p class="text-xs text-gray-500 mt-1">Máximo 15 caracteres, sin espacios ni caracteres especiales.</p> </div> <div> <label for="register-password" class="block text-sm font-medium text-gray-300">Contraseña</label> <input type="password" id="register-password" required class="w-full mt-1 px-3 py-2 bg-gray-900 border border-gray-700 rounded-md focus:outline-none focus:ring-2 focus:ring-solana-purple" autocomplete="new-password"> <p class="text-xs text-gray-500 mt-1">Mínimo 6 caracteres.</p> </div> <button type="submit" class="w-full bg-solana-green hover:bg-opacity-80 text-gray-900 font-bold py-2 px-4 rounded-md transition duration-200"> Crear Cuenta </button> <p id="register-error" class="text-red-500 text-sm mt-2 text-center hidden"></p> </form>
        </div>
    </div>

    <!-- Contenido Principal del Juego (Oculto inicialmente) -->
    <div id="main-content" class="hidden flex flex-col min-h-screen">
        <!-- Encabezado Fijo -->
        <header class="bg-item-bg shadow-lg sticky top-0 z-30">
             <!-- ... (contenido header sin cambios) ... -->
            <nav class="container mx-auto px-4 py-3 flex justify-between items-center"> <h1 class="text-xl lg:text-2xl font-bold text-solana-green"> 🚀 Solana Memecoin Sim </h1> <div class="flex items-center space-x-4"> <button id="logout-btn" class="text-gray-400 hover:text-white transition duration-200" title="Cerrar Sesión"> <i class="ph ph-sign-out text-2xl"></i> </button> <button id="show-create-modal-btn" class="bg-solana-purple hover:bg-opacity-80 text-white font-bold p-2 rounded-full transition duration-200"> <i class="ph ph-plus text-xl"></i> </button> <div class="text-right"> <div class="text-sm text-gray-400">Balance</div> <div id="ssol-balance" class="text-lg font-semibold text-solana-green">?.?? sSOL</div> </div> </div> </nav> <div id="player-id-banner" class="bg-solana-purple text-center py-1 px-4 text-xs font-mono"> Conectando... </div>
        </header>

        <!-- Contenedor Principal de Páginas -->
        <main class="container mx-auto page-container">
             <!-- ... (contenido main sin cambios) ... -->
            <section id="page-mercado" class="page active"> <div class="mb-3"> <input type="text" id="coin-filter-input" placeholder="Filtrar por nombre o símbolo..." class="w-full px-3 py-2 bg-item-bg border border-item-hover rounded-md focus:outline-none focus:ring-2 focus:ring-solana-purple"> </div> <div id="memecoin-list" class="flex-grow overflow-y-auto space-y-2 pr-2"> <p class="text-gray-400 text-center mt-10">Cargando monedas...</p> </div> </section>
            <section id="page-portafolio" class="page"> <h2 class="text-xl font-semibold mb-3 border-b border-gray-700 pb-2">Mi Portafolio</h2> <div id="portfolio-list" class="space-y-2 pr-2 mb-6"> <p class="text-gray-400">Cargando portafolio...</p> </div> </section>
            <section id="page-social" class="page"> <div class="flex justify-between items-center mb-4"> <h2 class="text-xl font-semibold">Feed Social</h2> <div> <button id="show-my-profile-btn" class="bg-item-hover hover:bg-gray-600 text-white font-bold py-2 px-3 rounded-md transition duration-200 text-sm mr-2"> Mi Perfil </button> <button id="create-social-post-btn" class="bg-solana-purple hover:bg-opacity-80 text-white font-bold py-2 px-3 rounded-md transition duration-200 text-sm"> Crear Post </button> </div> </div> <div id="social-feed-list" class="space-y-3"> <p class="text-gray-400 text-center mt-10">Cargando feed...</p> </div> </section>
            <section id="page-jugadores" class="page"> <h2 class="text-xl font-semibold mb-3 border-b border-gray-700 pb-2">Jugadores en la Sala</h2> <div id="players-list" class="overflow-y-auto space-y-2 pr-2"> <p class="text-gray-400 text-center mt-10">Cargando jugadores...</p> </div> </section>
        </main>

        <!-- Barra de Navegación Inferior (Simplificada) -->
        <nav class="bottom-nav flex shadow-lg">
             <!-- ... (contenido nav sin cambios) ... -->
            <button class="nav-btn active" data-page="page-mercado" title="Mercado"> <i class="ph ph-chart-line-up"></i> <span class="hidden sm:inline">Mercado</span> </button> <button class="nav-btn" data-page="page-portafolio" title="Portafolio"> <i class="ph ph-wallet"></i> <span class="hidden sm:inline">Portafolio</span> </button> <button class="nav-btn" data-page="page-social" title="Feed Social"> <i class="ph ph-user-sound"></i> <span class="hidden sm:inline">Feed</span> </button> <button class="nav-btn" data-page="page-jugadores" title="Jugadores"> <i class="ph ph-users"></i> <span class="hidden sm:inline">Jugadores</span> </button>
        </nav>

        <!-- MODALES -->
        <!-- ... (todos los modales sin cambios) ... -->
         <div id="message-modal" class="modal fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 hidden opacity-0 visibility-hidden p-4"> <div class="modal-content glassmorphism p-6 rounded-lg shadow-2xl max-w-sm w-full text-center transform scale-95"> <p id="message-text" class="text-lg mb-4">Mensaje</p> <button id="close-message-btn" class="bg-solana-purple hover:bg-opacity-80 text-white font-bold py-2 px-4 rounded-md transition duration-200"> Cerrar </button> </div> </div>
         <div id="create-coin-modal" class="modal fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 hidden opacity-0 visibility-hidden p-4"> <div class="modal-content glassmorphism p-6 rounded-lg shadow-2xl max-w-md w-full text-center transform scale-95 overflow-y-auto max-h-full"> <div class="flex justify-between items-center mb-3 border-b border-gray-700 pb-2"> <h2 class="text-xl font-semibold">Lanzar Nueva Memecoin</h2> <button id="close-create-modal-btn" class="text-gray-400 hover:text-white text-2xl">&times;</button> </div> <form id="create-coin-form" class="space-y-3 text-left"> <div> <label for="coin-name" class="block text-sm font-medium text-gray-300">Nombre (Ej: DogeWifHat)</label> <input type="text" id="coin-name" required class="w-full mt-1 px-3 py-2 bg-gray-900 border border-gray-700 rounded-md focus:outline-none focus:ring-2 focus:ring-solana-purple" maxlength="20"> </div> <div> <label for="coin-symbol" class="block text-sm font-medium text-gray-300">Símbolo (Ej: WIF)</label> <input type="text" id="coin-symbol" required class="w-full mt-1 px-3 py-2 bg-gray-900 border border-gray-700 rounded-md focus:outline-none focus:ring-2 focus:ring-solana-purple" maxlength="5" autocapitalize="characters"> </div> <div> <label for="coin-image-url" class="block text-sm font-medium text-gray-300">URL de Imagen</label> <input type="url" id="coin-image-url" placeholder="https://..." class="w-full mt-1 px-3 py-2 bg-gray-900 border border-gray-700 rounded-md focus:outline-none focus:ring-2 focus:ring-solana-purple"> </div> <div> <label for="coin-x-url" class="block text-sm font-medium text-gray-300">URL de X (Twitter)</label> <input type="url" id="coin-x-url" placeholder="https://x.com/yourcoin" class="w-full mt-1 px-3 py-2 bg-gray-900 border border-gray-700 rounded-md focus:outline-none focus:ring-2 focus:ring-x-blue"> </div> <div class="grid grid-cols-2 gap-2"> <div> <label for="coin-initial-ssol" class="block text-sm font-medium text-gray-300">sSOL Inicial (Liq.)</label> <input type="number" id="coin-initial-ssol" step="0.01" min="0.01" required placeholder="0.1" class="w-full mt-1 px-3 py-2 bg-gray-900 border border-gray-700 rounded-md focus:outline-none focus:ring-2 focus:ring-solana-purple"> </div> <div> <label for="coin-initial-tokens" class="block text-sm font-medium text-gray-300">Tokens (Liq.)</label> <input type="number" id="coin-initial-tokens" step="1000" min="1000" required placeholder="1000000" class="w-full mt-1 px-3 py-2 bg-gray-900 border border-gray-700 rounded-md focus:outline-none focus:ring-2 focus:ring-solana-purple"> </div> </div> <button type="submit" class="w-full bg-solana-purple hover:bg-opacity-80 text-white font-bold py-2 px-4 rounded-md transition duration-200"> Lanzar (Costo: 0.01 sSOL + Liq.) </button> </form> </div> </div>
         <div id="chart-modal" class="modal fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 hidden opacity-0 visibility-hidden p-4"> <div class="modal-content glassmorphism p-6 rounded-lg shadow-2xl max-w-3xl w-full text-center transform scale-95 overflow-y-auto max-h-full"> <div class="flex justify-between items-center mb-3 border-b border-gray-700 pb-2"> <div class="flex items-center gap-2"> <h2 id="modal-coin-name" class="text-2xl font-bold text-solana-green"></h2> <span id="modal-live-badge" class="hidden animate-livePulse text-xs font-bold bg-red-600 text-white px-2 py-0.5 rounded-md">LIVE</span> </div> <button id="close-chart-modal-btn" class="text-gray-400 hover:text-white text-2xl">&times;</button> </div> <p id="modal-coin-price" class="text-xl font-mono text-center text-gray-300 mb-4">$0.00</p> <p id="modal-contract-id" class="text-sm font-mono text-center text-gray-500 mb-4">ID: ...</p> <div class="relative h-48 md:h-72 mb-4"> <canvas id="coin-chart-modal"></canvas> </div> <div class="flex gap-2 mb-4 w-full justify-center"> <button id="view-live-btn" class="hidden w-1/2 bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-md transition duration-200"> Ver Directo </button> <button id="show-pnl-modal-btn" class="w-1/2 bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md transition duration-200"> Ver PnL </button> </div> <div class="grid grid-cols-1 md:grid-cols-2 gap-4"> <form id="buy-form-modal" class="space-y-2 glassmorphism p-4 rounded-lg"> <label for="buy-amount-ssol-modal" class="block text-sm font-medium text-gray-300">Gastar (sSOL) - Fee 0.3%</label> <input type="text" id="buy-amount-ssol-modal" inputmode="decimal" placeholder="0.1" class="w-full px-3 py-2 bg-gray-900 border border-gray-700 rounded-md focus:outline-none focus:ring-2 focus:ring-solana-green" required> <button type="submit" class="w-full bg-solana-green hover:bg-opacity-80 text-gray-900 font-bold py-2 px-4 rounded-md transition duration-200"> Comprar </button> </form> <form id="sell-form-modal" class="space-y-2 glassmorphism p-4 rounded-lg"> <label for="sell-amount-token-modal" class="block text-sm font-medium text-gray-300">Vender (Tokens) - Fee 0.3%</label> <input type="text" id="sell-amount-token-modal" inputmode="decimal" placeholder="1000" class="w-full px-3 py-2 bg-gray-900 border border-gray-700 rounded-md focus:outline-none focus:ring-2 focus:ring-red-500" required> <div class="grid grid-cols-3 gap-2 text-xs"> <button type="button" class="sell-percent-btn bg-gray-700 hover:bg-gray-600 py-1 rounded" data-percent="0.10">10%</button> <button type="button" class="sell-percent-btn bg-gray-700 hover:bg-gray-600 py-1 rounded" data-percent="0.50">50%</button> <button type="button" class="sell-percent-btn bg-gray-700 hover:bg-gray-600 py-1 rounded" data-percent="1.00">100%</button> </div> <button type="submit" class="w-full bg-red-600 hover:bg-opacity-80 text-white font-bold py-2 px-4 rounded-md transition duration-200"> Vender </button> </form> </div> </div> </div>
         <div id="creator-dashboard-modal" class="modal fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 hidden opacity-0 visibility-hidden p-4"> <div class="modal-content glassmorphism p-6 rounded-lg shadow-2xl max-w-4xl w-full text-center transform scale-95 overflow-y-auto max-h-full"> <div class="flex justify-between items-center mb-3 border-b border-gray-700 pb-2"> <h2 class="text-xl font-semibold">Panel de Creador</h2> <button id="close-creator-dashboard-btn" class="text-gray-400 hover:text-white text-2xl">&times;</button> </div> <div id="creator-coins-list" class="space-y-4 text-left"> <p class="text-gray-400 text-center">Cargando tus monedas...</p> </div> </div> </div>
         <div id="send-ssol-modal" class="modal fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 hidden opacity-0 visibility-hidden p-4"> <div class="modal-content glassmorphism p-6 rounded-lg shadow-2xl max-w-md w-full text-center transform scale-95"> <div class="flex justify-between items-center mb-3 border-b border-gray-700 pb-2"> <h2 class="text-xl font-semibold">Enviar sSOL</h2> <button id="close-send-ssol-btn" class="text-gray-400 hover:text-white text-2xl">&times;</button> </div> <form id="send-ssol-form" class="space-y-3 text-left"> <p class="text-sm">Enviar a: <strong id="send-ssol-target-name" class="font-mono text-solana-green">...</strong></p> <div> <label for="send-ssol-amount" class="block text-sm font-medium text-gray-300">Monto (sSOL)</label> <input type="number" id="send-ssol-amount" step="0.01" min="0.01" required placeholder="0.1" class="w-full mt-1 px-3 py-2 bg-gray-900 border border-gray-700 rounded-md focus:outline-none focus:ring-2 focus:ring-solana-purple"> </div> <button type="submit" class="w-full bg-solana-purple hover:bg-opacity-80 text-white font-bold py-2 px-4 rounded-md transition duration-200"> Confirmar Envío </button> </form> </div> </div>
         <div id="live-stream-modal" class="modal fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 hidden opacity-0 visibility-hidden p-4"> <div class="modal-content glassmorphism p-6 rounded-lg shadow-2xl max-w-2xl w-full text-center transform scale-95"> <div class="flex justify-between items-center mb-3 border-b border-gray-700 pb-2"> <h2 id="live-coin-name" class="text-xl font-semibold text-red-500 animate-pulse">LIVE: ...</h2> <button id="close-live-stream-btn" class="text-gray-400 hover:text-white text-2xl">&times;</button> </div> <div class="w-full h-64 bg-black rounded-lg mb-4 animate-liveScreen border-2 border-gray-700 flex items-center justify-center"> <span class="text-3xl font-bold text-gray-500">SIMULACIÓN DE LIVE</span> </div> <div class="flex justify-between items-center mb-3"> <div class="text-lg">Espectadores: <span id="live-viewers" class="font-bold text-solana-green">...</span></div> <div class="flex space-x-2"> <button id="boost-live-btn-small" data-boost-level="small" class="boost-live-btn bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-3 rounded-md text-sm transition"> Boost (0.1 sSOL) </button> <button id="boost-live-btn-medium" data-boost-level="medium" class="boost-live-btn bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-3 rounded-md text-sm transition"> Boost (1 sSOL) </button> <button id="boost-live-btn-large" data-boost-level="large" class="boost-live-btn bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-3 rounded-md text-sm transition"> Boost (10 sSOL) </button> </div> </div> </div> </div>
         <div id="my-profile-modal" class="modal fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 hidden opacity-0 visibility-hidden p-4"> <div class="modal-content glassmorphism p-6 rounded-lg shadow-2xl max-w-md w-full text-center transform scale-95 overflow-y-auto max-h-full"> <div class="flex justify-between items-center mb-3"> <h2 class="text-xl font-semibold">Mi Perfil</h2> <button id="close-my-profile-btn" class="text-gray-400 hover:text-white text-2xl">&times;</button> </div> <form id="edit-social-profile-form" class="space-y-3 text-left mb-4"> <div class="flex items-center gap-4"> <img id="social-avatar-preview" src="https://placehold.co/60/374151/FFFFFF?text=P" alt="Avatar" class="w-16 h-16 rounded-full border-2 border-solana-green"> <div class="flex-grow"> <label for="social-username-input" class="block text-sm font-medium text-gray-300">Nombre de Usuario</label> <input type="text" id="social-username-input" required class="w-full mt-1 px-3 py-2 bg-gray-900 border border-gray-700 rounded-md focus:outline-none focus:ring-2 focus:ring-solana-purple" maxlength="15"> </div> </div> <div> <label for="social-avatar-input" class="block text-sm font-medium text-gray-300">URL de Avatar</label> <input type="url" id="social-avatar-input" placeholder="https://..." class="w-full mt-1 px-3 py-2 bg-gray-900 border border-gray-700 rounded-md focus:outline-none focus:ring-2 focus:ring-solana-purple"> </div> <button type="submit" class="w-full bg-solana-purple hover:bg-opacity-80 text-white font-bold py-2 px-4 rounded-md transition duration-200"> Guardar Perfil </button> </form> <div class="text-left border-t border-gray-700 pt-4"> <h3 class="font-semibold text-md mb-2">Mis Posts</h3> <div id="my-social-posts" class="space-y-3 h-48 overflow-y-auto pr-2"> <p class="text-gray-400 text-sm">Cargando posts...</p> </div> </div> <button id="show-creator-dashboard-btn-from-profile" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md transition duration-200 mt-4"> 💼 Panel de Creador </button> <button id="launch-socialfi-coin-btn" class="w-full bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-3 rounded-md transition duration-200 mt-2 hidden"> 💎 Lanzar Moneda SocialFi (50+ Seguidores) </button> </div> </div>
         <div id="create-social-post-modal" class="modal fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 hidden opacity-0 visibility-hidden p-4"> <div class="modal-content glassmorphism p-6 rounded-lg shadow-2xl max-w-md w-full text-center transform scale-95"> <div class="flex justify-between items-center mb-3 border-b border-gray-700 pb-2"> <h2 class="text-xl font-semibold">Crear Nuevo Post</h2> <button id="close-create-social-post-btn" class="text-gray-400 hover:text-white text-2xl">&times;</button> </div> <form id="create-social-post-form" class="space-y-3 text-left"> <div> <label for="social-post-text" class="block text-sm font-medium text-gray-300">Texto del Post</label> <textarea id="social-post-text" rows="4" required class="w-full mt-1 px-3 py-2 bg-gray-900 border border-gray-700 rounded-md focus:outline-none focus:ring-2 focus:ring-solana-purple" maxlength="280" placeholder="¿Qué estás pensando? Shillea tu moneda aquí..."></textarea> </div> <button type="submit" class="w-full bg-solana-purple hover:bg-opacity-80 text-white font-bold py-2 px-4 rounded-md transition duration-200"> Publicar Post </button> </form> </div> </div>
         <div id="player-profile-modal" class="modal fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 hidden opacity-0 visibility-hidden p-4"> <div class="modal-content glassmorphism p-6 rounded-lg shadow-2xl max-w-md w-full text-center transform scale-95 overflow-y-auto max-h-full"> <div class="flex justify-between items-center mb-3"> <h2 id="player-profile-username" class="text-xl font-semibold">Perfil del Jugador</h2> <button id="close-player-profile-btn" class="text-gray-400 hover:text-white text-2xl">&times;</button> </div> <img id="player-profile-avatar" src="https://placehold.co/60/374151/FFFFFF?text=P" alt="Avatar" class="w-16 h-16 rounded-full mx-auto mb-2 border-2 border-solana-green"> <p class="text-sm text-gray-400 mb-4">Seguidores: <span id="player-profile-followers">0</span></p> <button id="follow-player-btn" class="w-full bg-x-blue hover:bg-opacity-80 text-white font-bold py-2 px-4 rounded-md transition duration-200 mb-4"> Seguir </button> <div class="text-left border-t border-gray-700 pt-4 mb-4"> <h3 class="font-semibold text-md mb-2">Monedas Creadas</h3> <div id="player-profile-coins" class="space-y-2 h-24 overflow-y-auto pr-2"> <p class="text-gray-400 text-sm">Cargando monedas...</p> </div> </div> <div class="text-left border-t border-gray-700 pt-4"> <h3 class="font-semibold text-md mb-2">Posts Recientes</h3> <div id="player-profile-posts" class="space-y-3 h-48 overflow-y-auto pr-2"> <p class="text-gray-400 text-sm">Cargando posts...</p> </div> </div> </div> </div>
         <div id="pnl-card-modal" class="modal fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 hidden opacity-0 visibility-hidden p-4"> <div class="modal-content p-0 rounded-lg shadow-2xl max-w-sm w-full text-center transform scale-95 overflow-hidden"> <div id="pnl-card-content" class="p-6 rounded-lg text-white relative"> <button id="close-pnl-card-btn" class="absolute top-2 right-3 text-gray-300 hover:text-white text-2xl">&times;</button> <div class="flex justify-between items-center mb-4"> <span class="text-xl font-bold">Mi PnL</span> <span id="pnl-coin-symbol" class="text-lg font-bold bg-gray-700 px-3 py-1 rounded-full">...</span> </div> <div id="pnl-total-percent" class="text-4xl font-bold mb-1">+0.00%</div> <div id="pnl-total-ssol" class="text-2xl font-semibold mb-6">+0.00 sSOL</div> <div class="space-y-3 text-sm text-left"> <div class="flex justify-between border-b border-gray-700 pb-2"> <span class="text-gray-400">Total Invertido (sSOL)</span> <span id="pnl-total-invested" class="font-mono">0.00</span> </div> <div class="flex justify-between border-b border-gray-700 pb-2"> <span class="text-gray-400">Total Realizado (sSOL)</span> <span id="pnl-total-realized" class="font-mono">0.00</span> </div> <div class="flex justify-between border-b border-gray-700 pb-2"> <span class="text-gray-400">Valor Actual (sSOL)</span> <span id="pnl-current-value" class="font-mono">0.00</span> </div> <div class="flex justify-between border-b border-gray-700 pb-2"> <span class="text-gray-400">Tokens Actuales</span> <span id="pnl-current-tokens" class="font-mono">0.00</span> </div> <div class="flex justify-between"> <span class="text-gray-400">Precio Prom. Compra</span> <span id="pnl-avg-buy-price" class="font-mono">$0.00</span> </div> </div> </div> </div> </div>

    </div> <!-- Fin de #main-content -->


    <!-- Script Principal (SUPABASE + AUTH SIMPLIFICADO) -->
    <script type="module">
        // --- CONFIGURACIÓN DE SUPABASE ---
        const supabaseUrl = 'https://etwhxnbisztbohrhxexb.supabase.co'; // TU URL
        const supabaseAnonKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImV0d2h4bmJpc3p0Ym9oaHJ4ZXhiIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjE1MDU0NzMsImV4cCI6MjA3NzA4MTQ3M30.y1x3Ra3s7lTvPC6UrAc9DhXb8adFOA2NUQkTz-VZs3s'; // TU CLAVE ANÓNIMA
        const supabaseClient = supabase.createClient(supabaseUrl, supabaseAnonKey);
        const appId = 'meme-59775'; // No se usa directamente con Supabase

        // --- INICIO: ENVOLTORIO MAIN ASYNC ---
        async function main() {

            // --- Prueba Fetch Inicial ---
            console.log("Intentando fetch a Supabase URL...");
            try {
                const response = await fetch(supabaseUrl, { method: 'HEAD' }); // HEAD request is lightweight
                console.log("Fetch test a Supabase URL exitoso:", response.status);
            } catch (fetchError) {
                console.error("Fetch test a Supabase URL fallido:", fetchError);
                // Considera mostrar un mensaje al usuario aquí si este test falla
                 showMessage(`Error de conexión inicial: ${fetchError.message}. Verifica tu red o el entorno.`);
            }
            // --- Fin Prueba Fetch ---

            // --- REFERENCIAS AL DOM (Auth y Contenido Principal) ---
            const authScreen = document.getElementById('auth-screen');
            const mainContent = document.getElementById('main-content');
            const loginForm = document.getElementById('login-form');
            const registerForm = document.getElementById('register-form');
            const tabLogin = document.getElementById('tab-login');
            const tabRegister = document.getElementById('tab-register');
            const loginUsernameInput = document.getElementById('login-username');
            const loginPasswordInput = document.getElementById('login-password');
            const registerUsernameInput = document.getElementById('register-username');
            const registerPasswordInput = document.getElementById('register-password');
            const loginErrorEl = document.getElementById('login-error');
            const registerErrorEl = document.getElementById('register-error');
            const logoutBtn = document.getElementById('logout-btn');


            // --- REFERENCIAS AL DOM (MODALES y otros elementos) ---
            // ... (resto de refs sin cambios)
            const messageModalEl = document.getElementById('message-modal');
            const messageTextEl = document.getElementById('message-text');
            const closeMessageBtn = document.getElementById('close-message-btn');
            const createCoinModalEl = document.getElementById('create-coin-modal');
            const showCreateModalBtn = document.getElementById('show-create-modal-btn');
            const closeCreateModalBtn = document.getElementById('close-create-modal-btn');
            const chartModalEl = document.getElementById('chart-modal');
            const closeChartModalBtn = document.getElementById('close-chart-modal-btn');
            const modalCoinNameEl = document.getElementById('modal-coin-name');
            const modalCoinPriceEl = document.getElementById('modal-coin-price');
            const modalLiveBadgeEl = document.getElementById('modal-live-badge');
            const viewLiveBtnEl = document.getElementById('view-live-btn');
            const modalContractIdEl = document.getElementById('modal-contract-id');
            const showPnlModalBtn = document.getElementById('show-pnl-modal-btn');
            const pnlCardModalEl = document.getElementById('pnl-card-modal');
            const closePnlCardBtn = document.getElementById('close-pnl-card-btn');
            const pnlCardContentEl = document.getElementById('pnl-card-content');
            const pnlCoinSymbolEl = document.getElementById('pnl-coin-symbol');
            const pnlTotalPercentEl = document.getElementById('pnl-total-percent');
            const pnlTotalSsolEl = document.getElementById('pnl-total-ssol');
            const pnlTotalInvestedEl = document.getElementById('pnl-total-invested');
            const pnlTotalRealizedEl = document.getElementById('pnl-total-realized');
            const pnlCurrentValueEl = document.getElementById('pnl-current-value');
            const pnlCurrentTokensEl = document.getElementById('pnl-current-tokens');
            const pnlAvgBuyPriceEl = document.getElementById('pnl-avg-buy-price');
            const creatorDashboardModalEl = document.getElementById('creator-dashboard-modal');
            const closeCreatorDashboardBtn = document.getElementById('close-creator-dashboard-btn');
            const creatorCoinsListEl = document.getElementById('creator-coins-list');
            const sendSsolModalEl = document.getElementById('send-ssol-modal');
            const closeSendSsolBtn = document.getElementById('close-send-ssol-btn');
            const sendSsolTargetNameEl = document.getElementById('send-ssol-target-name');
            const sendSsolFormEl = document.getElementById('send-ssol-form');
            const sendSsolAmountEl = document.getElementById('send-ssol-amount');
            const liveStreamModalEl = document.getElementById('live-stream-modal');
            const closeLiveStreamBtn = document.getElementById('close-live-stream-btn');
            const liveCoinNameEl = document.getElementById('live-coin-name');
            const liveViewersEl = document.getElementById('live-viewers');
            const myProfileModalEl = document.getElementById('my-profile-modal');
            const showMyProfileBtn = document.getElementById('show-my-profile-btn');
            const closeMyProfileBtn = document.getElementById('close-my-profile-btn');
            const editSocialProfileFormEl = document.getElementById('edit-social-profile-form');
            const socialUsernameInputEl = document.getElementById('social-username-input');
            const socialAvatarInputEl = document.getElementById('social-avatar-input');
            const socialAvatarPreviewEl = document.getElementById('social-avatar-preview');
            const mySocialPostsEl = document.getElementById('my-social-posts');
            const showCreatorDashboardBtnFromProfile = document.getElementById('show-creator-dashboard-btn-from-profile');
            const launchSocialFiCoinBtn = document.getElementById('launch-socialfi-coin-btn');
            const createSocialPostModalEl = document.getElementById('create-social-post-modal');
            const closeCreateSocialPostBtn = document.getElementById('close-create-social-post-btn');
            const createSocialPostBtn = document.getElementById('create-social-post-btn');
            const createSocialPostFormEl = document.getElementById('create-social-post-form');
            const socialPostTextEl = document.getElementById('social-post-text');
            const playerProfileModalEl = document.getElementById('player-profile-modal');
            const closePlayerProfileBtn = document.getElementById('close-player-profile-btn');
            const playerProfileUsernameEl = document.getElementById('player-profile-username');
            const playerProfileAvatarEl = document.getElementById('player-profile-avatar');
            const playerProfileFollowersEl = document.getElementById('player-profile-followers');
            const playerProfilePostsEl = document.getElementById('player-profile-posts');
            const playerProfileCoinsEl = document.getElementById('player-profile-coins');
            const followPlayerBtn = document.getElementById('follow-player-btn');
            const ssolBalanceEl = document.getElementById('ssol-balance');
            const playerIdBannerEl = document.getElementById('player-id-banner');
            const coinFilterInputEl = document.getElementById('coin-filter-input');
            const pages = document.querySelectorAll('.page');
            const navButtons = document.querySelectorAll('.nav-btn');
            const memecoinListEl = document.getElementById('memecoin-list');
            const portfolioListEl = document.getElementById('portfolio-list');
            // Elementos eliminados: myLuxuryAssetsListEl, myOfficeAssetsListEl, officeLayoutEl, chatMessagesEl, chatFormEl, chatInputEl
            const socialFeedListEl = document.getElementById('social-feed-list');
            const playersListEl = document.getElementById('players-list');
            const createCoinFormEl = document.getElementById('create-coin-form');
            const coinNameEl = document.getElementById('coin-name');
            const coinSymbolEl = document.getElementById('coin-symbol');
            const coinImageUrlEl = document.getElementById('coin-image-url');
            const coinXUrlEl = document.getElementById('coin-x-url');
            const coinInitialSsolEl = document.getElementById('coin-initial-ssol');
            const coinInitialTokensEl = document.getElementById('coin-initial-tokens');
            const buyFormEl = document.getElementById('buy-form-modal');
            const sellFormEl = document.getElementById('sell-form-modal');
            const buyAmountEl = document.getElementById('buy-amount-ssol-modal');
            const sellAmountEl = document.getElementById('sell-amount-token-modal');


            // --- FUNCIONES DE MODAL ---
             function showModal(modalEl) {
                modalEl.classList.remove('hidden');
                setTimeout(() => {
                    modalEl.classList.remove('opacity-0', 'visibility-hidden');
                    const content = modalEl.querySelector('.modal-content');
                    if (content) content.classList.remove('scale-95');
                }, 10);
            }

            function hideModal(modalEl) {
                modalEl.classList.add('opacity-0');
                const content = modalEl.querySelector('.modal-content');
                 if (content) content.classList.add('scale-95');
                setTimeout(() => {
                    modalEl.classList.add('hidden', 'visibility-hidden');
                }, 250);
            }

            function showMessage(text) {
                messageTextEl.textContent = text;
                showModal(messageModalEl);
            }
            // --- VARIABLES GLOBALES DEL JUEGO ---
            let currentUserId = null; // UUID de Supabase Auth
            let currentUserData = null; // Datos de la tabla 'players'
            let realtimeChannels = []; // Suscripciones Realtime
            let selectedCoinId = null;
            let targetPlayerId = null;
            let memecoinChart = null;
            let chartGradient = null;
            let allCoinsCache = new Map();
            let myPortfolioCache = new Map();
            // let myAssetsCache = { assets: new Map(), office: new Map() }; // Eliminado
            let allPlayersCache = new Map();
            let mySocialPostsCache = new Map();
            let globalSocialFeedCache = new Map();
            let selectedProfilePlayerId = null;
            let myFollowsCache = new Set();
            // let chatListener = null; // Eliminado

            // --- COMISIONES ---
            const LP_FEE = 0.0025;
            const CREATOR_FEE = 0.0005;
            const TOTAL_FEE = LP_FEE + CREATOR_FEE;
            const PROMO_POST_COST = 0.2;

            // --- LÓGICA DE NAVEGACIÓN (SPA - Simplificada) ---
            function showPage(pageId) {
                pages.forEach(page => {
                    page.classList.toggle('active', page.id === pageId);
                });
                navButtons.forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.page === pageId);
                });
            }
            navButtons.forEach(btn => {
                btn.addEventListener('click', () => showPage(btn.dataset.page));
            });

             // --- Add event listeners for modal close buttons ---
            closeMessageBtn.addEventListener('click', () => hideModal(messageModalEl));
            closeCreateModalBtn.addEventListener('click', () => hideModal(createCoinModalEl));
            closeChartModalBtn.addEventListener('click', () => {
                hideModal(chartModalEl);
                selectedCoinId = null;
                const coinElements = memecoinListEl.querySelectorAll('button');
                coinElements.forEach(child => {
                    child.classList.remove('bg-solana-purple/50');
                    child.classList.add('bg-item-bg');
                });
            });
            closeCreatorDashboardBtn.addEventListener('click', () => hideModal(creatorDashboardModalEl));
            closeSendSsolBtn.addEventListener('click', () => hideModal(sendSsolModalEl));
            closeLiveStreamBtn.addEventListener('click', () => hideModal(liveStreamModalEl));
            closeMyProfileBtn.addEventListener('click', () => hideModal(myProfileModalEl));
            closeCreateSocialPostBtn.addEventListener('click', () => hideModal(createSocialPostModalEl));
            closePlayerProfileBtn.addEventListener('click', () => hideModal(playerProfileModalEl));
            closePnlCardBtn.addEventListener('click', () => hideModal(pnlCardModalEl));

             // --- Add event listeners for modal open buttons ---
            showCreateModalBtn.addEventListener('click', () => showModal(createCoinModalEl));
            showPnlModalBtn.addEventListener('click', () => showPnlModal());
            viewLiveBtnEl.addEventListener('click', () => showLiveStream());
            showMyProfileBtn.addEventListener('click', () => {
                const player = allPlayersCache.get(currentUserId); // Usa caché aquí
                if (player) {
                    socialUsernameInputEl.value = player.username || '';
                    socialAvatarInputEl.value = player.avatar_url || '';
                    socialAvatarPreviewEl.src = player.avatar_url || 'https://placehold.co/60/374151/FFFFFF?text=P';
                }
                loadMySocialPosts(currentUserId); // Cargar posts aquí
                showModal(myProfileModalEl);
            });
            createSocialPostBtn.addEventListener('click', () => showModal(createSocialPostModalEl));
             showCreatorDashboardBtnFromProfile.addEventListener('click', () => {
                hideModal(myProfileModalEl);
                showCreatorDashboard();
            });
             document.querySelectorAll('.boost-live-btn').forEach(btn => btn.addEventListener('click', (e) => boostLiveStream(e.target.dataset.boostLevel)));

            // --- FUNCIONES DE UTILIDAD ---
             function parseFloatStrict(value) {
                if (typeof value !== 'string' || value.trim() === '') return NaN;
                const normalizedValue = value.replace(',', '.');
                // Permitir solo números y un punto decimal opcional
                if (!/^[0-9]+(\.[0-9]*)?$|^[0-9]*(\.[0-9]+)?$/.test(normalizedValue)) return NaN;
                const number = parseFloat(normalizedValue);
                return isNaN(number) || number < 0 ? NaN : number;
             }
            function formatPrice(value) { /* ... (sin cambios) ... */
                if (isNaN(value)) value = 0;
                return new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD', minimumFractionDigits: 2, maximumFractionDigits: 10 }).format(value);
            }
            function formatCurrency(value) { /* ... (sin cambios) ... */
                if (isNaN(value)) value = 0;
                 return new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD', minimumFractionDigits: 2, maximumFractionDigits: 2 }).format(value);
            }
            function formatNumber(value, decimals = 2) { /* ... (sin cambios) ... */
                if (isNaN(value)) value = 0;
                return new Intl.NumberFormat('en-US', { minimumFractionDigits: decimals, maximumFractionDigits: decimals }).format(value);
            }
            function timeAgo(dateString) { /* ... (sin cambios) ... */
                 if (!dateString) return 'justo ahora';
                const date = new Date(dateString);
                const seconds = Math.floor((new Date() - date) / 1000);
                let interval = seconds / 31536000;
                if (interval > 1) return Math.floor(interval) + "a";
                interval = seconds / 2592000;
                if (interval > 1) return Math.floor(interval) + "m";
                interval = seconds / 86400;
                if (interval > 1) return Math.floor(interval) + "d";
                interval = seconds / 3600;
                if (interval > 1) return Math.floor(interval) + "h";
                interval = seconds / 60;
                if (interval > 1) return Math.floor(interval) + "min";
                return "ahora";
            }
            // Función para validar username (solo letras, números y guión bajo)
            function isValidUsername(username) {
                return /^[a-zA-Z0-9_]{3,15}$/.test(username);
            }

            // --- LÓGICA DE AUTENTICACIÓN (SUPABASE AUTH - Username/Password) ---

            // Cambiar entre formularios Login/Register
            tabLogin.addEventListener('click', () => {
                loginForm.classList.remove('hidden');
                registerForm.classList.add('hidden');
                tabLogin.classList.add('text-solana-green', 'border-solana-green');
                tabLogin.classList.remove('text-gray-400');
                tabRegister.classList.add('text-gray-400');
                tabRegister.classList.remove('text-solana-green', 'border-solana-green');
                loginErrorEl.classList.add('hidden');
                registerErrorEl.classList.add('hidden');
            });
             tabRegister.addEventListener('click', () => {
                loginForm.classList.add('hidden');
                registerForm.classList.remove('hidden');
                tabLogin.classList.remove('text-solana-green', 'border-solana-green');
                tabLogin.classList.add('text-gray-400');
                tabRegister.classList.add('text-solana-green', 'border-solana-green');
                tabRegister.classList.remove('text-gray-400');
                loginErrorEl.classList.add('hidden');
                registerErrorEl.classList.add('hidden');
            });

             // Manejar Registro
            registerForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                registerErrorEl.classList.add('hidden');
                const username = registerUsernameInput.value.trim();
                const password = registerPasswordInput.value;
                const registerButton = registerForm.querySelector('button[type="submit"]');

                if (!isValidUsername(username)) {
                    registerErrorEl.textContent = "Usuario inválido (3-15 caracteres, solo letras, números, _).";
                    registerErrorEl.classList.remove('hidden');
                    return;
                }
                 if (password.length < 6) {
                    registerErrorEl.textContent = "Contraseña debe tener al menos 6 caracteres.";
                    registerErrorEl.classList.remove('hidden');
                    return;
                }

                 // Crear email falso
                 const email = `${username.toLowerCase()}@memesim.app`;

                 registerButton.disabled = true;
                 registerButton.textContent = 'Creando...';

                try {
                     // 1. Intentar registrar en Supabase Auth
                     console.log(`Intentando registrar con email: ${email}`); // Log para depurar
                     const { data: signUpData, error: signUpError } = await supabaseClient.auth.signUp({ email, password });

                     if (signUpError) {
                         console.error("Error directo de signUp:", signUpError); // Log detallado
                         if (signUpError.message.includes("User already registered")) {
                             throw new Error("Nombre de usuario ya existe.");
                         }
                         throw new Error(`Error de registro: ${signUpError.message}`);
                     }

                     if (!signUpData.user) throw new Error("No se pudo obtener el usuario después del registro.");

                     const newUserId = signUpData.user.id;
                     console.log("Usuario registrado en Auth:", newUserId);

                     // 2. Crear perfil en la tabla 'players'
                     const defaultAvatar = `https://placehold.co/60/374151/FFFFFF?text=${username.slice(0,1).toUpperCase()}`;
                     console.log("Intentando crear perfil para:", newUserId);
                     const { error: profileError } = await supabaseClient
                         .from('players')
                         .insert({
                             user_id: newUserId,
                             username: username, // Usar el username real
                             avatar_url: defaultAvatar,
                             s_sol_balance: 2.0 // Saldo inicial
                         });

                     if (profileError) {
                          console.error("Error al crear perfil:", profileError);
                         // Intentar eliminar el usuario de Auth si falla la creación del perfil (mejor esfuerzo)
                         console.error("Error al crear perfil, intentando eliminar usuario de auth:", profileError);
                         // Necesitarías una función de admin para eliminar usuario, no es posible desde el cliente directamente
                         // Por ahora, solo mostrar error
                         throw new Error(`Error al crear perfil: ${profileError.message}. Contacta soporte si el usuario queda inconsistente.`);
                     }
                     console.log("Perfil creado exitosamente.");

                     // 3. Iniciar sesión automáticamente (signUp a menudo ya lo hace) y empezar juego
                     console.log("Registro exitoso, iniciando juego...");
                     currentUserId = newUserId;
                     await initializeGameUI(newUserId); // Iniciar UI y listeners

                 } catch (error) {
                     console.error("Error en registro:", error);
                     registerErrorEl.textContent = error.message;
                     registerErrorEl.classList.remove('hidden');
                 } finally {
                    registerButton.disabled = false;
                    registerButton.textContent = 'Crear Cuenta';
                 }
            });

             // Manejar Login
            loginForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                loginErrorEl.classList.add('hidden');
                const username = loginUsernameInput.value.trim();
                const password = loginPasswordInput.value;
                const loginButton = loginForm.querySelector('button[type="submit"]');

                 if (!username || !password) {
                     loginErrorEl.textContent = "Ingresa usuario y contraseña.";
                     loginErrorEl.classList.remove('hidden');
                     return;
                 }
                  // Crear email falso
                 const email = `${username.toLowerCase()}@memesim.app`;

                 loginButton.disabled = true;
                 loginButton.textContent = 'Entrando...';

                 try {
                     console.log(`Intentando iniciar sesión con email: ${email}`); // Log para depurar
                    const { data: signInData, error: signInError } = await supabaseClient.auth.signInWithPassword({ email, password });

                    if (signInError) {
                        console.error("Error directo de signIn:", signInError); // Log detallado
                        if (signInError.message.includes("Invalid login credentials")) {
                            throw new Error("Usuario o contraseña incorrectos.");
                        }
                        throw new Error(`Error al iniciar sesión: ${signInError.message}`);
                    }

                    if (!signInData.user) throw new Error("No se pudo obtener el usuario después del login.");

                    console.log("Login exitoso, iniciando juego...");
                    currentUserId = signInData.user.id;
                    await initializeGameUI(currentUserId); // Iniciar UI y listeners

                 } catch (error) {
                      console.error("Error en login:", error);
                     loginErrorEl.textContent = error.message;
                     loginErrorEl.classList.remove('hidden');
                 } finally {
                     loginButton.disabled = false;
                     loginButton.textContent = 'Entrar';
                 }
            });

             // Manejar Logout
            logoutBtn.addEventListener('click', async () => {
                logoutBtn.disabled = true;
                const { error } = await supabaseClient.auth.signOut();
                if (error) {
                    console.error("Error al cerrar sesión:", error);
                    showMessage("Error al cerrar sesión.");
                }
                // Limpiar estado y mostrar pantalla de login
                unsubscribeAllRealtime();
                currentUserId = null;
                currentUserData = null;
                allCoinsCache.clear();
                myPortfolioCache.clear();
                allPlayersCache.clear();
                myFollowsCache.clear();
                // Limpiar UI
                ssolBalanceEl.textContent = '?.?? sSOL';
                playerIdBannerEl.textContent = 'Desconectado';
                memecoinListEl.innerHTML = '';
                portfolioListEl.innerHTML = '';
                socialFeedListEl.innerHTML = '';
                playersListEl.innerHTML = '';

                authScreen.classList.remove('hidden');
                mainContent.classList.add('hidden');
                logoutBtn.disabled = false;
                // Resetear forms de auth
                loginForm.reset();
                registerForm.reset();
                tabLogin.click(); // Volver a la pestaña de login por defecto
            });


            // Función inicial para verificar sesión y mostrar pantalla correcta
            async function checkInitialSession() {
                const { data: { session }, error } = await supabaseClient.auth.getSession();
                if (error) {
                    console.error("Error al obtener sesión:", error);
                    authScreen.classList.remove('hidden'); // Mostrar login si hay error
                    return;
                }
                if (session && session.user) {
                    console.log("Sesión activa encontrada:", session.user.id);
                    currentUserId = session.user.id;
                    await initializeGameUI(currentUserId);
                } else {
                    console.log("No hay sesión activa.");
                    authScreen.classList.remove('hidden');
                    mainContent.classList.add('hidden');
                }
            }

            // Función para inicializar la UI del juego y los listeners después del login/registro
             async function initializeGameUI(userId) {
                 if (!userId) {
                     console.error("initializeGameUI llamado sin userId");
                     authScreen.classList.remove('hidden'); // Mostrar login si falta ID
                     mainContent.classList.add('hidden');
                     return;
                 }
                 // Obtener datos del jugador (tabla players)
                const { data: player, error } = await supabaseClient
                    .from('players')
                    .select('*')
                    .eq('user_id', userId)
                    .single();

                if (error || !player) {
                    console.error("Error al obtener perfil del jugador:", error);
                    showMessage("Error al cargar tu perfil. Intenta cerrar sesión y volver a entrar.");
                    // Forzar logout si no se encuentra el perfil asociado
                     await supabaseClient.auth.signOut();
                     authScreen.classList.remove('hidden');
                     mainContent.classList.add('hidden');
                     return;
                }

                currentUserData = player;

                // Actualizar UI inicial con datos del usuario
                ssolBalanceEl.textContent = `${formatNumber(currentUserData.s_sol_balance)} sSOL`;
                playerIdBannerEl.textContent = `Usuario: ${currentUserData.username} | ID: ...${userId.slice(-6)}`;
                // myAssetsCache ya no existe
                // updateMyAssetsUI(); // Ya no existe

                // Mostrar contenido principal, ocultar auth
                authScreen.classList.add('hidden');
                mainContent.classList.remove('hidden');

                // Iniciar listeners/suscripciones Realtime
                unsubscribeAllRealtime(); // Limpiar por si acaso
                subscribeToPlayerBalance(userId);
                subscribeToPlayers();
                subscribeToMemecoins();
                subscribeToMyPortfolio(userId);
                loadMyPortfolio(userId); // Carga inicial portfolio
                subscribeToMySocialProfile(userId);
                subscribeToGlobalSocialFeed();
                subscribeToMyFollows(userId);
                // No hay chat
            }

            // joinGame ya no es necesario, su lógica está en initializeGameUI

            // --- LISTENERS/SUSCRIPCIONES REALTIME (SUPABASE) ---

            // Función genérica para manejar suscripciones y limpieza
            function setupRealtimeSubscription(channelName, table, filter, callback) {
                // Quitar canal existente con el mismo nombre si existe
                const existingChannel = supabaseClient.channel(channelName);
                if (existingChannel && existingChannel.state === 'joined') {
                    // console.log(`Channel ${channelName} already exists, reusing.`);
                    // return existingChannel; // Podríamos reusarlo, pero remover y recrear es más simple
                     supabaseClient.removeChannel(existingChannel).then(() => console.log(`Removed existing channel ${channelName}`));
                }


                const channel = supabaseClient.channel(channelName);
                channel
                    .on('postgres_changes', { event: '*', schema: 'public', table: table, filter: filter }, payload => {
                        // console.log(`Realtime update on ${table}:`, payload.eventType);
                        callback(payload);
                    })
                    .subscribe((status, err) => {
                        if (status === 'SUBSCRIBED') {
                            console.log(`Subscribed to ${channelName} (${table})`);
                        }
                         else if (status === 'CHANNEL_ERROR' || status === 'TIMED_OUT' || status === 'CLOSED') {
                            console.error(`Subscription error/closed on ${channelName} (${table}):`, status, err);
                            // Intentar re-suscribir después de un delay podría ser una opción
                             // Quitar canal fallido de la lista para evitar intentos de removerlo de nuevo
                             realtimeChannels = realtimeChannels.filter(ch => ch.topic !== channel.topic);
                        }
                    });
                realtimeChannels.push(channel); // Guardar para limpiar después
                return channel; // Devolver el canal por si se necesita referencia directa
            }

            function unsubscribeAllRealtime() {
                console.log("Unsubscribing from all channels...");
                realtimeChannels.forEach(channel => {
                    if (channel.state === 'joined' || channel.state === 'joining') {
                        supabaseClient.removeChannel(channel).catch(e => console.warn("Error removing channel:", e));
                    }
                });
                realtimeChannels = [];
                console.log("Unsubscribed.");
            }
            window.addEventListener('beforeunload', unsubscribeAllRealtime);

            function subscribeToPlayerBalance(userId) {
                setupRealtimeSubscription(`player-balance-${userId}`, 'players', `user_id=eq.${userId}`, (payload) => {
                    if (payload.new && payload.eventType !== 'DELETE') {
                        const data = payload.new;
                        console.log("Realtime update for my balance:", data.s_sol_balance);
                        currentUserData = data; // Actualizar caché local del usuario
                        ssolBalanceEl.textContent = `${formatNumber(data.s_sol_balance)} sSOL`;
                        // myAssetsCache ya no existe
                        // updateMyAssetsUI(); // Ya no existe
                    }
                });
            }

            function subscribeToPlayers() {
                // Carga inicial
                async function loadInitialPlayers() {
                    const { data, error } = await supabaseClient.from('players').select('*');
                    if (error) { console.error("Error loading initial players:", error); playersListEl.innerHTML = '<p class="text-red-500">Error.</p>'; return; }
                    allPlayersCache.clear();
                    data.forEach(p => allPlayersCache.set(p.user_id, p));
                    updatePlayersListUI();
                }
                loadInitialPlayers();
                // Suscripción a cambios
                setupRealtimeSubscription('all-players', 'players', null, (payload) => {
                     const eventType = payload.eventType; const record = eventType === 'DELETE' ? payload.old : payload.new; const userId = record?.user_id;
                     if (!userId) return;
                     if (eventType === 'INSERT' || eventType === 'UPDATE') allPlayersCache.set(userId, record);
                     else if (eventType === 'DELETE') allPlayersCache.delete(userId);
                     updatePlayersListUI();
                });
            }
            function updatePlayersListUI() {
                playersListEl.innerHTML = '';
                if (allPlayersCache.size === 0) { playersListEl.innerHTML = '<p class="text-gray-400">Nadie por aquí...</p>'; return; }
                const sortedPlayers = Array.from(allPlayersCache.values()).sort((a, b) => b.s_sol_balance - a.s_sol_balance);
                sortedPlayers.forEach(player => {
                    const isMe = player.user_id === currentUserId;
                    const playerEl = document.createElement('div');
                    playerEl.className = `flex w-full justify-between items-center p-3 rounded-lg ${isMe ? 'bg-solana-purple/30' : 'bg-item-bg'}`;
                    playerEl.innerHTML = `
                        <div class="flex items-center gap-3">
                            <img src="${player.avatar_url || 'https://placehold.co/40/374151/FFFFFF?text=P'}" alt="avatar" class="w-10 h-10 rounded-full">
                            <div>
                                <span class="font-semibold truncate ${isMe ? 'text-solana-green' : ''}">${player.username || '...'} ${isMe ? '(Tú)' : ''}</span>
                                <span class="text-sm text-gray-400 block">${formatNumber(player.social_followers || 0, 0)} seguidores</span>
                            </div>
                        </div>
                        <span class="text-sm font-semibold">${formatNumber(player.s_sol_balance)} sSOL</span>`;
                    if (!isMe) {
                        const controlsEl = document.createElement('div'); controlsEl.className = "flex gap-2";
                        const sendBtn = document.createElement('button'); sendBtn.innerHTML = `<i class="ph ph-paper-plane-tilt text-xl"></i>`; sendBtn.className = "p-2 bg-item-hover rounded-md hover:bg-gray-600 transition"; sendBtn.title = "Enviar sSOL";
                        sendBtn.addEventListener('click', () => { targetPlayerId = player.user_id; sendSsolTargetNameEl.textContent = `${player.username || '...' + player.user_id.slice(-6)}`; showModal(sendSsolModalEl); });
                        const profileBtn = document.createElement('button'); profileBtn.innerHTML = `<i class="ph ph-user text-xl"></i>`; profileBtn.className = "p-2 bg-item-hover rounded-md hover:bg-gray-600 transition"; profileBtn.title = "Ver Perfil";
                        profileBtn.addEventListener('click', () => { showPlayerProfile(player.user_id); });
                        controlsEl.appendChild(profileBtn); controlsEl.appendChild(sendBtn); playerEl.appendChild(controlsEl);
                    }
                    playersListEl.appendChild(playerEl);
                });
            }

            function subscribeToMyFollows(userId) {
                // Carga inicial
                async function loadInitialFollows() {
                    const { data, error } = await supabaseClient.from('players').select('following').eq('user_id', userId).single();
                    if (!error && data) myFollowsCache = new Set(data.following || []);
                    else console.error("Error loading initial follows:", error);
                }
                loadInitialFollows();
                // Suscripción
                setupRealtimeSubscription(`my-follows-${userId}`, 'players', `user_id=eq.${userId}`, (payload) => {
                    if (payload.new && payload.eventType !== 'DELETE') {
                         myFollowsCache = new Set(payload.new.following || []);
                         if (!playerProfileModalEl.classList.contains('hidden') && selectedProfilePlayerId) updateFollowButton();
                    }
                });
            }

            function subscribeToMySocialProfile(userId) {
                 setupRealtimeSubscription(`my-profile-${userId}`, 'players', `user_id=eq.${userId}`, (payload) => {
                    if (payload.new && payload.eventType !== 'DELETE') {
                        const player = payload.new;
                        currentUserData = player; // Actualizar caché local
                        socialUsernameInputEl.value = player.username || '';
                        socialAvatarInputEl.value = player.avatar_url || '';
                        socialAvatarPreviewEl.src = player.avatar_url || 'https://placehold.co/60/374151/FFFFFF?text=P';
                        launchSocialFiCoinBtn.classList.toggle('hidden', (player.social_followers || 0) < 50);
                    }
                 });
            }

            async function loadMySocialPosts(userId) {
                 mySocialPostsEl.innerHTML = '<p class="text-gray-400 text-sm">Cargando...</p>';
                const { data: posts, error } = await supabaseClient.from('social_posts').select('*').eq('user_id', userId).order('created_at', { ascending: false });
                mySocialPostsCache.clear();
                if (error) { mySocialPostsEl.innerHTML = '<p class="text-red-500 text-sm">Error.</p>'; return; }
                if (!posts || posts.length === 0) { mySocialPostsEl.innerHTML = '<p class="text-gray-400 text-sm">Sin posts.</p>'; return; }
                mySocialPostsEl.innerHTML = '';
                posts.forEach(post => {
                    mySocialPostsCache.set(post.id, post);
                    const postEl = document.createElement('div'); postEl.className = 'bg-item-hover p-3 rounded-lg text-sm';
                    postEl.innerHTML = `<p>${post.text}</p><p class="text-xs text-gray-500 mt-2">${new Date(post.created_at).toLocaleString()}</p>`;
                    mySocialPostsEl.appendChild(postEl);
                });
            }

            function subscribeToGlobalSocialFeed() {
                 // Carga inicial
                async function loadInitialFeed() {
                    const { data, error } = await supabaseClient.from('social_posts').select('*').order('created_at', { ascending: false }).limit(50);
                    if (error) { socialFeedListEl.innerHTML = '<p class="text-red-500 text-center">Error.</p>'; return; }
                    handleFeedUpdate(data);
                }
                loadInitialFeed();
                // Suscripción a cambios
                 setupRealtimeSubscription('social-feed-changes', 'social_posts', null, (payload) => { loadInitialFeed(); });
            }
            function handleFeedUpdate(postsData) {
                socialFeedListEl.innerHTML = ''; globalSocialFeedCache.clear();
                if (!postsData || postsData.length === 0) { socialFeedListEl.innerHTML = '<p class="text-gray-400 text-center">Feed vacío.</p>'; return; }
                 postsData.sort((a, b) => (a.boosted === b.boosted) ? 0 : a.boosted ? -1 : 1); // Boosted primero
                postsData.forEach(post => {
                    globalSocialFeedCache.set(post.id, post);
                    const username = post.username || allPlayersCache.get(post.user_id)?.username || '???';
                    const avatarUrl = post.avatar_url || allPlayersCache.get(post.user_id)?.avatar_url || 'https://placehold.co/40/374151/FFFFFF?text=P';
                    const postEl = document.createElement('div'); postEl.className = `glassmorphism p-4 rounded-lg ${post.boosted ? 'border-2 border-solana-purple' : 'border border-transparent'}`;
                    let promoBtn = '';
                    if (post.user_id === currentUserId && !post.boosted) promoBtn = `<button data-post-id="${post.id}" class="promote-post-btn text-sm text-solana-purple hover:text-solana-green transition">Promocionar (0.2 sSOL)</button>`;
                    else if (post.boosted) promoBtn = `<span class="text-sm text-solana-purple font-semibold">¡Promocionado!</span>`;
                    postEl.innerHTML = `<div class="flex justify-between items-start"><button data-player-id="${post.user_id}" class="player-profile-link flex items-center gap-3 group"><img src="${avatarUrl}" alt="avatar" class="w-10 h-10 rounded-full group-hover:opacity-80 transition"><div><p class="font-semibold text-white group-hover:text-solana-green transition">${username}</p><p class="text-xs text-gray-400">${timeAgo(post.created_at)}</p></div></button>${promoBtn}</div><p class="mt-3 text-gray-200">${post.text}</p>`;
                    socialFeedListEl.appendChild(postEl);
                });
                socialFeedListEl.querySelectorAll('.promote-post-btn').forEach(btn => btn.addEventListener('click', (e) => promotePost(e.target.dataset.postId, e.target)));
                socialFeedListEl.querySelectorAll('.player-profile-link').forEach(btn => btn.addEventListener('click', (e) => showPlayerProfile(e.currentTarget.dataset.playerId)));
            }

             async function loadMyPortfolio(userId) {
                const { data, error } = await supabaseClient.from('wallets').select('*, coins(*)').eq('user_id', userId).gt('amount', 0.00000001);
                if (error) { portfolioListEl.innerHTML = '<p class="text-red-500">Error.</p>'; return; }
                handlePortfolioUpdate(data);
            }
            function subscribeToMyPortfolio(userId) {
                setupRealtimeSubscription(`my-portfolio-${userId}`, 'wallets', `user_id=eq.${userId}`, (payload) => loadMyPortfolio(userId));
                 setupRealtimeSubscription('portfolio-coin-prices', 'coins', null, (payload) => {
                     const coinId = payload.new?.id || payload.old?.id; if (!coinId) return;
                     if (payload.new && payload.eventType !== 'DELETE') allCoinsCache.set(coinId, payload.new);
                     else if (payload.eventType === 'DELETE' && payload.old) allCoinsCache.delete(coinId);
                      if (document.getElementById('page-portafolio').classList.contains('active')) handlePortfolioUpdate(Array.from(myPortfolioCache.values()));
                 });
            }
            function handlePortfolioUpdate(walletData) {
                portfolioListEl.innerHTML = ''; myPortfolioCache.clear();
                if (!walletData || walletData.length === 0) { portfolioListEl.innerHTML = '<p class="text-gray-400">Sin monedas.</p>'; return; }
                let portfolioItems = walletData.map(wallet => {
                    const coinData = wallet.coins || allCoinsCache.get(wallet.coin_id);
                    const currentValue = coinData ? wallet.amount * coinData.current_price : 0;
                     const portfolioItem = { ...wallet, coinData: coinData, currentValue: currentValue };
                    myPortfolioCache.set(wallet.coin_id, portfolioItem);
                    return portfolioItem;
                }).filter(item => item.coinData);
                portfolioItems.sort((a, b) => b.currentValue - a.currentValue);
                portfolioItems.forEach(item => {
                    const coinName = `${item.coinData.name} (${item.coinData.symbol})`;
                    const itemEl = document.createElement('div'); itemEl.className = 'flex justify-between items-center bg-item-bg p-3 rounded-lg';
                    itemEl.innerHTML = `<div><div class="font-semibold">${coinName}</div><div class="text-sm text-gray-400">${formatNumber(item.amount, 4)} tokens</div></div><div class="text-right"><div class="font-semibold">${formatCurrency(item.currentValue)}</div><div class="text-sm text-gray-400">Valor</div></div>`;
                    portfolioListEl.appendChild(itemEl);
                });
            }

            function subscribeToMemecoins() {
                // Carga inicial
                async function loadInitialCoins() {
                    const { data, error } = await supabaseClient.from('coins').select('*').order('created_at', { ascending: false });
                    if (error) { memecoinListEl.innerHTML = '<p class="text-red-500">Error.</p>'; return; }
                    allCoinsCache.clear(); data.forEach(c => allCoinsCache.set(c.id, c)); updateMemecoinListUI();
                }
                loadInitialCoins();
                // Suscripción a cambios
                setupRealtimeSubscription('all-coins', 'coins', null, (payload) => {
                     const eventType = payload.eventType; const record = eventType === 'DELETE' ? payload.old : payload.new; const coinId = record?.id; if (!coinId) return;
                     if (eventType === 'INSERT' || eventType === 'UPDATE') allCoinsCache.set(coinId, record);
                     else if (eventType === 'DELETE') allCoinsCache.delete(coinId);
                     updateMemecoinListUI();
                });
            }

            // --- LÓGICA DE GRÁFICA (CHART.JS) ---
            function initChart() { /* ... (sin cambios) ... */
                if (typeof ChartjsPluginAnnotation !== 'undefined') Chart.register(ChartjsPluginAnnotation);
                const ctx = document.getElementById('coin-chart-modal').getContext('2d');
                chartGradient = createChartGradient(ctx, 'green');
                 if (memecoinChart) memecoinChart.destroy();
                memecoinChart = new Chart(ctx, { /* ... (configuración sin cambios) ... */
                     type: 'line',
                    data: { labels: [], datasets: [ { label: 'Precio', data: [], borderColor: '#14F195', borderWidth: 2, pointRadius: 0, tension: 0.3, fill: true, backgroundColor: chartGradient, yAxisID: 'yPrice', }, { label: 'Volumen', data: [], backgroundColor: 'rgba(153, 69, 255, 0.4)', type: 'bar', yAxisID: 'yVolume', } ] },
                    options: { responsive: true, maintainAspectRatio: false, scales: { yPrice: { type: 'linear', position: 'left', ticks: { color: '#9CA3AF', callback: (value) => formatPrice(value) }, grid: { color: 'rgba(255, 255, 255, 0.1)' } }, yVolume: { type: 'linear', position: 'right', ticks: { display: false }, grid: { display: false }, beginAtZero: true }, x: { ticks: { display: false }, grid: { color: 'rgba(255, 255, 255, 0.1)' } } }, plugins: { legend: { display: false }, tooltip: { enabled: true, mode: 'index', intersect: false, callbacks: { label: (context) => context.datasetIndex === 0 ? `Precio: ${formatPrice(context.parsed.y)}` : `Volumen: ${formatCurrency(context.parsed.y)}` } }, annotation: { annotations: {} } } }
                });
             }
             function createChartGradient(ctx, color) { /* ... (sin cambios) ... */
                const gradient = ctx.createLinearGradient(0, 0, 0, 400); gradient.addColorStop(0, color === 'green' ? 'rgba(20, 241, 149, 0.5)' : 'rgba(239, 68, 68, 0.5)'); gradient.addColorStop(1, 'rgba(31, 41, 55, 0)'); return gradient;
             }
             function updateChart(coinData) { /* ... (sin cambios, usa nombres SQL) ... */
                  if (!memecoinChart) return;
                const history = coinData.price_history?.slice(-50) || []; const volumeHistory = (coinData.volume_history || []).slice(-50);
                let newColor = '#14F195'; let newGradientColor = 'green';
                if (history.length > 1 && coinData.current_price < history[history.length - 2]) { newColor = '#EF4444'; newGradientColor = 'red'; }
                memecoinChart.data.datasets[0].borderColor = newColor; memecoinChart.data.datasets[0].backgroundColor = createChartGradient(memecoinChart.ctx, newGradientColor);
                memecoinChart.data.labels = history.map((_, i) => i + 1); memecoinChart.data.datasets[0].data = history; memecoinChart.data.datasets[1].data = volumeHistory;
                updateChartAnnotations(coinData.id);
                memecoinChart.update('none');
             }
            async function updateChartAnnotations(coinId) { /* ... (sin cambios, usa nombres SQL) ... */
                 if (!memecoinChart || !memecoinChart.options.plugins.annotation) return;
                let annotations = {};
                const { data: walletData, error } = await supabaseClient.from('wallets').select('trade_history').eq('user_id', currentUserId).eq('coin_id', coinId).single();
                if (!error && walletData && walletData.trade_history) {
                    const tradeHistory = walletData.trade_history || [];
                    tradeHistory.forEach((trade, index) => {
                         const isBuy = trade.type === 'buy'; annotations[`line${index}`] = { type: 'line', yMin: trade.price, yMax: trade.price, borderColor: isBuy ? 'rgba(34, 197, 94, 0.7)' : 'rgba(239, 68, 68, 0.7)', borderWidth: 2, borderDash: [6, 6], label: { content: isBuy ? `C` : `V`, enabled: true, position: index % 2 === 0 ? 'start' : 'end', backgroundColor: isBuy ? 'rgba(34, 197, 94, 0.7)' : 'rgba(239, 68, 68, 0.7)', font: { size: 9 }, color: 'white', padding: 2, borderRadius: 4 } };
                    });
                } else if (error && error.code !== 'PGRST116') console.error("Error fetching trade history:", error);
                memecoinChart.options.plugins.annotation.annotations = annotations;
             }

             function updateSelectedCoinPrice(price) { /* ... (sin cambios) ... */ modalCoinPriceEl.textContent = `${formatPrice(price)}`; }
             function selectCoin(coinId) { /* ... (sin cambios, usa nombres SQL) ... */
                  selectedCoinId = coinId; const coinData = allCoinsCache.get(coinId); if (!coinData) return;
                modalCoinNameEl.textContent = `${coinData.name} (${coinData.symbol})`; modalContractIdEl.textContent = `ID: ...${coinData.id.slice(-6)}`; updateSelectedCoinPrice(coinData.current_price); updateChart(coinData); showModal(chartModalEl);
                modalLiveBadgeEl.classList.toggle('hidden', !coinData.is_live); viewLiveBtnEl.classList.toggle('hidden', !coinData.is_live);
                Array.from(memecoinListEl.children).forEach(child => { child.classList.toggle('bg-solana-purple/50', child.dataset.coinId === coinId); child.classList.toggle('bg-item-bg', child.dataset.coinId !== coinId); });
             }

            // --- ACCIONES DEL JUGADOR ---

             function updateMemecoinListUI() { /* ... (sin cambios, usa nombres SQL) ... */
                  memecoinListEl.innerHTML = ''; const filterText = coinFilterInputEl.value.toLowerCase(); let coinsToShow = Array.from(allCoinsCache.values());
                if (filterText) coinsToShow = coinsToShow.filter(coin => coin.name.toLowerCase().includes(filterText) || coin.symbol.toLowerCase().includes(filterText));
                 // Ordenar por fecha de creación (ya viene así de Supabase)
                if (coinsToShow.length === 0) { memecoinListEl.innerHTML = `<p class="text-gray-400 text-center mt-10">${filterText ? 'No encontradas.' : 'Lanza la primera!'}</p>`; return; }
                coinsToShow.forEach(coin => {
                     const priceHistory = coin.price_history || []; const priceChange = priceHistory.length > 1 ? (coin.current_price - priceHistory[priceHistory.length - 2]) / priceHistory[priceHistory.length - 2] : 0; const changeColor = priceChange >= 0 ? 'text-green-500' : 'text-red-500'; const changeIcon = priceChange >= 0 ? '▲' : '▼'; const placeholderImg = `https://placehold.co/40x40/${coin.id.slice(0,6)}/FFFFFF?text=${coin.symbol}`; const creatorUsername = allPlayersCache.get(coin.creator_id)?.username || '...?';
                    const coinEl = document.createElement('button'); coinEl.className = `w-full text-left p-3 rounded-lg transition duration-200 ${selectedCoinId === coin.id ? 'bg-solana-purple/50' : 'bg-item-bg hover:bg-item-hover'}`; coinEl.dataset.coinId = coin.id;
                    coinEl.innerHTML = `<div class="flex justify-between items-center"><div class="flex items-center gap-3 overflow-hidden mr-2"><img src="${coin.image_url || placeholderImg}" onerror="this.src='${placeholderImg}'" alt="${coin.name}" class="w-10 h-10 rounded-full bg-gray-700 flex-shrink-0"><div class="truncate"><span class="text-lg font-bold block truncate">${coin.name} (${coin.symbol})</span><span class="text-xs text-gray-400 block" title="${coin.creator_id}">Creador: ${creatorUsername}</span></div>${coin.is_live ? `<span class="animate-livePulse text-xs font-bold bg-red-600 text-white px-2 py-0.5 rounded-md ml-2 flex-shrink-0">LIVE</span>` : ''}${coin.x_url ? `<div class="x-popover-container ml-1 flex-shrink-0"><i class="ph ph-x text-gray-400 hover:text-x-blue cursor-pointer text-base"></i><div class="x-popover glassmorphism p-3 rounded-lg shadow-xl text-xs">...</div></div>` : ''}</div><div class="text-right flex-shrink-0"><span class="text-lg font-mono block">${formatPrice(coin.current_price)}</span><span class="text-sm font-semibold ${changeColor}">${changeIcon} ${formatNumber(isNaN(priceChange) ? 0 : priceChange * 100)}%</span></div></div><div class="grid grid-cols-3 sm:grid-cols-5 gap-2 mt-3 text-xs text-center"><div><span class="text-gray-400 block">MC</span><span class="font-semibold">${formatCurrency(coin.market_cap || 0)}</span></div><div><span class="text-gray-400 block">Liq</span><span class="font-semibold">${formatCurrency(coin.s_sol_pool || 0)}</span></div><div><span class="text-gray-400 block">Vol</span><span class="font-semibold">${formatCurrency(coin.volume || 0)}</span></div><div><span class="text-gray-400 block">Hold</span><span class="font-semibold">${formatNumber(coin.holder_count || 0, 0)}</span></div><div><span class="text-gray-400 block">Follow</span><span class="font-semibold">${formatNumber(coin.followers || 0, 0)}</span></div></div>`;
                    coinEl.addEventListener('click', () => selectCoin(coin.id)); memecoinListEl.appendChild(coinEl);
                    if (coin.id === selectedCoinId) { updateChart(coin); updateSelectedCoinPrice(coin.current_price); modalCoinNameEl.textContent = `${coin.name} (${coin.symbol})`; modalContractIdEl.textContent = `ID: ...${coin.id.slice(-6)}`; modalLiveBadgeEl.classList.toggle('hidden', !coin.is_live); viewLiveBtnEl.classList.toggle('hidden', !coin.is_live); }
                });
             }
             coinFilterInputEl.addEventListener('input', updateMemecoinListUI);
             // updateMyAssetsUI eliminada

             // --- LÓGICA DE BOTS (DEFINICIÓN) ---
             // simulateBotTrade necesita nombres SQL y devuelve nombres SQL
            function simulateBotTrade(coinData, playerAction, forceBuyProbability = null) {
                // Usar nombres SQL en la desestructuración
                let {
                    bot_ssol_pool, bot_token_pool, s_sol_pool, token_pool,
                    volume, price_history, volume_history, creator_id,
                    creator_fees_ssol, creator_fees_token, market_cap, all_time_high, all_time_low,
                    followers
                } = coinData;

                 if (creator_id === 'bot') return { updates: {}, creatorFollowsIncrement: 0 }; // Asumiendo 'bot' no es un UUID válido

                let buyProbability = 0.6;
                if (playerAction === 'proactive' && forceBuyProbability !== null) {
                    buyProbability = forceBuyProbability;
                }

                const isBuy = (Math.random() < buyProbability);

                let ssolTraded = 0;
                let ssolForTrade = 0;
                let tokensForTrade = 0;
                let tokensReceived = 0;
                let ssolReceived = 0;
                let finalSsolPool = s_sol_pool;
                let finalTokenPool = token_pool;
                let newCreatorFeesSsol = creator_fees_ssol || 0;
                let newCreatorFeesToken = creator_fees_token || 0;
                let newFollowers = followers || 0;
                let creatorFollowsIncrement = 0;

                if (isBuy) {
                    const ssolToSpend = (Math.pow(Math.random(), 2) * (bot_ssol_pool * 0.1));
                    if (ssolToSpend < 0.00000001 || bot_ssol_pool < ssolToSpend) return { updates: {}, creatorFollowsIncrement: 0 };

                    bot_ssol_pool -= ssolToSpend;
                    ssolTraded = ssolToSpend;

                    const totalFee = ssolToSpend * TOTAL_FEE;
                    ssolForTrade = ssolToSpend - totalFee;

                    // Evitar división por cero o pools negativos
                    if(s_sol_pool <= 0 || token_pool <= 0) return { updates: {}, creatorFollowsIncrement: 0 };

                    const k = s_sol_pool * token_pool;
                    const newSsolPool_k = s_sol_pool + ssolForTrade;
                    // Evitar división por cero
                    finalTokenPool = newSsolPool_k > 0 ? k / newSsolPool_k : 0;
                    tokensReceived = token_pool - finalTokenPool;

                    finalSsolPool = newSsolPool_k;
                    newCreatorFeesSsol += totalFee; // Las fees van al creador

                    bot_token_pool += tokensReceived;

                    newFollowers++;
                    if (Math.random() < 0.1) {
                        creatorFollowsIncrement = 1;
                    }

                } else { // Venta del bot
                    const sellPercentage = (Math.pow(Math.random(), 2) * 0.1); // Vende hasta 10%
                    const tokensToSell = bot_token_pool * sellPercentage;
                    if (tokensToSell < 0.00000001 || bot_token_pool < tokensToSell) return { updates: {}, creatorFollowsIncrement: 0 };

                    bot_token_pool -= tokensToSell;

                    const totalFee = tokensToSell * TOTAL_FEE;
                    tokensForTrade = tokensToSell - totalFee;

                     // Evitar división por cero o pools negativos
                    if(s_sol_pool <= 0 || token_pool <= 0) return { updates: {}, creatorFollowsIncrement: 0 };

                    const k = s_sol_pool * token_pool;
                    const newTokenPool_k = token_pool + tokensForTrade;
                     // Evitar división por cero
                    finalSsolPool = newTokenPool_k > 0 ? k / newTokenPool_k : 0;
                    ssolReceived = s_sol_pool - finalSsolPool;
                    ssolTraded = ssolReceived;

                    finalTokenPool = newTokenPool_k;
                    newCreatorFeesToken += totalFee; // Las fees van al creador

                    bot_ssol_pool += ssolReceived;
                }

                // Evitar división por cero en el precio
                const newPrice = finalTokenPool > 0 ? finalSsolPool / finalTokenPool : (coinData.current_price || 0); // Mantener precio anterior si pool se vacía
                const newAllTimeHigh = Math.max(all_time_high || 0, newPrice);
                const newAllTimeLow = Math.min(all_time_low || 999999, newPrice);
                const newMarketCap = newPrice * (finalTokenPool + bot_token_pool); // Incluir tokens del bot en MC
                 // Asegurarse de que price_history es un array
                const currentPriceHistory = Array.isArray(price_history) ? price_history : [];
                const newHistory = [...currentPriceHistory, newPrice].slice(-50);
                 // Asegurarse de que volume_history es un array
                const currentVolumeHistory = Array.isArray(volume_history) ? volume_history : [];
                const newVolumeHistory = [...currentVolumeHistory, ssolTraded].slice(-50);

                const newVolume = (volume || 0) + ssolTraded;

                // Retornar objeto con nombres SQL
                const updates = {
                    s_sol_pool: finalSsolPool,
                    token_pool: finalTokenPool,
                    bot_ssol_pool: bot_ssol_pool,
                    bot_token_pool: bot_token_pool,
                    current_price: newPrice,
                    price_history: newHistory,
                    volume_history: newVolumeHistory,
                    volume: newVolume,
                    market_cap: newMarketCap,
                    creator_fees_ssol: newCreatorFeesSsol,
                    creator_fees_token: newCreatorFeesToken,
                    all_time_high: newAllTimeHigh,
                    all_time_low: newAllTimeLow,
                };

                if (isBuy) updates.followers = newFollowers;

                // Devolver también el incremento para manejarlo fuera
                return { updates, creatorFollowsIncrement };
            }

            // proactiveBotLoop adaptado para Supabase (update, nombres SQL)
             async function proactiveBotLoop() {
                 try { // Envolver en try...catch para que el loop no se detenga por un error
                    if (allCoinsCache.size > 0 && allPlayersCache.size > 0) {
                        for (const [coinId, coin] of allCoinsCache.entries()) {
                             // Usar nombres SQL
                            const allTimeHigh = coin.all_time_high || coin.price_history?.[0] || 0;
                            const currentPrice = coin.current_price;
                            let buyProbability = 0.5;
                            let tradeProbability = 0.0;

                             if (allTimeHigh > 0 && currentPrice > 0 && (currentPrice / allTimeHigh) < 0.2) { // Evitar división por cero
                                 tradeProbability = 0.1;
                                 buyProbability = 0.05;
                             } else {
                                 const priceHistory = coin.price_history || [];
                                 let priceChange = 0;
                                 if (priceHistory.length > 1) {
                                     const prevPrice = priceHistory[priceHistory.length - 2];
                                     if (prevPrice > 0) priceChange = (coin.current_price - prevPrice) / prevPrice;
                                 }

                                 const creator = allPlayersCache.get(coin.creator_id);
                                 const creatorFollowers = creator ? (creator.social_followers || 0) : 0;
                                 const creatorFollowerScore = Math.min(1.0, creatorFollowers / 1000);

                                 const priceChangeScore = Math.min(1, priceChange / 0.1);
                                 const volumeRatio = (coin.s_sol_pool > 0) ? (coin.volume || 0) / coin.s_sol_pool : 0;
                                 const volumeScore = Math.min(1, volumeRatio / 10);
                                 const holderScore = Math.min(1, (coin.last_holder_count_change || 0) / 5);
                                 const liveScore = coin.is_live ? Math.min(1.0, (coin.live_viewers || 0) / 1000) : 0.0;
                                 const followersScore = Math.min(1, (coin.followers || 0) / 1000);

                                 const totalHypeScore = (priceChangeScore + volumeScore + holderScore + (followersScore*1.5) + (liveScore * 5) + (creatorFollowerScore * 2)) / 11.5;
                                 tradeProbability = totalHypeScore * 0.7;

                                 if (priceChange > 0) buyProbability = 0.5 + (totalHypeScore * 0.45);
                                 else buyProbability = 0.5 - ((1 - totalHypeScore) * 0.45);
                             }

                             // Probabilidad de seguir a un jugador aleatorio
                            if (Math.random() < 0.01) {
                                try {
                                    const playerIds = Array.from(allPlayersCache.keys()).filter(id => id !== currentUserId); // No seguirse a sí mismo
                                    if(playerIds.length > 0) {
                                        const randomPlayerId = playerIds[Math.floor(Math.random() * playerIds.length)];
                                        if (randomPlayerId && randomPlayerId !== coin.creator_id) {
                                             // Usar RPC sería más robusto para incrementos concurrentes
                                             const { error } = await supabaseClient.rpc('increment_followers', { user_uuid: randomPlayerId, amount: 1 });
                                             if(error) console.warn("Bot failed to follow (RPC):", error.message);
                                             else console.log("Bot followed player:", randomPlayerId);
                                        }
                                    }
                                } catch(e) { console.warn("Bot failed to follow random player (client):", e.message); }
                            }

                            if (Math.random() < tradeProbability) {
                                // --- INICIO: Lógica de transacción simulada (NO ATÓMICA) ---
                                // 1. Obtener datos actuales de la moneda (podrían estar obsoletos)
                                const currentCoinData = allCoinsCache.get(coinId); // Usar caché
                                if (!currentCoinData) continue;

                                // 2. Simular el trade del bot
                                const { updates: botUpdates, creatorFollowsIncrement } = simulateBotTrade(currentCoinData, 'proactive', buyProbability);

                                if (Object.keys(botUpdates).length > 0) {
                                    // 3. Actualizar la moneda
                                    botUpdates.last_holder_count_change = 0; // Resetear contador
                                    const { error: coinUpdateError } = await supabaseClient
                                        .from('coins')
                                        .update(botUpdates)
                                        .eq('id', coinId);

                                    if (coinUpdateError) {
                                        console.warn(`Bot failed coin update for ${coinId}:`, coinUpdateError.message);
                                    } else {
                                         // 4. Incrementar seguidores del creador si aplica (después de actualizar moneda)
                                        if (creatorFollowsIncrement > 0) {
                                            const { error: followError } = await supabaseClient.rpc('increment_followers', { user_uuid: currentCoinData.creator_id, amount: creatorFollowsIncrement });
                                            if (followError) console.warn(`Bot failed creator follow for ${coinId}:`, followError.message);
                                        }
                                    }
                                }
                                // --- FIN: Lógica de transacción simulada ---
                            }
                        }
                    }
                 } catch (loopError) {
                     console.error("Error inside proactiveBotLoop:", loopError);
                 } finally {
                     // Programar la siguiente ejecución incluso si hubo un error
                     setTimeout(proactiveBotLoop, 5000 + Math.random() * 2000); // Añadir algo de aleatoriedad
                 }
            }


            // --- OTRAS FUNCIONES (ADAPTADAS Y SIN CAMBIOS) ---
            // Crear Moneda
            createCoinFormEl.addEventListener('submit', async (e) => { /* ... (adaptado, sin cambios funcionales) ... */
                  e.preventDefault();
                const name = coinNameEl.value.trim(); const symbol = coinSymbolEl.value.trim().toUpperCase(); const imageUrl = coinImageUrlEl.value.trim(); const xUrl = coinXUrlEl.value.trim(); const initialSsol = parseFloat(coinInitialSsolEl.value); const initialTokens = parseFloat(coinInitialTokensEl.value);
                if (!name || !symbol || isNaN(initialSsol) || isNaN(initialTokens) || initialSsol <= 0 || initialTokens <= 0) { showMessage("Completa los campos."); return; }
                const launchCost = 0.01; const totalCost = launchCost + initialSsol;
                if (!currentUserData || currentUserData.s_sol_balance < totalCost) { showMessage(`Fondos insuficientes (${formatNumber(totalCost)} sSOL req).`); return; }
                const createBtn = createCoinFormEl.querySelector('button[type="submit"]'); createBtn.disabled = true; createBtn.textContent = 'Lanzando...';
                try {
                    const { error: balanceError } = await supabaseClient.from('players').update({ s_sol_balance: currentUserData.s_sol_balance - totalCost }).eq('user_id', currentUserId);
                    if (balanceError) throw new Error(`Balance: ${balanceError.message}`);
                    currentUserData.s_sol_balance -= totalCost;
                    const price = initialSsol / initialTokens; const placeholderImgUrl = `https://placehold.co/40x40/random/FFFFFF?text=${symbol}`;
                    const { data: newCoinData, error: coinError } = await supabaseClient.from('coins').insert({ name, symbol, creator_id: currentUserId, image_url: imageUrl || placeholderImgUrl, x_url: xUrl || '', s_sol_pool: initialSsol, token_pool: initialTokens, current_price: price, price_history: [price], volume_history: [0], all_time_high: price, all_time_low: price, market_cap: initialSsol * 2, followers: (currentUserData.social_followers || 0) + 1 }).select().single();
                    if (coinError) { await supabaseClient.from('players').update({ s_sol_balance: currentUserData.s_sol_balance + totalCost }).eq('user_id', currentUserId); currentUserData.s_sol_balance += totalCost; throw new Error(`Coin: ${coinError.message}`); }
                    const newCoinId = newCoinData.id;
                    const { error: updateContractIdError } = await supabaseClient.from('coins').update({ contract_id: newCoinId }).eq('id', newCoinId); if (updateContractIdError) console.warn("Could not backfill contract_id:", updateContractIdError.message);
                    const { error: walletError } = await supabaseClient.from('wallets').insert({ user_id: currentUserId, coin_id: newCoinId, amount: initialTokens, trade_history: [] });
                     if (walletError) { console.error("Wallet insert error:", walletError); showMessage("Moneda creada, error en wallet."); }
                    hideModal(createCoinModalEl); showMessage(`¡${name} (${symbol}) lanzada!`); createCoinFormEl.reset(); showPage('page-portafolio');
                } catch (error) { showMessage(error.message); } finally { createBtn.disabled = false; createBtn.textContent = 'Lanzar (Costo: 0.01 sSOL + Liq.)'; }
             });
            // Compra
             buyFormEl.addEventListener('submit', async (e) => { /* ... (adaptado, sin cambios funcionales) ... */
                  e.preventDefault(); const ssolToSpend = parseFloatStrict(buyAmountEl.value); if (!selectedCoinId || isNaN(ssolToSpend) || ssolToSpend <= 0) return showMessage("Monto inválido.");
                 buyAmountEl.disabled = true; const buyButton = buyFormEl.querySelector('button[type="submit"]'); buyButton.disabled = true; buyButton.textContent = 'Procesando...';
                try {
                     const { data: rpcData, error: rpcError } = await supabaseClient.rpc('handle_buy', { p_user_id: currentUserId, p_coin_id: selectedCoinId, p_ssol_to_spend: ssolToSpend });
                    if (rpcData?.success) { showMessage(`¡Compraste ${formatNumber(rpcData.tokensReceived, 4)} ${allCoinsCache.get(selectedCoinId)?.symbol}! (RPC)`); currentUserData.s_sol_balance -= ssolToSpend; ssolBalanceEl.textContent = `${formatNumber(currentUserData.s_sol_balance)} sSOL`; }
                     else if (rpcError || rpcData?.error) { console.warn("RPC handle_buy failed, using fallback:", rpcError || rpcData.error); await buySequentially(ssolToSpend); }
                     else throw new Error("Respuesta inesperada de compra.");
                    buyAmountEl.value = '';
                } catch (error) { showMessage(`Compra: ${error.message}`); } finally { buyAmountEl.disabled = false; buyButton.disabled = false; buyButton.textContent = 'Comprar'; }
             });
             // Venta
             sellFormEl.addEventListener('submit', async (e) => { /* ... (adaptado, sin cambios funcionales) ... */
                 e.preventDefault(); const tokensToSell = parseFloatStrict(sellAmountEl.value); if (!selectedCoinId || isNaN(tokensToSell) || tokensToSell <= 0) return showMessage("Monto inválido.");
                 sellAmountEl.disabled = true; const sellButton = sellFormEl.querySelector('button[type="submit"]'); sellButton.disabled = true; sellButton.textContent = 'Procesando...';
                try { await sellSequentially(tokensToSell); sellAmountEl.value = ''; }
                 catch (error) { showMessage(`Venta: ${error.message}`); }
                 finally { sellAmountEl.disabled = false; sellButton.disabled = false; sellButton.textContent = 'Vender'; }
             });
             // Botones % venta
            document.querySelectorAll('.sell-percent-btn').forEach(btn => { /* ... (sin cambios) ... */
                btn.addEventListener('click', () => { const percent = parseFloat(btn.dataset.percent); const walletItem = myPortfolioCache.get(selectedCoinId); if (walletItem) { const amountToSell = (walletItem.amount * percent).toFixed(2); sellAmountEl.value = amountToSell; } else { showMessage("No tienes esta moneda."); sellAmountEl.value = '0'; } });
             });
            // Compra Secuencial (Helper)
            async function buySequentially(ssolToSpend) { /* ... (adaptado, sin cambios funcionales) ... */
                  const { data: playerData, error: playerError } = await supabaseClient.from('players').select('s_sol_balance, social_followers').eq('user_id', currentUserId).single(); const { data: coinData, error: coinError } = await supabaseClient.from('coins').select('*').eq('id', selectedCoinId).single(); const { data: walletData, error: walletError } = await supabaseClient.from('wallets').select('amount, trade_history').eq('user_id', currentUserId).eq('coin_id', selectedCoinId).single();
                if (playerError || coinError || (walletError && walletError.code !== 'PGRST116')) throw new Error(`Lectura: ${playerError?.message || coinError?.message || walletError?.message}`); if (!playerData || !coinData) throw new Error("Datos no encontrados."); if (playerData.s_sol_balance < ssolToSpend) throw new Error("sSOL insuficiente.");
                const { updates: botUpdates, creatorFollowsIncrement: botCreatorFollows } = simulateBotTrade(coinData, 'reactive_buy'); let coinDataAfterBot = { ...coinData, ...botUpdates };
                const ssolTraded = ssolToSpend; const totalFee = ssolToSpend * TOTAL_FEE; const ssolForTrade = ssolToSpend - totalFee; if(coinDataAfterBot.s_sol_pool <= 0 || coinDataAfterBot.token_pool <= 0) throw new Error("Pool inválida."); const k = coinDataAfterBot.s_sol_pool * coinDataAfterBot.token_pool; const newSsolPool_k = coinDataAfterBot.s_sol_pool + ssolForTrade; if(newSsolPool_k <= 0) throw new Error("Pool inválida post-trade."); const newTokenPool = k / newSsolPool_k; const tokensReceived = coinDataAfterBot.token_pool - newTokenPool; const finalSsolPool = newSsolPool_k; const newPrice = finalSsolPool / newTokenPool;
                if (tokensReceived <= 0) throw new Error("No se recibieron tokens.");
                const newAllTimeHigh = Math.max(coinDataAfterBot.all_time_high || 0, newPrice); const newAllTimeLow = Math.min(coinDataAfterBot.all_time_low || 999999, newPrice); const newMarketCap = newPrice * (newTokenPool + coinDataAfterBot.bot_token_pool); const currentPriceHistory = Array.isArray(coinDataAfterBot.price_history) ? coinDataAfterBot.price_history : []; const newHistory = [...currentPriceHistory, newPrice].slice(-50); const currentVolumeHistory = Array.isArray(coinDataAfterBot.volume_history) ? coinDataAfterBot.volume_history : []; const newVolumeHistory = [...currentVolumeHistory, ssolTraded].slice(-50); const newVolume = (coinDataAfterBot.volume || 0) + ssolTraded; const newCreatorFeesSsol = (coinDataAfterBot.creator_fees_ssol || 0) + totalFee;
                let newHolderCount = coinDataAfterBot.holder_count || 0; let holderChange = 0; let newFollowers = coinDataAfterBot.followers || 0; let playerCreatorFollows = 0; const currentTokens = walletData ? walletData.amount : 0;
                if (currentTokens < 0.00000001) { newHolderCount++; holderChange = 1; newFollowers++; playerCreatorFollows = 1; } const newLastHolderCountChange = (coinDataAfterBot.last_holder_count_change || 0) + holderChange;
                const currentTradeHistory = walletData?.trade_history || []; const updatedTradeHistory = [...currentTradeHistory, { type: 'buy', price: newPrice, amountSsol: ssolToSpend, amountToken: tokensReceived, coinId: selectedCoinId, timestamp: new Date().toISOString() }].slice(-50);
                const { error: playerUpdateError } = await supabaseClient.from('players').update({ s_sol_balance: playerData.s_sol_balance - ssolToSpend }).eq('user_id', currentUserId); if (playerUpdateError) throw new Error(`Player: ${playerUpdateError.message}`); currentUserData.s_sol_balance -= ssolToSpend;
                const { error: walletUpdateError } = await supabaseClient.from('wallets').upsert({ user_id: currentUserId, coin_id: selectedCoinId, amount: currentTokens + tokensReceived, trade_history: updatedTradeHistory }); if (walletUpdateError) throw new Error(`Wallet: ${walletUpdateError.message}`);
                if (playerCreatorFollows > 0 || botCreatorFollows > 0) { const totalFollowIncrement = playerCreatorFollows + botCreatorFollows; const { error: followError } = await supabaseClient.rpc('increment_followers', { user_uuid: coinData.creator_id, amount: totalFollowIncrement }); if(followError) console.warn("Fallo follow creador:", followError.message); } delete botUpdates.creatorFollowsIncrement;
                const { error: coinUpdateError } = await supabaseClient.from('coins').update({ ...botUpdates, s_sol_pool: finalSsolPool, token_pool: newTokenPool, current_price: newPrice, price_history: newHistory, volume: newVolume, volume_history: newVolumeHistory, market_cap: newMarketCap, holder_count: newHolderCount, last_holder_count_change: newLastHolderCountChange, creator_fees_ssol: newCreatorFeesSsol, all_time_high: newAllTimeHigh, all_time_low: newAllTimeLow, followers: newFollowers }).eq('id', selectedCoinId); if (coinUpdateError) throw new Error(`Coin: ${coinUpdateError.message}`);
                showMessage(`¡Compra! ${formatNumber(tokensReceived, 4)} ${coinData.symbol} a ~${formatPrice(newPrice)}`);
             }
             // Venta Secuencial (Helper)
            async function sellSequentially(tokensToSell) { /* ... (adaptado, sin cambios funcionales) ... */
                 const { data: playerData, error: playerError } = await supabaseClient.from('players').select('s_sol_balance').eq('user_id', currentUserId).single(); const { data: coinData, error: coinError } = await supabaseClient.from('coins').select('*').eq('id', selectedCoinId).single(); const { data: walletData, error: walletError } = await supabaseClient.from('wallets').select('amount, trade_history').eq('user_id', currentUserId).eq('coin_id', selectedCoinId).single();
                if (playerError || coinError || walletError) throw new Error(`Lectura: ${playerError?.message || coinError?.message || walletError?.message}`); if (!playerData || !coinData || !walletData) throw new Error("Datos no encontrados."); if (walletData.amount < tokensToSell) throw new Error("Tokens insuficientes.");
                const { updates: botUpdates, creatorFollowsIncrement: botCreatorFollows } = simulateBotTrade(coinData, 'reactive_sell'); let coinDataAfterBot = { ...coinData, ...botUpdates };
                const totalFee = tokensToSell * TOTAL_FEE; const tokensForTrade = tokensToSell - totalFee; if(coinDataAfterBot.s_sol_pool <= 0 || coinDataAfterBot.token_pool <= 0) throw new Error("Pool inválida."); const k = coinDataAfterBot.s_sol_pool * coinDataAfterBot.token_pool; const newTokenPool_k = coinDataAfterBot.token_pool + tokensForTrade; if(newTokenPool_k <= 0) throw new Error("Pool inválida post-trade."); const newSsolPool = k / newTokenPool_k; const ssolReceived = coinDataAfterBot.s_sol_pool - newSsolPool; const finalTokenPool = newTokenPool_k; const ssolTraded = ssolReceived;
                if (ssolReceived < 0.00000001) throw new Error("Liquidez baja.");
                const newPrice = newSsolPool / finalTokenPool; const newAllTimeHigh = Math.max(coinDataAfterBot.all_time_high || 0, newPrice); const newAllTimeLow = Math.min(coinDataAfterBot.all_time_low || 999999, newPrice); const newMarketCap = newPrice * (finalTokenPool + coinDataAfterBot.bot_token_pool); const currentPriceHistory = Array.isArray(coinDataAfterBot.price_history) ? coinDataAfterBot.price_history : []; const newHistory = [...currentPriceHistory, newPrice].slice(-50); const currentVolumeHistory = Array.isArray(coinDataAfterBot.volume_history) ? coinDataAfterBot.volume_history : []; const newVolumeHistory = [...currentVolumeHistory, ssolTraded].slice(-50); const newVolume = (coinDataAfterBot.volume || 0) + ssolTraded; const newCreatorFeesToken = (coinDataAfterBot.creator_fees_token || 0) + totalFee;
                let newHolderCount = coinDataAfterBot.holder_count || 0; let holderChange = 0; const currentTokens = walletData.amount; const newAmountInWallet = currentTokens - tokensToSell; if (newAmountInWallet < 0.00000001 && currentTokens >= 0.00000001) { newHolderCount--; holderChange = -1; } const newLastHolderCountChange = (coinDataAfterBot.last_holder_count_change || 0) + holderChange;
                const currentTradeHistory = walletData.trade_history || []; const updatedTradeHistory = [...currentTradeHistory, { type: 'sell', price: newPrice, amountSsol: ssolReceived, amountToken: tokensToSell, coinId: selectedCoinId, timestamp: new Date().toISOString() }].slice(-50);
                const { error: playerUpdateError } = await supabaseClient.rpc('increment_balance', { user_uuid: currentUserId, amount: ssolReceived }); if (playerUpdateError) throw new Error(`Player: ${playerUpdateError.message}`); currentUserData.s_sol_balance += ssolReceived;
                const { error: walletUpdateError } = await supabaseClient.from('wallets').update({ amount: newAmountInWallet, trade_history: updatedTradeHistory }).eq('user_id', currentUserId).eq('coin_id', selectedCoinId); if (walletUpdateError) throw new Error(`Wallet: ${walletUpdateError.message}`);
                if (botCreatorFollows > 0) { const { error: followError } = await supabaseClient.rpc('increment_followers', { user_uuid: coinData.creator_id, amount: botCreatorFollows }); if(followError) console.warn("Fallo follow creador (venta):", followError.message); } delete botUpdates.creatorFollowsIncrement;
                const { error: coinUpdateError } = await supabaseClient.from('coins').update({ ...botUpdates, s_sol_pool: newSsolPool, token_pool: finalTokenPool, current_price: newPrice, price_history: newHistory, volume: newVolume, volume_history: newVolumeHistory, market_cap: newMarketCap, holder_count: newHolderCount, last_holder_count_change: newLastHolderCountChange, creator_fees_token: newCreatorFeesToken, all_time_high: newAllTimeHigh, all_time_low: newAllTimeLow }).eq('id', selectedCoinId); if (coinUpdateError) throw new Error(`Coin: ${coinUpdateError.message}`);
                showMessage(`¡Vendiste ${formatNumber(tokensToSell, 4)} ${coinData.symbol} por ${formatNumber(ssolReceived)} sSOL!`);
            }
             // Enviar sSOL
             sendSsolFormEl.addEventListener('submit', async (e) => { /* ... (adaptado, sin cambios funcionales) ... */
                 e.preventDefault(); const amountToSend = parseFloat(sendSsolAmountEl.value); if (!targetPlayerId || isNaN(amountToSend) || amountToSend <= 0) return showMessage("Monto inválido."); if (!currentUserData || currentUserData.s_sol_balance < amountToSend) return showMessage("sSOL insuficiente.");
                 const sendButton = sendSsolFormEl.querySelector('button[type="submit"]'); sendButton.disabled = true; sendButton.textContent = 'Enviando...';
                 try {
                     const { error: sendError } = await supabaseClient.from('players').update({ s_sol_balance: currentUserData.s_sol_balance - amountToSend }).eq('user_id', currentUserId); if (sendError) throw new Error(`Envío: ${sendError.message}`); currentUserData.s_sol_balance -= amountToSend;
                     const { error: receiveError } = await supabaseClient.rpc('increment_balance', { user_uuid: targetPlayerId, amount: amountToSend });
                     if (receiveError) { await supabaseClient.from('players').update({ s_sol_balance: currentUserData.s_sol_balance + amountToSend }).eq('user_id', currentUserId); currentUserData.s_sol_balance += amountToSend; throw new Error(`Recepción: ${receiveError.message}`); }
                     showMessage(`¡Enviaste ${formatNumber(amountToSend)} sSOL a ${allPlayersCache.get(targetPlayerId)?.username || '...'}!`); hideModal(sendSsolModalEl); sendSsolFormEl.reset();
                 } catch (error) { showMessage(error.message); } finally { sendButton.disabled = false; sendButton.textContent = 'Confirmar Envío'; }
             });
             // showCreatorDashboard
             function showCreatorDashboard() { /* ... (adaptado, sin cambios funcionales) ... */
                 creatorCoinsListEl.innerHTML = ''; let hasCoins = false;
                 const myCoins = Array.from(allCoinsCache.values()).filter(coin => coin.creator_id === currentUserId).sort((a, b) => (new Date(b.created_at) || 0) - (new Date(a.created_at) || 0));
                 myCoins.forEach(coin => {
                     hasCoins = true; const itemEl = document.createElement('div'); itemEl.className = 'bg-item-hover p-3 rounded-lg';
                     itemEl.innerHTML = `<div class="flex justify-between items-center mb-3"><span class="font-semibold text-lg">${coin.name} (${coin.symbol})</span><button data-coin-id="${coin.id}" class="go-live-btn ${coin.is_live ? 'bg-gray-600' : 'bg-red-600 hover:bg-red-700'} text-white font-bold py-2 px-3 rounded-md text-sm transition"> ${coin.is_live ? 'EN VIVO' : 'Ir en Vivo'} </button></div><div class="bg-gray-700/50 p-3 rounded-lg"><h4 class="font-semibold mb-2">Comisiones Ganadas (Totales: 0.3%)</h4><div class="text-sm text-gray-300">sSOL: <span id="fee-ssol-${coin.id}">${formatNumber(coin.creator_fees_ssol, 6)}</span></div><div class="text-sm text-gray-300">${coin.symbol}: <span id="fee-token-${coin.id}">${formatNumber(coin.creator_fees_token, 2)}</span></div><button data-coin-id="${coin.id}" class="claim-fee-btn w-full mt-2 bg-solana-green text-gray-900 font-bold py-2 px-3 rounded-md text-sm hover:bg-opacity-80 transition">Reclamar</button></div>`;
                     creatorCoinsListEl.appendChild(itemEl);
                 });
                 if (!hasCoins) creatorCoinsListEl.innerHTML = '<p class="text-gray-400 text-center">No has creado monedas.</p>';
                 creatorCoinsListEl.querySelectorAll('.claim-fee-btn').forEach(btn => btn.addEventListener('click', (e) => claimFees(e.target.dataset.coinId, e.target)));
                 creatorCoinsListEl.querySelectorAll('.go-live-btn').forEach(btn => btn.addEventListener('click', (e) => toggleLive(e.target.dataset.coinId, e.target)));
                 showModal(creatorDashboardModalEl);
             }
             // claimFees
            async function claimFees(coinId, btn) { /* ... (adaptado, sin cambios funcionales) ... */
                 const coin = allCoinsCache.get(coinId); if (!coin || (coin.creator_fees_ssol < 0.00000001 && coin.creator_fees_token < 0.00000001)) return showMessage("No hay fees.");
                 btn.disabled = true; btn.textContent = '...'; const ssolToClaim = coin.creator_fees_ssol; const tokensToClaim = coin.creator_fees_token;
                 try {
                     const { error: resetError } = await supabaseClient.from('coins').update({ creator_fees_ssol: 0, creator_fees_token: 0 }).eq('id', coinId); if (resetError) throw new Error(`Reset: ${resetError.message}`);
                     const { error: ssolError } = await supabaseClient.rpc('increment_balance', { user_uuid: currentUserId, amount: ssolToClaim });
                     if (ssolError) { await supabaseClient.from('coins').update({ creator_fees_ssol: ssolToClaim, creator_fees_token: tokensToClaim }).eq('id', coinId); throw new Error(`sSOL: ${ssolError.message}`); } currentUserData.s_sol_balance += ssolToClaim;
                     if (tokensToClaim > 0) { const { error: tokenError } = await supabaseClient.rpc('increment_wallet_amount', { p_user_id: currentUserId, p_coin_id: coinId, p_amount: tokensToClaim }); if (tokenError) { console.error("Error claim tokens:", tokenError); showMessage("Error en tokens, sSOL reclamado."); } const walletItem = myPortfolioCache.get(coinId); if (walletItem) walletItem.amount += tokensToClaim; }
                     showMessage("¡Fees reclamadas!"); btn.textContent = "Reclamado"; document.getElementById(`fee-ssol-${coinId}`).textContent = formatNumber(0, 6); document.getElementById(`fee-token-${coinId}`).textContent = formatNumber(0, 2);
                 } catch (e) { showMessage(e.message); btn.disabled = false; btn.textContent = "Reclamar"; }
             }
             // toggleLive
             async function toggleLive(coinId, btn) { /* ... (adaptado, sin cambios funcionales) ... */
                  const coin = allCoinsCache.get(coinId); const newState = !coin.is_live; btn.disabled = true; btn.textContent = '...';
                 try {
                     const initialViewers = newState ? 50 + Math.floor(Math.random() * 50) : 0; const initialFollowers = newState ? (coin.followers || 0) + 5 + Math.floor(Math.random() * 10) : coin.followers;
                     const { error } = await supabaseClient.from('coins').update({ is_live: newState, live_viewers: initialViewers, followers: initialFollowers }).eq('id', coinId); if (error) throw error;
                     showMessage(newState ? "¡En vivo!" : "Directo finalizado."); btn.textContent = newState ? "EN VIVO" : "Ir en Vivo"; btn.classList.toggle('bg-gray-600', newState); btn.classList.toggle('bg-red-600', !newState);
                 } catch (e) { showMessage(`Live: ${e.message}`); } finally { btn.disabled = false; }
             }
             // showLiveStream
            function showLiveStream() { /* ... (sin cambios) ... */
                if (!selectedCoinId) return; const coin = allCoinsCache.get(selectedCoinId); if (!coin) return; liveCoinNameEl.textContent = `LIVE: ${coin.name}`; liveViewersEl.textContent = formatNumber(coin.live_viewers || 0, 0); showModal(liveStreamModalEl);
                 // Listener para cerrar si termina (simplificado, usar realtime channel sería mejor)
                 const liveCheckInterval = setInterval(async () => { if (!selectedCoinId) { clearInterval(liveCheckInterval); return; } const { data, error } = await supabaseClient.from('coins').select('is_live, live_viewers').eq('id', selectedCoinId).single(); if (error || !data || !data.is_live) { hideModal(liveStreamModalEl); clearInterval(liveCheckInterval); } else { liveViewersEl.textContent = formatNumber(data.live_viewers || 0, 0); } }, 5000); // Chequear cada 5 seg
            }
             // boostLiveStream
             async function boostLiveStream(level) { /* ... (adaptado, sin cambios funcionales) ... */
                 if (!selectedCoinId) return; let boostCost = 0, viewerBonus = 0, followerBonus = 0; switch (level) { case 'small': boostCost = 0.1; viewerBonus = 100 + Math.floor(Math.random() * 100); followerBonus = 10 + Math.floor(Math.random() * 20); break; case 'medium': boostCost = 1; viewerBonus = 500 + Math.floor(Math.random() * 500); followerBonus = 50 + Math.floor(Math.random() * 50); break; case 'large': boostCost = 10; viewerBonus = 2000 + Math.floor(Math.random() * 3000); followerBonus = 200 + Math.floor(Math.random() * 300); break; default: return showMessage("Nivel inválido."); }
                 if (!currentUserData || currentUserData.s_sol_balance < boostCost) return showMessage("sSOL insuficiente.");
                 const btn = document.querySelector(`.boost-live-btn[data-boost-level="${level}"]`); if (btn) { btn.disabled = true; btn.textContent = '...'; }
                 try {
                     const { error: balanceError } = await supabaseClient.from('players').update({ s_sol_balance: currentUserData.s_sol_balance - boostCost }).eq('user_id', currentUserId); if (balanceError) throw new Error(`Balance: ${balanceError.message}`); currentUserData.s_sol_balance -= boostCost;
                     const { error: boostError } = await supabaseClient.rpc('boost_coin_stats', { coin_uuid: selectedCoinId, viewer_inc: viewerBonus, follower_inc: followerBonus });
                     if (boostError) { await supabaseClient.from('players').update({ s_sol_balance: currentUserData.s_sol_balance + boostCost }).eq('user_id', currentUserId); currentUserData.s_sol_balance += boostCost; throw new Error(`Boost: ${boostError.message}`); }
                     showMessage(`¡Boost (${level}) aplicado!`);
                 } catch (e) { showMessage(e.message); } if (btn) { btn.disabled = false; btn.textContent = `Boost (${boostCost} sSOL)`; }
             }
             // Editar Perfil
            editSocialProfileFormEl.addEventListener('submit', async (e) => { /* ... (adaptado, sin cambios funcionales) ... */
                  e.preventDefault(); const username = socialUsernameInputEl.value.trim(); const avatarUrl = socialAvatarInputEl.value.trim(); if (!username) return showMessage("Usuario vacío.");
                  const saveBtn = editSocialProfileFormEl.querySelector('button[type="submit"]'); saveBtn.disabled = true;
                 try {
                     const { error } = await supabaseClient.from('players').update({ username: username, avatar_url: avatarUrl || `https://placehold.co/60/374151/FFFFFF?text=${username.slice(0,1)}` }).eq('user_id', currentUserId); if (error) throw error;
                     showMessage("Perfil actualizado."); hideModal(myProfileModalEl); if(currentUserData) { currentUserData.username = username; currentUserData.avatar_url = avatarUrl; }
                 } catch (error) { showMessage(`Perfil: ${error.message}`); } finally { saveBtn.disabled = false; }
             });
             // Crear Post
             createSocialPostFormEl.addEventListener('submit', async (e) => { /* ... (adaptado, sin cambios funcionales) ... */
                 e.preventDefault(); const postText = socialPostTextEl.value.trim(); if (!postText || !currentUserData) return;
                 const postButton = createSocialPostFormEl.querySelector('button[type="submit"]'); postButton.disabled = true;
                 try {
                     const { error } = await supabaseClient.from('social_posts').insert({ user_id: currentUserId, username: currentUserData.username, avatar_url: currentUserData.avatar_url, text: postText }); if (error) throw error;
                     showMessage("Post publicado."); hideModal(createSocialPostModalEl); createSocialPostFormEl.reset(); showPage('page-social');
                 } catch (error) { showMessage(`Post: ${error.message}`); } finally { postButton.disabled = false; }
             });
             // Promocionar Post
             async function promotePost(postId, btn) { /* ... (adaptado, sin cambios funcionales) ... */
                 if (!currentUserData || currentUserData.s_sol_balance < PROMO_POST_COST) return showMessage(`sSOL insuficiente.`);
                 btn.disabled = true; btn.textContent = '...';
                 try {
                     const { error: balanceError } = await supabaseClient.from('players').update({ s_sol_balance: currentUserData.s_sol_balance - PROMO_POST_COST }).eq('user_id', currentUserId); if (balanceError) throw new Error(`Balance: ${balanceError.message}`); currentUserData.s_sol_balance -= PROMO_POST_COST;
                     const { error: postError } = await supabaseClient.from('social_posts').update({ boosted: true }).eq('id', postId).eq('user_id', currentUserId);
                     if (postError) { await supabaseClient.from('players').update({ s_sol_balance: currentUserData.s_sol_balance + PROMO_POST_COST }).eq('user_id', currentUserId); currentUserData.s_sol_balance += PROMO_POST_COST; throw new Error(`Post: ${postError.message}`); }
                     showMessage("¡Post promocionado!");
                 } catch (e) { showMessage(e.message); btn.disabled = false; btn.textContent = `Promocionar (0.2 sSOL)`; }
             }
             // Mostrar Perfil Otro Jugador
             async function showPlayerProfile(playerId) { /* ... (adaptado, sin cambios funcionales) ... */
                  if (playerId === currentUserId) { showMyProfileBtn.click(); return; }
                 selectedProfilePlayerId = playerId; const player = allPlayersCache.get(playerId); if (!player) return showMessage("Jugador no encontrado.");
                 playerProfileUsernameEl.textContent = player.username; playerProfileAvatarEl.src = player.avatar_url || 'https://placehold.co/60/374151/FFFFFF?text=P'; playerProfileFollowersEl.textContent = formatNumber(player.social_followers || 0, 0);
                 updateFollowButton();
                 playerProfilePostsEl.innerHTML = '<p class="text-gray-400 text-sm">Cargando...</p>'; playerProfileCoinsEl.innerHTML = '<p class="text-gray-400 text-sm">Cargando...</p>'; showModal(playerProfileModalEl);
                 const { data: posts, error: postsError } = await supabaseClient.from('social_posts').select('*').eq('user_id', playerId).order('created_at', { ascending: false }).limit(10);
                 if (postsError) playerProfilePostsEl.innerHTML = '<p class="text-red-500 text-sm">Error.</p>'; else if (!posts || posts.length === 0) playerProfilePostsEl.innerHTML = '<p class="text-gray-400 text-sm">Sin posts.</p>'; else { playerProfilePostsEl.innerHTML = ''; posts.forEach(post => { const postEl = document.createElement('div'); postEl.className = 'bg-item-hover p-3 rounded-lg text-sm'; postEl.innerHTML = `<p>${post.text}</p><p class="text-xs text-gray-500 mt-2">${new Date(post.created_at).toLocaleString()}</p>`; playerProfilePostsEl.appendChild(postEl); }); }
                 const { data: coins, error: coinsError } = await supabaseClient.from('coins').select('id, name, symbol, image_url').eq('creator_id', playerId).order('created_at', { ascending: false });
                 if (coinsError) playerProfileCoinsEl.innerHTML = '<p class="text-red-500 text-sm">Error.</p>'; else if (!coins || coins.length === 0) playerProfileCoinsEl.innerHTML = '<p class="text-gray-400 text-sm">No ha creado monedas.</p>'; else { playerProfileCoinsEl.innerHTML = ''; coins.forEach(coin => { const coinEl = document.createElement('div'); coinEl.className = 'bg-item-hover p-2 rounded-lg text-sm flex items-center gap-2'; coinEl.innerHTML = `<img src="${coin.image_url || 'https://placehold.co/24/718096/FFFFFF?text=' + coin.symbol}" alt="${coin.symbol}" class="w-6 h-6 rounded-full"><span>${coin.name} (${coin.symbol})</span>`; playerProfileCoinsEl.appendChild(coinEl); }); }
             }
             // updateFollowButton
             function updateFollowButton() { /* ... (sin cambios) ... */
                  if (!selectedProfilePlayerId) return; if (myFollowsCache.has(selectedProfilePlayerId)) { followPlayerBtn.textContent = "Dejar de Seguir"; followPlayerBtn.classList.remove('bg-x-blue', 'hover:bg-opacity-80'); followPlayerBtn.classList.add('bg-gray-600', 'hover:bg-gray-700'); } else { followPlayerBtn.textContent = "Seguir"; followPlayerBtn.classList.add('bg-x-blue', 'hover:bg-opacity-80'); followPlayerBtn.classList.remove('bg-gray-600', 'hover:bg-gray-700'); } followPlayerBtn.disabled = false;
             }
             // Seguir/Dejar de seguir
            followPlayerBtn.addEventListener('click', async () => { /* ... (adaptado, sin cambios funcionales) ... */
                  if (!selectedProfilePlayerId) return; followPlayerBtn.disabled = true; const isFollowing = myFollowsCache.has(selectedProfilePlayerId); const followerIncrement = isFollowing ? -1 : 1;
                 try {
                     let currentFollows = Array.from(myFollowsCache); if (isFollowing) currentFollows = currentFollows.filter(id => id !== selectedProfilePlayerId); else currentFollows.push(selectedProfilePlayerId);
                     const { error: myUpdateError } = await supabaseClient.from('players').update({ following: currentFollows }).eq('user_id', currentUserId); if (myUpdateError) throw new Error(`My update: ${myUpdateError.message}`);
                     const { error: targetUpdateError } = await supabaseClient.rpc('increment_followers', { user_uuid: selectedProfilePlayerId, amount: followerIncrement });
                     if (targetUpdateError) { if (isFollowing) currentFollows.push(selectedProfilePlayerId); else currentFollows = currentFollows.filter(id => id !== selectedProfilePlayerId); await supabaseClient.from('players').update({ following: currentFollows }).eq('user_id', currentUserId); throw new Error(`Target update: ${targetUpdateError.message}`); }
                     if (isFollowing) myFollowsCache.delete(selectedProfilePlayerId); else myFollowsCache.add(selectedProfilePlayerId);
                     updateFollowButton(); const targetPlayer = allPlayersCache.get(selectedProfilePlayerId); if (targetPlayer) { targetPlayer.social_followers = (targetPlayer.social_followers || 0) + followerIncrement; playerProfileFollowersEl.textContent = formatNumber(targetPlayer.social_followers, 0); }
                 } catch (e) { showMessage("Error follow: " + e.message); updateFollowButton(); }
             });
             // Lanzar Moneda SocialFi
             launchSocialFiCoinBtn.addEventListener('click', () => { /* ... (sin cambios) ... */
                 const player = currentUserData; if (player && (player.social_followers || 0) >= 50) { coinNameEl.value = `${player.username || 'Mi'} Coin`; coinSymbolEl.value = (player.username || 'ME').slice(0,5).toUpperCase(); coinImageUrlEl.value = player.avatar_url || ''; hideModal(myProfileModalEl); showModal(createCoinModalEl); } else { showMessage("Necesitas 50+ seguidores."); }
             });
             // PnL Modal
             async function showPnlModal() { /* ... (adaptado, sin cambios funcionales) ... */
                 if (!selectedCoinId) return showMessage("Selecciona moneda."); const coin = allCoinsCache.get(selectedCoinId); if (!coin) return showMessage("Moneda no encontrada.");
                 const { data: walletData, error } = await supabaseClient.from('wallets').select('amount, trade_history').eq('user_id', currentUserId).eq('coin_id', selectedCoinId).single();
                 if (error && error.code !== 'PGRST116') return showMessage("Error wallet: " + error.message); if (!walletData || !walletData.trade_history || walletData.trade_history.length === 0) return showMessage("Sin historial.");
                 const tradeHistory = walletData.trade_history || []; const currentTokens = walletData.amount || 0;
                 let totalSsolInvested = 0; let totalSsolRealized = 0; let totalTokensBought = 0;
                 tradeHistory.forEach(trade => { if (trade.type === 'buy') { totalSsolInvested += trade.amountSsol; totalTokensBought += trade.amountToken; } else if (trade.type === 'sell') { totalSsolRealized += trade.amountSsol; } });
                 const avgBuyPrice = totalTokensBought > 0 ? totalSsolInvested / totalTokensBought : 0; const currentValue = currentTokens * coin.current_price;
                 const totalPnL_sSOL = (totalSsolRealized + currentValue) - totalSsolInvested; const totalPnL_Percent = totalSsolInvested > 0 ? (totalPnL_sSOL / totalSsolInvested) * 100 : 0;
                 pnlCoinSymbolEl.textContent = coin.symbol; pnlTotalSsolEl.textContent = `${totalPnL_sSOL >= 0 ? '+' : ''}${formatNumber(totalPnL_sSOL, 4)} sSOL`; pnlTotalPercentEl.textContent = `${totalPnL_Percent >= 0 ? '+' : ''}${formatNumber(totalPnL_Percent, 2)}%`;
                 pnlTotalSsolEl.className = `text-2xl font-semibold mb-6 ${totalPnL_sSOL >= 0 ? 'pnl-value-positive' : 'pnl-value-negative'}`; pnlTotalPercentEl.className = `text-4xl font-bold mb-1 ${totalPnL_sSOL >= 0 ? 'pnl-value-positive' : 'pnl-value-negative'}`;
                 pnlTotalInvestedEl.textContent = formatNumber(totalSsolInvested, 4); pnlTotalRealizedEl.textContent = formatNumber(totalSsolRealized, 4); pnlCurrentValueEl.textContent = formatNumber(currentValue, 4); pnlCurrentTokensEl.textContent = formatNumber(currentTokens, 4); pnlAvgBuyPriceEl.textContent = formatPrice(avgBuyPrice);
                 showModal(pnlCardModalEl);
             }


            // --- INICIAR ---
            checkInitialSession(); // Verifica si hay sesión y arranca
            initChart();
             // Iniciar el loop del bot después de un breve retraso inicial
             setTimeout(proactiveBotLoop, 7000);

        } // --- FIN: ENVOLTORIO MAIN ASYNC ---

        main().catch(err => {
            console.error("Error fatal:", err);
            const messageModalEl = document.getElementById('message-modal'); const messageTextEl = document.getElementById('message-text');
            if (messageTextEl && messageModalEl && typeof showModal === 'function') { messageTextEl.textContent = `Error: ${err.message}.`; showModal(messageModalEl); }
            else { alert(`Error: ${err.message}.`); }
        });

    </script>
</body>
</html>

