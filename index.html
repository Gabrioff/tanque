<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solana Memecoin Simulator</title>
    <!-- Cargar Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Cargar Chart.js (para las grÃ¡ficas) -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- ConfiguraciÃ³n de Tailwind para modo oscuro -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                    colors: {
                        'solana-green': '#14F195',
                        'solana-purple': '#9945FF',
                    }
                }
            }
        }
    </script>
    <style>
        /* Estilo para la barra de scroll */
        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }
        ::-webkit-scrollbar-track {
            background: #2d3748; /* gray-800 */
        }
        ::-webkit-scrollbar-thumb {
            background: #4a5568; /* gray-600 */
            border-radius: 3px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #718096; /* gray-500 */
        }
        .glassmorphism {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        /* Estilo para Modales */
        .modal {
            transition: opacity 0.25s ease, visibility 0.25s ease;
        }
        .modal-content {
            transition: transform 0.25s ease;
        }
    </style>
</head>
<body class="bg-gray-900 text-white font-sans antialiased flex flex-col min-h-screen">

    <!-- Encabezado -->
    <header class="bg-gray-800 shadow-lg sticky top-0 z-30">
        <nav class="container mx-auto px-4 py-3 flex justify-between items-center">
            <h1 class="text-xl lg:text-2xl font-bold text-solana-green">
                ðŸš€ Solana Memecoin Sim
            </h1>
            <div class="flex items-center space-x-4">
                <div class="text-right">
                    <div class="text-sm text-gray-400">Balance</div>
                    <div id="ssol-balance" class="text-lg font-semibold text-solana-green">2.00 sSOL</div>
                </div>
            </div>
        </nav>
        <div id="player-id-banner" class="bg-solana-purple text-center py-1 px-4 text-xs font-mono">
            Cargando tu ID de jugador...
        </div>
    </header>

    <!-- Contenido Principal -->
    <main class="container mx-auto p-4 flex-grow flex flex-col lg:flex-row gap-4">

        <!-- Columna Izquierda: Controles y Portafolio -->
        <aside class="w-full lg:w-1/3 flex flex-col gap-4">
            
            <!-- BotÃ³n para Crear Moneda -->
            <div class="glassmorphism rounded-lg shadow-xl p-4">
                 <button id="show-create-modal-btn" class="w-full bg-solana-purple hover:bg-opacity-80 text-white font-bold py-3 px-4 rounded-md transition duration-200 text-lg">
                    âœ¨ Lanzar Nueva Memecoin
                </button>
            </div>

            <!-- Mi Portafolio -->
            <div class="glassmorphism rounded-lg shadow-xl p-4 flex-grow flex flex-col">
                <h2 class="text-xl font-semibold mb-3 border-b border-gray-700 pb-2">Mi Portafolio</h2>
                <div id="portfolio-list" class="flex-grow overflow-y-auto h-48 lg:h-auto space-y-2 pr-2">
                    <p class="text-gray-400">AÃºn no tienes monedas.</p>
                </div>
            </div>

            <!-- Trades Recientes -->
            <div class="glassmorphism rounded-lg shadow-xl p-4 flex-grow flex flex-col">
                <h2 class="text-xl font-semibold mb-3 border-b border-gray-700 pb-2">Trades Recientes</h2>
                <div id="top-trades-list" class="flex-grow overflow-y-auto h-48 lg:h-auto space-y-2 pr-2">
                    <p class="text-gray-400">Esperando trades...</p>
                </div>
            </div>

            <!-- Jugadores en la Sala -->
            <div class="glassmorphism rounded-lg shadow-xl p-4 flex-grow flex flex-col">
                <h2 class="text-xl font-semibold mb-3 border-b border-gray-700 pb-2">Jugadores en la Sala</h2>
                <div id="players-list" class="flex-grow overflow-y-auto h-48 lg:h-auto space-y-2 pr-2">
                    <p class="text-gray-400">Cargando jugadores...</p>
                </div>
            </div>
        </aside>

        <!-- Columna Derecha: Lista de Monedas -->
        <section class="w-full lg:w-2/3 glassmorphism rounded-lg shadow-xl p-4 flex flex-col">
            <h2 class="text-xl font-semibold mb-3 border-b border-gray-700 pb-2">Mercado de Memecoins</h2>
            <div id="memecoin-list" class="flex-grow overflow-y-auto space-y-2 pr-2 h-96 lg:h-[80vh]">
                <p class="text-gray-400">No hay monedas. Â¡Lanza la primera!</p>
            </div>
        </section>

    </main>

    <!-- Modal para Mensajes Simples -->
    <div id="message-modal" class="modal fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 hidden opacity-0 visibility-hidden">
        <div class="modal-content glassmorphism p-6 rounded-lg shadow-2xl max-w-sm mx-auto text-center transform scale-95">
            <p id="message-text" class="text-lg mb-4">Mensaje</p>
            <button id="close-message-btn" class="bg-solana-purple hover:bg-opacity-80 text-white font-bold py-2 px-4 rounded-md transition duration-200">
                Cerrar
            </button>
        </div>
    </div>
    
    <!-- Modal para Crear Moneda -->
    <div id="create-coin-modal" class="modal fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-40 hidden opacity-0 visibility-hidden p-4">
        <div class="modal-content glassmorphism p-6 rounded-lg shadow-2xl max-w-md w-full text-center transform scale-95 overflow-y-auto max-h-full">
            <div class="flex justify-between items-center mb-3 border-b border-gray-700 pb-2">
                <h2 class="text-xl font-semibold">Lanzar Nueva Memecoin</h2>
                <button id="close-create-modal-btn" class="text-gray-400 hover:text-white text-2xl">&times;</button>
            </div>
            <form id="create-coin-form" class="space-y-3 text-left">
                <div>
                    <label for="coin-name" class="block text-sm font-medium text-gray-300">Nombre (Ej: DogeWifHat)</label>
                    <input type="text" id="coin-name" required class="w-full mt-1 px-3 py-2 bg-gray-800 border border-gray-700 rounded-md focus:outline-none focus:ring-2 focus:ring-solana-purple" maxlength="20">
                </div>
                <div>
                    <label for="coin-symbol" class="block text-sm font-medium text-gray-300">SÃ­mbolo (Ej: WIF)</label>
                    <input type="text" id="coin-symbol" required class="w-full mt-1 px-3 py-2 bg-gray-800 border border-gray-700 rounded-md focus:outline-none focus:ring-2 focus:ring-solana-purple" maxlength="5" autocapitalize="characters">
                </div>
                <div>
                    <label for="coin-image-url" class="block text-sm font-medium text-gray-300">URL de Imagen</glabel>
                    <input type="url" id="coin-image-url" placeholder="https://..." class="w-full mt-1 px-3 py-2 bg-gray-800 border border-gray-700 rounded-md focus:outline-none focus:ring-2 focus:ring-solana-purple">
                </div>
                <div class="grid grid-cols-2 gap-2">
                     <div>
                        <label for="coin-initial-ssol" class="block text-sm font-medium text-gray-300">sSOL Inicial (Liq.)</label>
                        <input type="number" id="coin-initial-ssol" step="0.01" min="0.01" required placeholder="0.1" class="w-full mt-1 px-3 py-2 bg-gray-800 border border-gray-700 rounded-md focus:outline-none focus:ring-2 focus:ring-solana-purple">
                    </div>
                     <div>
                        <label for="coin-initial-tokens" class="block text-sm font-medium text-gray-300">Tokens (Liq.)</label>
                        <input type="number" id="coin-initial-tokens" step="1000" min="1000" required placeholder="1000000" class="w-full mt-1 px-3 py-2 bg-gray-800 border border-gray-700 rounded-md focus:outline-none focus:ring-2 focus:ring-solana-purple">
                    </div>
                </div>
                <button type="submit" class="w-full bg-solana-purple hover:bg-opacity-80 text-white font-bold py-2 px-4 rounded-md transition duration-200">
                    Lanzar (Costo: 0.01 sSOL + Liq.)
                </button>
            </form>
        </div>
    </div>
    
    <!-- Modal para GrÃ¡fica y Trading -->
    <div id="chart-modal" class="modal fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-40 hidden opacity-0 visibility-hidden p-4">
        <div class="modal-content glassmorphism p-6 rounded-lg shadow-2xl max-w-3xl w-full text-center transform scale-95 overflow-y-auto max-h-full">
            
            <div class="flex justify-between items-center mb-3 border-b border-gray-700 pb-2">
                 <h2 id="modal-coin-name" class="text-2xl font-bold text-solana-green"></h2>
                <button id="close-chart-modal-btn" class="text-gray-400 hover:text-white text-2xl">&times;</button>
            </div>

            <p id="modal-coin-price" class="text-xl font-mono text-center text-gray-300 mb-4">$0.00</p>
            
            <!-- Canvas para la grÃ¡fica -->
            <div class="relative h-48 md:h-72 mb-4">
                <canvas id="coin-chart-modal"></canvas>
            </div>

            <!-- Formularios de Compra/Venta -->
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <!-- Comprar -->
                <form id="buy-form-modal" class="space-y-2 glassmorphism p-4 rounded-lg">
                    <label for="buy-amount-ssol-modal" class="block text-sm font-medium text-gray-300">Gastar (sSOL) - Fee 0.3%</label>
                    <input type="number" id="buy-amount-ssol-modal" step="0.01" min="0.01" placeholder="0.1" class="w-full px-3 py-2 bg-gray-800 border border-gray-700 rounded-md focus:outline-none focus:ring-2 focus:ring-solana-green" required>
                    <button type="submit" class="w-full bg-solana-green hover:bg-opacity-80 text-gray-900 font-bold py-2 px-4 rounded-md transition duration-200">
                        Comprar
                    </button>
                </form>
                
                <!-- Vender -->
                <form id="sell-form-modal" class="space-y-2 glassmorphism p-4 rounded-lg">
                    <label for="sell-amount-token-modal" class="block text-sm font-medium text-gray-300">Vender (Tokens) - Fee 0.3%</label>
                    <input type="number" id="sell-amount-token-modal" step="1" min="1" placeholder="1000" class="w-full px-3 py-2 bg-gray-800 border border-gray-700 rounded-md focus:outline-none focus:ring-2 focus:ring-red-500" required>
                    <button type="submit" class="w-full bg-red-600 hover:bg-opacity-80 text-white font-bold py-2 px-4 rounded-md transition duration-200">
                        Vender
                    </button>
                </form>
            </div>
        </div>
    </div>


    <!-- Scripts de Firebase y LÃ³gica del Juego -->
    <script type="module">
        // Importar funciones de Firebase
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { 
            getAuth, 
            signInAnonymously, 
            signInWithCustomToken, 
            onAuthStateChanged 
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { 
            getFirestore, 
            doc, 
            getDoc, 
            setDoc, 
            collection, 
            onSnapshot, 
            runTransaction, 
            serverTimestamp,
            query,
            updateDoc,
            orderBy,
            limit
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // --- INICIO: ENVOLTORIO MAIN ASYNC ---
        async function main() {
        
            // --- CONFIGURACIÃ“N DE FIREBASE ---
            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-memecoin-sim';
            let firebaseConfig;
            
            // --- REFERENCIAS AL DOM (MODALES) ---
            const messageModalEl = document.getElementById('message-modal');
            const messageTextEl = document.getElementById('message-text');
            const closeMessageBtn = document.getElementById('close-message-btn');
            
            const createCoinModalEl = document.getElementById('create-coin-modal');
            const showCreateModalBtn = document.getElementById('show-create-modal-btn');
            const closeCreateModalBtn = document.getElementById('close-create-modal-btn');

            const chartModalEl = document.getElementById('chart-modal');
            const closeChartModalBtn = document.getElementById('close-chart-modal-btn');
            const modalCoinNameEl = document.getElementById('modal-coin-name');
            const modalCoinPriceEl = document.getElementById('modal-coin-price');
            
            // --- FUNCIONES DE MODAL ---
            function showModal(modalEl) {
                modalEl.classList.remove('hidden');
                setTimeout(() => {
                    modalEl.classList.remove('opacity-0', 'visibility-hidden');
                    modalEl.querySelector('.modal-content').classList.remove('scale-95');
                }, 10);
            }

            function hideModal(modalEl) {
                modalEl.classList.add('opacity-0');
                modalEl.querySelector('.modal-content').classList.add('scale-95');
                setTimeout(() => {
                    modalEl.classList.add('hidden', 'visibility-hidden');
                }, 250);
            }

            function showMessage(text) {
                messageTextEl.textContent = text;
                showModal(messageModalEl);
            }
            
            closeMessageBtn.addEventListener('click', () => hideModal(messageModalEl));
            showCreateModalBtn.addEventListener('click', () => showModal(createCoinModalEl));
            closeCreateModalBtn.addEventListener('click', () => hideModal(createCoinModalEl));
            closeChartModalBtn.addEventListener('click', () => {
                hideModal(chartModalEl);
                selectedCoinId = null; // Deseleccionar al cerrar
                // Resetear la lista para quitar el highlight
                const coinElements = memecoinListEl.querySelectorAll('button');
                coinElements.forEach(child => {
                    child.classList.remove('bg-solana-purple/50');
                    child.classList.add('bg-gray-800');
                });
            });


            try {
                firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
            } catch (e) {
                console.error("Error parsing Firebase config:", e);
                showMessage("Error crÃ­tico: La configuraciÃ³n de Firebase es invÃ¡lida.");
                return;
            }

            if (!firebaseConfig.apiKey) {
                showMessage("Error crÃ­tico: La configuraciÃ³n de Firebase estÃ¡ incompleta.");
                return;
            }
            
            const app = initializeApp(firebaseConfig);
            const db = getFirestore(app);
            const auth = getAuth(app);

            // --- VARIABLES GLOBALES DEL JUEGO ---
            let currentUserId = null;
            let selectedCoinId = null;
            let memecoinChart = null;
            let allCoinsCache = new Map(); // Cache para datos de monedas
            let myPortfolioCache = new Map(); // Cache para el portafolio
            
            // --- COMISIONES ---
            const LP_FEE = 0.0025; // 0.25% para el pool
            const CREATOR_FEE = 0.0005; // 0.05% para el creador
            
            // Referencia a la sala de juego global (pÃºblica)
            const roomRef = collection(db, 'artifacts', appId, 'public', 'data', 'game_rooms', 'global_room', 'data');
            const playersRef = collection(db, 'artifacts', appId, 'public', 'data', 'game_rooms', 'global_room', 'players');
            const tradesRef = collection(db, 'artifacts', appId, 'public', 'data', 'game_rooms', 'global_room', 'trades');

            // --- REFERENCIAS AL DOM (JUEGO) ---
            const ssolBalanceEl = document.getElementById('ssol-balance');
            const playerIdBannerEl = document.getElementById('player-id-banner');
            const playersListEl = document.getElementById('players-list');
            const portfolioListEl = document.getElementById('portfolio-list');
            const topTradesListEl = document.getElementById('top-trades-list'); 
            const memecoinListEl = document.getElementById('memecoin-list');

            // Formularios (dentro de modales)
            const createCoinFormEl = document.getElementById('create-coin-form');
            const coinNameEl = document.getElementById('coin-name');
            const coinSymbolEl = document.getElementById('coin-symbol');
            const coinImageUrlEl = document.getElementById('coin-image-url');
            const coinInitialSsolEl = document.getElementById('coin-initial-ssol');
            const coinInitialTokensEl = document.getElementById('coin-initial-tokens');
            
            const buyFormEl = document.getElementById('buy-form-modal');
            const sellFormEl = document.getElementById('sell-form-modal');
            const buyAmountEl = document.getElementById('buy-amount-ssol-modal');
            const sellAmountEl = document.getElementById('sell-amount-token-modal');

            // --- FUNCIONES DE UTILIDAD ---
            function formatPrice(value) {
                return new Intl.NumberFormat('en-US', { 
                    style: 'currency', 
                    currency: 'USD',
                    minimumFractionDigits: 2,
                    maximumFractionDigits: 10
                }).format(value);
            }

            function formatCurrency(value) {
                 return new Intl.NumberFormat('en-US', { 
                    style: 'currency', 
                    currency: 'USD',
                    minimumFractionDigits: 2,
                    maximumFractionDigits: 2
                }).format(value);
            }
            
            function formatNumber(value) {
                return new Intl.NumberFormat('en-US', { maximumFractionDigits: 2 }).format(value);
            }

            // --- LÃ“GICA DE AUTENTICACIÃ“N Y JUEGO ---
            
            async function initAuth() {
                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        currentUserId = user.uid;
                        playerIdBannerEl.textContent = `Tu ID de Jugador: ${currentUserId}`;
                        await joinGame(user.uid);
                    } else {
                        try {
                            if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                                await signInWithCustomToken(auth, __initial_auth_token);
                            } else {
                                await signInAnonymously(auth);
                            }
                        } catch (error) {
                            console.error("Error de autenticaciÃ³n:", error);
                            showMessage("Error al conectar con el servidor. Por favor, recarga.");
                        }
                    }
                });
            }
            
            async function joinGame(userId) {
                const playerRef = doc(playersRef, userId);
                const playerDoc = await getDoc(playerRef);

                if (!playerDoc.exists()) {
                    await setDoc(playerRef, {
                        userId: userId,
                        sSOL_balance: 2, // Balance inicial de 2 sSOL
                        joinedAt: serverTimestamp()
                    });
                }
                
                listenForPlayerBalance(userId);
                listenForPlayers();
                listenForMemecoins();
                listenForMyPortfolio(userId);
                listenForTopTrades(); 
            }
            
            // --- LISTENERS DE FIRESTORE (TIEMPO REAL) ---

            function listenForPlayerBalance(userId) {
                const playerRef = doc(playersRef, userId);
                onSnapshot(playerRef, (doc) => {
                    if (doc.exists()) {
                        const data = doc.data();
                        ssolBalanceEl.textContent = `${formatNumber(data.sSOL_balance)} sSOL`;
                    }
                });
            }

            function listenForPlayers() {
                onSnapshot(query(playersRef), (snapshot) => {
                    playersListEl.innerHTML = ''; 
                    if (snapshot.empty) {
                        playersListEl.innerHTML = '<p class="text-gray-400">EstÃ¡s solo aquÃ­...</p>';
                        return;
                    }
                    snapshot.forEach(doc => {
                        const player = doc.data();
                        const isMe = player.userId === currentUserId;
                        const playerEl = document.createElement('div');
                        playerEl.className = `flex justify-between items-center p-2 rounded ${isMe ? 'bg-solana-purple/30' : 'bg-gray-800'}`;
                        playerEl.innerHTML = `
                            <span class="font-mono text-xs truncate ${isMe ? 'text-solana-green' : ''}" title="${player.userId}">
                                ${isMe ? 'Tu (...' + player.userId.slice(-6) + ')' : '...' + player.userId.slice(-6)}
                            </span>
                            <span class="text-sm font-semibold">${formatNumber(player.sSOL_balance)} sSOL</span>
                        `;
                        playersListEl.appendChild(playerEl);
                    });
                });
            }
            
            function listenForTopTrades() {
                const q = query(tradesRef, orderBy("timestamp", "desc"), limit(15));
                onSnapshot(q, (snapshot) => {
                    topTradesListEl.innerHTML = '';
                    if (snapshot.empty) {
                        topTradesListEl.innerHTML = '<p class="text-gray-400">Esperando trades...</p>';
                        return;
                    }
                    snapshot.forEach(doc => {
                        const trade = doc.data();
                        const isBuy = trade.type === 'buy';
                        const color = isBuy ? 'text-green-500' : 'text-red-500';
                        const tradeEl = document.createElement('div');
                        tradeEl.className = 'flex justify-between items-center text-xs bg-gray-800 p-2 rounded';
                        tradeEl.innerHTML = `
                            <div>
                                <span class="font-bold ${color}">${isBuy ? 'COMPRA' : 'VENTA'}</span>
                                <span class="font-semibold text-white ml-1">${trade.coinSymbol}</span>
                            </div>
                            <div class="text-right font-mono">
                                <div>${formatNumber(trade.amountSsol)} sSOL</div>
                                <div class="text-gray-400">${formatNumber(trade.amountToken)} tkn</div>
                            </div>
                        `;
                        topTradesListEl.appendChild(tradeEl);
                    });
                });
            }

            function listenForMyPortfolio(userId) {
                const portfolioRef = collection(playersRef, userId, 'wallet');
                onSnapshot(query(portfolioRef), (snapshot) => {
                    portfolioListEl.innerHTML = '';
                    myPortfolioCache.clear();
                    
                    if (snapshot.empty) {
                        portfolioListEl.innerHTML = '<p class="text-gray-400">AÃºn no tienes monedas.</p>';
                        return;
                    }

                    snapshot.forEach(doc => {
                        const coin = doc.data();
                        if (coin.amount < 0.01) return; // No mostrar saldos de polvo
                        
                        myPortfolioCache.set(doc.id, coin);
                        
                        const coinData = allCoinsCache.get(doc.id);
                        const coinName = coinData ? `${coinData.name} (${coinData.symbol})` : 'Moneda Desconocida';
                        const currentValue = coinData ? coin.amount * coinData.currentPrice : 0;
                        
                        const itemEl = document.createElement('div');
                        itemEl.className = 'flex justify-between items-center bg-gray-800 p-2 rounded';
                        itemEl.innerHTML = `
                            <div>
                                <div class="font-semibold">${coinName}</div>
                                <div class="text-sm text-gray-400">${formatNumber(coin.amount)} tokens</div>
                            </div>
                            <div class="text-right">
                                <div class="font-semibold">${formatCurrency(currentValue)}</div>
                                <div class="text-sm text-gray-400">Valor</div>
                            </div>
                        `;
                        portfolioListEl.appendChild(itemEl);
                    });
                });
            }

            function listenForMemecoins() {
                onSnapshot(query(roomRef), (snapshot) => {
                    memecoinListEl.innerHTML = '';
                    
                    if (snapshot.empty) {
                        memecoinListEl.innerHTML = '<p class="text-gray-400">No hay monedas. Â¡Lanza la primera!</p>';
                        allCoinsCache.clear(); // Limpiar cache si no hay monedas
                        return;
                    }
                    
                    const newCache = new Map();
                    const coins = [];
                    snapshot.forEach(doc => {
                        const coinData = { id: doc.id, ...doc.data() };
                        coins.push(coinData);
                        newCache.set(doc.id, coinData);
                    });
                    
                    allCoinsCache = newCache; // Actualizar cache

                    // Ordenar por Market Cap (mÃ¡s alto primero)
                    coins.sort((a, b) => (b.marketCap || 0) - (a.marketCap || 0));

                    coins.forEach(coin => {
                        const priceChange = coin.priceHistory.length > 1 ? (coin.currentPrice - coin.priceHistory[coin.priceHistory.length - 2]) / coin.priceHistory[coin.priceHistory.length - 2] : 0;
                        const changeColor = priceChange >= 0 ? 'text-green-500' : 'text-red-500';
                        const changeIcon = priceChange >= 0 ? 'â–²' : 'â–¼';
                        const placeholderImg = `https://placehold.co/40x40/${coin.id.slice(0,6)}/FFFFFF?text=${coin.symbol}`;

                        const coinEl = document.createElement('button');
                        coinEl.className = `w-full text-left p-3 rounded-lg transition duration-200 ${selectedCoinId === coin.id ? 'bg-solana-purple/50' : 'bg-gray-800 hover:bg-gray-700'}`;
                        coinEl.dataset.coinId = coin.id;
                        coinEl.innerHTML = `
                            <div class="flex justify-between items-center">
                                <div class="flex items-center gap-3">
                                    <img src="${coin.imageUrl || placeholderImg}" onerror="this.src='${placeholderImg}'" alt="${coin.name}" class="w-10 h-10 rounded-full bg-gray-700">
                                    <div>
                                        <span class="text-lg font-bold">${coin.name} (${coin.symbol})</span>
                                        <span class="text-xs text-gray-400 block" title="${coin.creatorId}">Creador: ...${coin.creatorId.slice(-6)}</span>
                                    </div>
                                </div>
                                <div class="text-right">
                                    <span class="text-lg font-mono">${formatPrice(coin.currentPrice)}</span>
                                    <span class="text-sm font-semibold ${changeColor}">${changeIcon} ${formatNumber(priceChange * 100)}%</span>
                                </div>
                            </div>
                            <div class="grid grid-cols-2 sm:grid-cols-4 gap-2 mt-3 text-xs text-center">
                                <div>
                                    <span class="text-gray-400 block">MC</span>
                                    <span class="font-semibold">${formatCurrency(coin.marketCap || 0)}</span>
                                </div>
                                <div>
                                    <span class="text-gray-400 block">Liquidez</span>
                                    <span class="font-semibold">${formatCurrency(coin.sSolPool || 0)}</span>
                                </div>
                                 <div>
                                    <span class="text-gray-400 block">Volumen</span>
                                    <span class="font-semibold">${formatCurrency(coin.volume || 0)}</span>
                                </div>
                                 <div>
                                    <span class="text-gray-400 block">Holders</span>
                                    <span class="font-semibold">${formatNumber(coin.holderCount || 0)}</span>
                                </div>
                            </div>
                            <div class="mt-2 pt-2 border-t border-gray-700 text-xs text-gray-400">
                                <span class="font-semibold text-gray-300">Comisiones Creador:</span> 
                                <span>${formatNumber(coin.creatorFeesSsol || 0)} sSOL</span> | 
                                <span>${formatNumber(coin.creatorFeesToken || 0)} ${coin.symbol}</span>
                            </div>
                        `;
                        coinEl.addEventListener('click', () => selectCoin(coin.id));
                        memecoinListEl.appendChild(coinEl);

                        // Si la moneda seleccionada se actualiza, actualiza el modal
                        if (coin.id === selectedCoinId) {
                            updateChart(coin);
                            updateSelectedCoinPrice(coin.currentPrice);
                            modalCoinNameEl.textContent = `${coin.name} (${coin.symbol})`;
                        }
                    });
                    
                    updatePortfolioValues();
                });
            }
            
            function updatePortfolioValues() {
                portfolioListEl.innerHTML = '';
                if (myPortfolioCache.size === 0) {
                     portfolioListEl.innerHTML = '<p class="text-gray-400">AÃºn no tienes monedas.</p>';
                     return;
                }
                
                myPortfolioCache.forEach((coin, coinId) => {
                    const coinData = allCoinsCache.get(coinId);
                    const coinName = coinData ? `${coinData.name} (${coinData.symbol})` : 'Moneda Desconocida';
                    const currentValue = coinData ? coin.amount * coinData.currentPrice : 0;
                    
                    const itemEl = document.createElement('div');
                    itemEl.className = 'flex justify-between items-center bg-gray-800 p-2 rounded';
                    itemEl.innerHTML = `
                        <div>
                            <div class="font-semibold">${coinName}</div>
                            <div class="text-sm text-gray-400">${formatNumber(coin.amount)} tokens</div>
                        </div>
                        <div class="text-right">
                            <div class="font-semibold">${formatCurrency(currentValue)}</div>
                            <div class="text-sm text-gray-400">Valor</div>
                        </div>
                    `;
                    portfolioListEl.appendChild(itemEl);
                });
            }
            
            // --- LÃ“GICA DE GRÃFICA (CHART.JS) ---

            function initChart() {
                const ctx = document.getElementById('coin-chart-modal').getContext('2d');
                
                memecoinChart = new Chart(ctx, {
                    type: 'line', // Tipo principal: lÃ­nea
                    data: {
                        labels: [],
                        datasets: [
                            {
                                label: 'Precio',
                                data: [],
                                borderColor: '#14F195',
                                borderWidth: 2,
                                pointRadius: 0,
                                tension: 0.3,
                                fill: false,
                                yAxisID: 'yPrice', // Asignar al eje Y de precio
                            },
                            {
                                label: 'Volumen',
                                data: [],
                                backgroundColor: 'rgba(153, 69, 255, 0.4)', // solana-purple con alpha
                                type: 'bar', // Tipo de este dataset: barras
                                yAxisID: 'yVolume', // Asignar al eje Y de volumen
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            yPrice: {
                                type: 'linear',
                                position: 'left',
                                ticks: { 
                                    color: '#9CA3AF',
                                    callback: (value) => formatPrice(value)
                                },
                                grid: { color: 'rgba(255, 255, 255, 0.1)' }
                            },
                            yVolume: {
                                type: 'linear',
                                position: 'right', // En el lado derecho
                                ticks: { display: false }, // No mostrar etiquetas
                                grid: { display: false }, // No mostrar rejilla
                                beginAtZero: true
                            },
                            x: {
                                ticks: { display: false },
                                grid: { display: false }
                            }
                        },
                        plugins: {
                            legend: { display: false },
                            tooltip: { 
                                enabled: true,
                                mode: 'index',
                                intersect: false,
                                callbacks: {
                                    label: (context) => {
                                        if (context.datasetIndex === 0) {
                                            return `Precio: ${formatPrice(context.parsed.y)}`;
                                        }
                                        if (context.datasetIndex === 1) {
                                            return `Volumen: ${formatCurrency(context.parsed.y)}`;
                                        }
                                        return '';
                                    }
                                }
                            }
                        }
                    }
                });
            }
            
            function updateChart(coinData) {
                if (!memecoinChart) return;
                
                const history = coinData.priceHistory.slice(-50); // Ãšltimos 50 puntos
                const volumeHistory = (coinData.volumeHistory || []).slice(-50);
                
                memecoinChart.data.labels = history.map((_, i) => i + 1);
                memecoinChart.data.datasets[0].data = history; // Dataset de Precio
                memecoinChart.data.datasets[1].data = volumeHistory; // Dataset de Volumen
                
                memecoinChart.update('none'); // 'none' para evitar animaciones parpadeantes
            }

            function updateSelectedCoinPrice(price) {
                modalCoinPriceEl.textContent = `${formatPrice(price)}`;
            }

            // --- ACCIONES DEL JUGADOR ---

            function selectCoin(coinId) {
                selectedCoinId = coinId;
                const coinData = allCoinsCache.get(coinId);
                
                if (!coinData) return;
                
                // Actualizar info del modal
                modalCoinNameEl.textContent = `${coinData.name} (${coinData.symbol})`;
                updateSelectedCoinPrice(coinData.currentPrice);
                
                // Actualizar grÃ¡fica y mostrar modal
                updateChart(coinData);
                showModal(chartModalEl);
                
                // Resaltar selecciÃ³n en la lista
                Array.from(memecoinListEl.children).forEach(child => {
                    child.classList.toggle('bg-solana-purple/50', child.dataset.coinId === coinId);
                    child.classList.toggle('bg-gray-800', child.dataset.coinId !== coinId);
                });
            }
            
            // Formulario de Crear Moneda
            createCoinFormEl.addEventListener('submit', async (e) => {
                e.preventDefault();
                const name = coinNameEl.value.trim();
                const symbol = coinSymbolEl.value.trim().toUpperCase();
                const imageUrl = coinImageUrlEl.value.trim();
                const initialSsol = parseFloat(coinInitialSsolEl.value);
                const initialTokens = parseFloat(coinInitialTokensEl.value);
                
                if (!name || !symbol || isNaN(initialSsol) || isNaN(initialTokens) || initialSsol <= 0 || initialTokens <= 0) {
                    showMessage("Por favor, completa todos los campos de liquidez con valores vÃ¡lidos.");
                    return;
                }

                const launchCost = 0.01;
                const totalCost = launchCost + initialSsol;

                try {
                    await runTransaction(db, async (transaction) => {
                        const playerRef = doc(playersRef, currentUserId);
                        const playerDoc = await transaction.get(playerRef);

                        if (!playerDoc.exists()) {
                            throw new Error("No se encontrÃ³ tu jugador.");
                        }
                        
                        const currentBalance = playerDoc.data().sSOL_balance;
                        if (currentBalance < totalCost) {
                            throw new Error(`Fondos insuficientes. Necesitas ${formatNumber(totalCost)} sSOL (0.01 de fee + ${formatNumber(initialSsol)} de liquidez).`);
                        }
                        
                        // Cobrar al jugador
                        transaction.update(playerRef, {
                            sSOL_balance: currentBalance - totalCost
                        });
                        
                        // Crear la moneda
                        const newCoinRef = doc(roomRef); // Genera un ID automÃ¡tico
                        const price = initialSsol / initialTokens;
                        
                        transaction.set(newCoinRef, {
                            name: name,
                            symbol: symbol,
                            creatorId: currentUserId,
                            imageUrl: imageUrl || `https://placehold.co/40x40/${newCoinRef.id.slice(0,6)}/FFFFFF?text=${symbol}`,
                            sSolPool: initialSsol, 
                            tokenPool: initialTokens,
                            currentPrice: price,
                            priceHistory: [price],
                            volumeHistory: [0], 
                            allTimeHigh: price, // <-- NUEVO: ATH Inicial
                            createdAt: serverTimestamp(),
                            marketCap: initialSsol * 2, 
                            volume: 0,
                            holderCount: 1,
                            lastHolderCountChange: 1, 
                            creatorFeesSsol: 0, 
                            creatorFeesToken: 0, 
                            botSsolPool: 400, 
                            botTokenPool: 0
                        });

                        // Dar al creador sus tokens iniciales
                        const walletRef = doc(playersRef, currentUserId, 'wallet', newCoinRef.id);
                        transaction.set(walletRef, {
                            amount: initialTokens
                        });
                    });
                    
                    hideModal(createCoinModalEl); // Ocultar modal al Ã©xito
                    showMessage(`Â¡Moneda ${name} (${symbol}) lanzada con Ã©xito!`);
                    createCoinFormEl.reset(); // Limpiar formulario

                } catch (error) {
                    console.error("Error al lanzar moneda:", error);
                    showMessage(error.message);
                }
            });

            // --- LÃ“GICA DE BOTS (REACTIVA Y PROACTIVA) ---
            
            function simulateBotTrade(coinData, playerAction, forceBuyProbability = null) {
                if (playerAction !== 'proactive' && Math.random() > 0.3) {
                     return {};
                }

                let { 
                    botSsolPool, botTokenPool, sSolPool, tokenPool, 
                    volume, priceHistory, volumeHistory, creatorId,
                    creatorFeesSsol, creatorFeesToken, marketCap, allTimeHigh
                } = coinData;

                if (creatorId === 'bot') return {};
                
                let buyProbability = 0.6; 
                if (playerAction === 'proactive' && forceBuyProbability !== null) {
                    buyProbability = forceBuyProbability;
                }
                
                const isBuy = Math.random() < buyProbability;

                let ssolTraded = 0;
                let ssolFee = 0;
                let tokenFee = 0;
                let ssolForTrade = 0;
                let tokensForTrade = 0;
                let tokensReceived = 0;
                let ssolReceived = 0;
                let finalSsolPool = sSolPool;
                let finalTokenPool = tokenPool;
                let newCreatorFeesSsol = creatorFeesSsol || 0;
                let newCreatorFeesToken = creatorFeesToken || 0;
                let tradeRef = null; // Para log de trade

                if (isBuy) { // BOT COMPRA
                    // --- NUEVO: MONTO VARIABLE ---
                    const ssolToSpend = Math.pow(Math.random(), 2) * (botSsolPool * 0.1); // Sesgado a pequeÃ±o, mÃ¡x 10%
                    if (ssolToSpend < 0.01 || botSsolPool < ssolToSpend) return {};
                    
                    botSsolPool -= ssolToSpend;
                    ssolTraded = ssolToSpend; // Volumen total de la operaciÃ³n
                    
                    const creatorFee = ssolToSpend * CREATOR_FEE;
                    const lpFee = ssolToSpend * LP_FEE;
                    ssolForTrade = ssolToSpend - creatorFee - lpFee;
                    
                    const k = sSolPool * tokenPool;
                    const newSsolPool_k = sSolPool + ssolForTrade + lpFee;
                    finalTokenPool = k / newSsolPool_k;
                    tokensReceived = tokenPool - finalTokenPool;
                    
                    finalSsolPool = newSsolPool_k;
                    newCreatorFeesSsol += creatorFee;
                    
                    botTokenPool += tokensReceived;
                    
                    tradeRef = { type: 'buy', coinSymbol: coinData.symbol, amountSsol: ssolToSpend, amountToken: tokensReceived, price: coinData.currentPrice, timestamp: serverTimestamp() };
                    
                } else { // BOT VENDE
                    const isRugpull = ((playerAction === 'sell' || playerAction === 'proactive') && Math.random() < 0.1);
                    // --- NUEVO: MONTO VARIABLE ---
                    const sellPercentage = isRugpull ? 0.5 : (Math.pow(Math.random(), 2) * 0.1); // Sesgado a pequeÃ±o, mÃ¡x 10%
                    
                    const tokensToSell = botTokenPool * sellPercentage;
                    if (tokensToSell < 1) return {};

                    botTokenPool -= tokensToSell;
                    
                    const creatorFee = tokensToSell * CREATOR_FEE;
                    const lpFee = tokensToSell * LP_FEE;
                    tokensForTrade = tokensToSell - creatorFee - lpFee;

                    const k = sSolPool * tokenPool;
                    const newTokenPool_k = tokenPool + tokensForTrade + lpFee;
                    finalSsolPool = k / newTokenPool_k;
                    ssolReceived = sSolPool - finalSsolPool;
                    ssolTraded = ssolReceived; // Volumen total de la operaciÃ³n

                    finalTokenPool = newTokenPool_k;
                    newCreatorFeesToken += creatorFee;
                    
                    botSsolPool += ssolReceived;
                    
                    tradeRef = { type: 'sell', coinSymbol: coinData.symbol, amountSsol: ssolReceived, amountToken: tokensToSell, price: coinData.currentPrice, timestamp: serverTimestamp() };

                    if (isRugpull) {
                        console.warn(`Â¡BOT RUGPULL SIMULADO! VendiÃ³ ${formatNumber(tokensToSell)} tokens.`);
                    }
                }

                const newPrice = finalSsolPool / finalTokenPool;
                // --- NUEVO: ACTUALIZAR ATH ---
                const newAllTimeHigh = Math.max(allTimeHigh || 0, newPrice);
                const newMarketCap = newPrice * (finalTokenPool + botTokenPool);
                const newHistory = [...priceHistory, newPrice].slice(-50);
                const newVolumeHistory = [...(volumeHistory || []), ssolTraded].slice(-50); 
                const newVolume = volume + ssolTraded;

                return {
                    sSolPool: finalSsolPool,
                    tokenPool: finalTokenPool,
                    botSsolPool: botSsolPool,
                    botTokenPool: botTokenPool,
                    currentPrice: newPrice,
                    priceHistory: newHistory,
                    volumeHistory: newVolumeHistory, 
                    volume: newVolume,
                    marketCap: newMarketCap,
                    creatorFeesSsol: newCreatorFeesSsol,
                    creatorFeesToken: newCreatorFeesToken,
                    tradeLog: tradeRef, 
                    allTimeHigh: newAllTimeHigh // <-- NUEVO: Devolver ATH
                };
            }

            async function proactiveBotLoop() {
                if (allCoinsCache.size > 0) {
                    
                    for (const [coinId, coin] of allCoinsCache.entries()) {
                        
                        const allTimeHigh = coin.allTimeHigh || coin.priceHistory[0] || 0;
                        const currentPrice = coin.currentPrice;
                        let buyProbability = 0.5; // Base neutral
                        let tradeProbability = 0.0; // Base de no-comercio

                        if (allTimeHigh > 0 && (currentPrice / allTimeHigh) < 0.2) {
                            // --- LÃ“GICA DE TOKEN MUERTO ---
                            // El precio ha caÃ­do mÃ¡s del 80%
                            tradeProbability = 0.1; // 10% de probabilidad de que un bot lo "limpie"
                            buyProbability = 0.05; // 95% de probabilidad de que sea una venta (liquidaciÃ³n)
                            
                        } else {
                            // --- LÃ“GICA DE HYPE (TOKEN VIVO) ---
                            const priceHistory = coin.priceHistory || [];
                            let priceChange = 0;
                            if (priceHistory.length > 1) {
                                const prevPrice = priceHistory[priceHistory.length - 2];
                                if (prevPrice > 0) {
                                    priceChange = (coin.currentPrice - prevPrice) / prevPrice;
                                }
                            }
                            
                            const priceChangeScore = Math.max(0, Math.min(1, priceChange / 0.1)); 
                            const volumeRatio = (coin.sSolPool > 0) ? (coin.volume || 0) / coin.sSolPool : 0;
                            const volumeScore = Math.max(0, Math.min(1, volumeRatio / 10));
                            const holderScore = Math.max(0, Math.min(1, (coin.lastHolderCountChange || 0) / 5));

                            const totalHypeScore = (priceChangeScore + volumeScore + holderScore) / 3;
                            tradeProbability = totalHypeScore * 0.5; // Prob. de comerciar (hasta 50%)

                            // --- LÃ“GICA DE ASEGURAR GANANCIAS ---
                            if (priceChange > 0) {
                                // FOMO (subiendo)
                                buyProbability = 0.5 + (totalHypeScore * 0.4); // Rango 0.5 a 0.9 (sesgo de compra)
                            } else {
                                // Profit-Taking / Panic (bajando)
                                buyProbability = 0.5 - ((1 - totalHypeScore) * 0.4); // Rango 0.1 a 0.5 (sesgo de venta)
                            }
                        }
                        
                        // Decidir si comerciar
                        if (Math.random() < tradeProbability) {
                            
                            const coinRef = doc(roomRef, coinId);
                            try {
                                await runTransaction(db, async (transaction) => {
                                    const coinDoc = await transaction.get(coinRef);
                                    if (!coinDoc.exists()) return;
                                    
                                    const coinData = coinDoc.data();
                                    const botUpdates = simulateBotTrade(coinData, 'proactive', buyProbability); // Pasamos la prob. de compra
                                    
                                    if (Object.keys(botUpdates).length > 0) {
                                        if (botUpdates.tradeLog) {
                                            const newTradeRef = doc(tradesRef);
                                            transaction.set(newTradeRef, botUpdates.tradeLog);
                                            delete botUpdates.tradeLog; 
                                        }
                                        botUpdates.lastHolderCountChange = 0; 
                                        
                                        // Asegurarse de que el ATH se actualiza (ya se hace en simulateBotTrade)
                                        transaction.update(coinRef, botUpdates);
                                    }
                                });
                            } catch (e) {
                                console.warn("Fallo la transacciÃ³n proactiva del bot (conflicto normal):", e.message);
                            }
                        }
                    }
                }
                
                setTimeout(proactiveBotLoop, 5000);
            }

            // Formulario de Compra
            buyFormEl.addEventListener('submit', async (e) => {
                e.preventDefault();
                const ssolToSpend = parseFloat(buyAmountEl.value);
                
                if (!selectedCoinId || isNaN(ssolToSpend) || ssolToSpend <= 0) {
                    showMessage("Ingresa un monto vÃ¡lido.");
                    return;
                }
                
                let tokensReceived = 0; 
                
                try {
                    await runTransaction(db, async (transaction) => {
                        const playerRef = doc(playersRef, currentUserId);
                        const coinRef = doc(roomRef, selectedCoinId);
                        const walletRef = doc(playersRef, currentUserId, 'wallet', selectedCoinId);
                        
                        const [playerDoc, coinDoc, walletDoc] = await Promise.all([
                            transaction.get(playerRef),
                            transaction.get(coinRef),
                            transaction.get(walletRef)
                        ]);
                        
                        if (!playerDoc.exists() || !coinDoc.exists()) {
                            throw new Error("No se encontraron datos del jugador o la moneda.");
                        }
                        
                        let playerData = playerDoc.data();
                        let coinData = coinDoc.data();
                        
                        if (playerData.sSOL_balance < ssolToSpend) {
                            throw new Error("sSOL insuficiente.");
                        }
                        
                        // 1. Simular bot reactivo
                        const botUpdates = simulateBotTrade(coinData, 'reactive_buy');
                        coinData = { ...coinData, ...botUpdates };
                        
                        // 2. Calcular trade del jugador con comisiones
                        const ssolTraded = ssolToSpend; // El volumen es el total
                        const creatorFee = ssolToSpend * CREATOR_FEE;
                        const lpFee = ssolToSpend * LP_FEE;
                        const ssolForTrade = ssolToSpend - creatorFee - lpFee;

                        const k = coinData.sSolPool * coinData.tokenPool;
                        const newSsolPool_k = coinData.sSolPool + ssolForTrade + lpFee;
                        const newTokenPool = k / newSsolPool_k;
                        tokensReceived = coinData.tokenPool - newTokenPool; 
                        
                        const finalSsolPool = newSsolPool_k;
                        
                        // 3. Calcular nuevos totales
                        const newPrice = finalSsolPool / newTokenPool;
                        const newAllTimeHigh = Math.max(coinData.allTimeHigh || 0, newPrice); // <-- NUEVO: Actualizar ATH
                        const newMarketCap = newPrice * (newTokenPool + coinData.botTokenPool);
                        const newHistory = [...coinData.priceHistory, newPrice].slice(-50);
                        const newVolumeHistory = [...(coinData.volumeHistory || []), ssolTraded].slice(-50);
                        const newVolume = coinData.volume + ssolTraded;
                        const newCreatorFeesSsol = (coinData.creatorFeesSsol || 0) + creatorFee;

                        // 4. LÃ³gica de Holders
                        let newHolderCount = coinData.holderCount;
                        let holderChange = 0;
                        const currentTokens = walletDoc.exists() ? walletDoc.data().amount : 0;
                        if (currentTokens < 0.01) { 
                            newHolderCount++;
                            holderChange = 1; // Para el hype del bot
                        }
                        const newLastHolderCountChange = (coinData.lastHolderCountChange || 0) + holderChange;
                        
                        // 5. Actualizar documentos
                        transaction.update(playerRef, {
                            sSOL_balance: playerData.sSOL_balance - ssolToSpend
                        });
                        
                        transaction.set(walletRef, {
                            amount: currentTokens + tokensReceived
                        }, { merge: true });
                        
                        // Loguear trade del bot (si hubo)
                        if (botUpdates.tradeLog) {
                            const newTradeRef = doc(tradesRef);
                            transaction.set(newTradeRef, botUpdates.tradeLog);
                            delete botUpdates.tradeLog;
                        }
                        
                        // Loguear trade del jugador
                        const playerTradeRef = doc(tradesRef);
                        transaction.set(playerTradeRef, { type: 'buy', coinSymbol: coinData.symbol, amountSsol: ssolToSpend, amountToken: tokensReceived, price: coinData.currentPrice, timestamp: serverTimestamp() });

                        transaction.update(coinRef, {
                            ...botUpdates, 
                            sSolPool: finalSsolPool, 
                            tokenPool: newTokenPool,
                            currentPrice: newPrice,
                            priceHistory: newHistory,
                            volume: newVolume,
                            volumeHistory: newVolumeHistory,
                            marketCap: newMarketCap,
                            holderCount: newHolderCount,
                            lastHolderCountChange: newLastHolderCountChange,
                            creatorFeesSsol: newCreatorFeesSsol,
                            allTimeHigh: newAllTimeHigh // <-- NUEVO: Guardar ATH
                        });
                    });
                    
                    showMessage(`Â¡Compraste ${formatNumber(tokensReceived)} ${allCoinsCache.get(selectedCoinId).symbol}!`);
                    buyAmountEl.value = '';

                } catch (error) {
                    console.error("Error al comprar:", error);
                    showMessage(error.message);
                }
            });
            
            // Formulario de Venta
            sellFormEl.addEventListener('submit', async (e) => {
                e.preventDefault();
                const tokensToSell = parseFloat(sellAmountEl.value);
                
                if (!selectedCoinId || isNaN(tokensToSell) || tokensToSell <= 0) {
                    showMessage("Ingresa un monto vÃ¡lido.");
                    return;
                }

                try {
                    await runTransaction(db, async (transaction) => {
                        const playerRef = doc(playersRef, currentUserId);
                        const coinRef = doc(roomRef, selectedCoinId);
                        const walletRef = doc(playersRef, currentUserId, 'wallet', selectedCoinId);

                        const [playerDoc, coinDoc, walletDoc] = await Promise.all([
                            transaction.get(playerRef),
                            transaction.get(coinRef),
                            transaction.get(walletRef)
                        ]);

                        if (!playerDoc.exists() || !coinDoc.exists()) {
                            throw new Error("No se encontraron datos del jugador o la moneda.");
                        }
                        
                        if (!walletDoc.exists() || walletDoc.data().amount < tokensToSell) {
                            throw new Error("No tienes suficientes tokens para vender.");
                        }

                        let playerData = playerDoc.data();
                        let coinData = coinDoc.data();
                        const walletData = walletDoc.data();

                        // 1. Simular bot reactivo
                        const botUpdates = simulateBotTrade(coinData, 'reactive_sell');
                        coinData = { ...coinData, ...botUpdates };
                        
                        // 2. Calcular trade del jugador con comisiones
                        const creatorFee = tokensToSell * CREATOR_FEE;
                        const lpFee = tokensToSell * LP_FEE;
                        const tokensForTrade = tokensToSell - creatorFee - lpFee;

                        const k = coinData.sSolPool * coinData.tokenPool;
                        const newTokenPool_k = coinData.tokenPool + tokensForTrade + lpFee;
                        const newSsolPool = k / newTokenPool_k;
                        const ssolReceived = coinData.sSolPool - newSsolPool;
                        
                        const finalTokenPool = newTokenPool_k;
                        const ssolTraded = ssolReceived; // El volumen es el sSOL recibido

                        if (ssolReceived < 0.00001) {
                            throw new Error("La liquidez es demasiado baja para esta venta.");
                        }
                        
                        // 3. Calcular nuevos totales
                        const newPrice = newSsolPool / finalTokenPool; 
                        const newAllTimeHigh = Math.max(coinData.allTimeHigh || 0, newPrice); // <-- NUEVO: Actualizar ATH
                        const newMarketCap = newPrice * (finalTokenPool + coinData.botTokenPool);
                        const newHistory = [...coinData.priceHistory, newPrice].slice(-50);
                        const newVolumeHistory = [...(coinData.volumeHistory || []), ssolTraded].slice(-50);
                        const newVolume = coinData.volume + ssolTraded;
                        const newCreatorFeesToken = (coinData.creatorFeesToken || 0) + creatorFee;

                        // 4. LÃ³gica de Holders
                        let newHolderCount = coinData.holderCount;
                        let holderChange = 0;
                        const currentTokens = walletData.amount;
                        const newAmountInWallet = currentTokens - tokensToSell;
                        if (newAmountInWallet < 0.01 && currentTokens >= 0.01) { 
                            newHolderCount--;
                            holderChange = -1; // Para el hype del bot
                        }
                        const newLastHolderCountChange = (coinData.lastHolderCountChange || 0) + holderChange;
                        
                        // 5. Actualizar documentos
                        transaction.update(playerRef, {
                            sSOL_balance: playerData.sSOL_balance + ssolReceived
                        });
                        
                        transaction.set(walletRef, {
                            amount: newAmountInWallet
                        }, { merge: true });
                        
                        // Loguear trade del bot (si hubo)
                        if (botUpdates.tradeLog) {
                            const newTradeRef = doc(tradesRef);
                            transaction.set(newTradeRef, botUpdates.tradeLog);
                            delete botUpdates.tradeLog;
                        }
                        
                        // Loguear trade del jugador
                        const playerTradeRef = doc(tradesRef);
                        transaction.set(playerTradeRef, { type: 'sell', coinSymbol: coinData.symbol, amountSsol: ssolReceived, amountToken: tokensToSell, price: coinData.currentPrice, timestamp: serverTimestamp() });

                        transaction.update(coinRef, {
                             ...botUpdates, 
                            sSolPool: newSsolPool,
                            tokenPool: finalTokenPool,
                            currentPrice: newPrice,
                            priceHistory: newHistory,
                            volume: newVolume,
                            volumeHistory: newVolumeHistory,
                            marketCap: newMarketCap,
                            holderCount: newHolderCount,
                            lastHolderCountChange: newLastHolderCountChange,
                            creatorFeesToken: newCreatorFeesToken,
                            allTimeHigh: newAllTimeHigh // <-- NUEVO: Guardar ATH
                        });
                    });
                    
                    showMessage(`Â¡Vendiste ${formatNumber(tokensToSell)} ${allCoinsCache.get(selectedCoinId).symbol}!`);
                    sellAmountEl.value = '';

                } catch (error) {
                    console.error("Error al vender:", error);
                    showMessage(error.message);
                }
            });

            // --- INICIAR EL JUEGO ---
            initAuth();
            initChart();
            
            // Iniciar el bucle de bots proactivos (se llama una vez, luego se auto-llama)
            setTimeout(proactiveBotLoop, 5000); 
            
            showMessage("Â¡Bienvenido! Bots actualizados con lÃ³gica de 'Token Muerto' (>80% de caÃ­da) y 'Toma de Ganancias'.");
        
        } // --- FIN: ENVOLTORIO MAIN ASYNC ---

        // Llamar a la funciÃ³n principal para iniciar todo
        main().catch(err => {
            console.error("Error fatal al iniciar la aplicaciÃ³n:", err);
            const messageModalEl = document.getElementById('message-modal');
            const messageTextEl = document.getElementById('message-text');
            if (messageTextEl && messageModalEl) {
                messageTextEl.textContent = "Error fatal al iniciar. Revisa la consola.";
                messageModalEl.classList.remove('hidden');
            }
        });

    </script>
</body>
</html>

